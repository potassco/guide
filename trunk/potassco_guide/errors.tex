\section{Errors and Warnings}\label{sec:errorwarn}

\com{RK: cleanup of warnings is on my todo list since quite a while.
This section does not always describe the current behavior of \gringo\ but the behavior I would like to have.}
This section explains the most frequent errors and warnings 
related to inappropriate inputs or command line options that,
if they occur,
lead to messages sent to the standard error stream.
The difference between errors and warnings is that the former involve premature termination,
while the latter are hints pointing at possibly corrupt input that can still be processed further.

\subsection{Errors}\label{sec:error}

Most of the errors in the following start with the prefix:
\begin{lstlisting}[numbers=none,escapechar=@]
*** ERROR: (@\textit{System}@)
\end{lstlisting}
where \codeit{System} is either \code{gringo}, \code{clingo}, or \code{clasp} depending on the system.
In the following sections, we use \codeit{Error} to denote this prefix.
All of the errors with this prefix are fatal and lead to immediate termination.

\subsubsection{Parsing Command Line Options}\label{subsec:error:options}

We start with errors emmited during command line parsing,
which are handled equally by \gringo, \clasp, and \clingo.
All our tools try to expand incomplete (long) options to recognized ones.
Parsing command line options may nonetheless fail due to the following three reasons:
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Error}@: In context '@\textit{Context}@': unknown option: '@\textit{Option}@'
@\textit{Error}@: In context '@\textit{Context}@': \
ambiguous option: '@\textit{Option}@' could be:
  @\textit{Option1}@
  @\textit{Option2}@
  ...
@\textit{Error}@: In context '<@\textit{Context}@>': \
'@\textit{Arg}@': invalid value for: '@\textit{Option}@'
*** Info : (@\textit{System}@): Try '--help' for usage information
\end{lstlisting}
%
The first error means that the option~\codeit{Option}
could not be expanded to one that is recognized.
While the second error expresses that the result of expanding~\codeit{Option} is ambiguous.
It is followed by a list of option canditates \codeit{Option1}, \codeit{Option2}, \dots, all sharing the same prefix.
Finally, the third error occurs if the argument~\codeit{Arg} is invalid for option~\codeit{Option}.
All three error messages include a context~\codeit{Context} in which the option is parsed.
Often, this is simply the system name 
but can also be the name of a configuration in a portfolio file
or the string \code{tester} for errors in options regarding the disjunctive tester.\comment{references to clasps command-line options would be nice}
The last line is printed in all three cases.
It indicates that option \code{--help} can be used to display the available options and their arguments.

\subsubsection{Parsing and Checking Logic Programs}\label{subsec:error:parselp}

Next, we consider errors emitted durnig the parsing and checking of logic programs.
Unlike the error messages in the previous section, 
such errors include location information to ease finding and fixing the problem.
Each of the error messages below begins with a location followed by the string \code{error} and a short description of the error in~\codeit{Message}:
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{File}@:@\textit{Line}@:@\textit{Column}@-@\textit{Column}@: error: @\textit{Message}@
  @\textit{Information}@
@\textit{File}@:@\textit{Line}@:@\textit{Column}@-@\textit{Column}@: note: @\textit{Message}@
  @\textit{Information}@
...

\end{lstlisting}
The location refers to a string in a source file,
specified by file name~\codeit{File},
line number~\codeit{Line},
and beginning and ending column number~\code{Column}
(column $n$ refers to the $n$-th symbol in a line).
Error messages are sometimes followed by further desriptions in the string~\codeit{Information} indented by two spaces.
An optional list of similarly structured notes, discernable via the string~\code{note}, can follow this part.
Such notes typically refer to locations that are in conflict with the object referred to in the location of the error message.
Multiple error messages of this kind might be reported;
each error message is terminated with two newlines after the notes.

\paragraph{Logic Program Parsing}
We start our description with errors that may be encountered during parsing,
where the following one indicates a syntax error in the input:
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: error: syntax error, unexpected @\textit{Token}@
\end{lstlisting}
%
To correct this error, please investigate the indicated location
and check whether something looks strange there
(like a missing period, an unmatched parenthesis, etc.).
Note that the parser tries to recover from a syntax error.
This typically means that everything up to the next period is ignored.

\paragraph{Safety Checking}
The next error occurs if an input program is not safe:
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: error: unsafe variables in
  @\textit{Rule}@
@\textit{Location}@: note: '@\textit{Var}@' is unsafe
...
\end{lstlisting}
%
Along with the error message,
the affected rule~\codeit{Rule} and a list of all unsafe variable occurrences~\codeit{Var} are reported.
The first action to take usually consists of checking whether
variable~\codeit{Var} is actually in the scope of any atom
(in the positive body of \codeit{Rule}) that can bind it.%
\footnote{%
  Recall from Section~\ref{subsec:gringo:arith} and~\ref{subsec:gringo:comp}
  that variables in the scope of built-in arithmetic functions are only bound by their corresponding atoms in some special cases 
  and that built-in comparison predicates do not bind variables.}
Also check for variables that occur in aggregate elements (cf.\ Section~\ref{subsec:gringo:aggregate}) or conditional literals (cf.\ Section~\ref{subsec:gringo:condition});
you might have to bind them with additional positive atoms in the conditions.

\paragraph{Script Execution and Parsing}
If an error in an embedded script occurs (cf.~Section~\ref{subsec:lang:extfun}), the following error message is printed:
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: error: failed to execute script:
  @\textit{Information}@
  ...
\end{lstlisting}
%
The information printed depends on the error that occurred when executing the embedded script.
This can for example be parse errors or errors that occurred when executing the script.
Typically, the information contains a trace where the error occurred.

\paragraph{Defining Constants}
There are three errors associated to \code{\#const} statements (cf.~Section~\ref{subsec:gringo:meta}).
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: error: cyclic constant definition:
  @\textit{Constant}@
@\textit{Location}@: note: cycle involves definition:
  @\textit{Constant}@
...

@\textit{Location}@: error: redefinition of constant:
  @\textit{Constant}@
@\textit{Location}@: note: constant also defined here:
  @\textit{Constant}@
...

@\textit{Location}@: error: evaluation of constant failed:
  @\textit{Constant}@
@\textit{Note}@
...
\end{lstlisting}
The strings~\codeit{Constant} depict the affected \code{\#const} statements.
The first error is printed if the statements rely on each other cyclically.
The second error message is printed if a constant is defined more than once.
Each statement involved in the cycle or redefinition is printed in the corresponding error message.
The third error occurs if the right hand side of \code{\#const} statement cannot be evaluated.
This happens for example if it contains an undefined term, which is then indicated in the notes.

If at least one of the errors above is reported,
then \gringo\ or \clingo\ terminates after parsing and checking with the error message:
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Error}@: grounding stopped because of errors
\end{lstlisting}

\begin{note}
No more than 20 errors are printed.
If this limit is exceeded, the application stops parsing or safety checking and terminates.
\end{note}

\subsubsection{Parsing Logic Programs in \smodels\ Format}\label{subsec:error:lparse}

\com{RK2BK: please check}
The following error message is issued by (embedded) \clasp:
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Error}@: Parse Error: @\textit{Message}@
\end{lstlisting}
%
This error means that the input does not comply with \smodels's numerical format~\cite{lparseManual}.
If you are using \gringo\ to ground logic programs,
this error should never occur.

\subsubsection{Solving Incremental Programs}
\com{RK2BK: clasp uses another error format than gringo; I would like to format the redefinition error slightly differently in gringo... }
The following error is issued by (embedded) \clasp\ if a program is not modular:
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Error}@: program not modular: Redefinition of atom <@\textit{Atom}@,@\textit{Id}@>
  @\textit{Information}@
\end{lstlisting}
where \codeit{Atom} is the string representation of the atom that is redefined
and \codeit{Id} is the unique identifier of the atom introduced when translating the logic program into \smodels\ format.
If the scripting API~(cf.~Section~\ref{sec:multi}) is used for grounding,
then the error message is followed by a trace,
indicating the source code location where the program has been grounded.

\begin{note}
Only the case that an atom is redefined is checked by clasp.
The case when there is a positive cycle over two or more incremental steps is not detected,
which possibly leads to unwanted answer sets.
\end{note}

\subsection{Warnings}\label{subsec:warn}

This section describes warnings that may be reported by \gringo\ or \clingo.
Unlike errors, warnings do not terminate the application 
but rather hint at possible problems, which should be investigated.
Most warnings have a similar format as the errors described in Sections~\ref{subsec:error:parselp};
the only difference is that the location is followed by the string \code{warning}.

\begin{note}
No more than 20 warnings are printed.
If this limit is exceeded you should definitely fix some warnings.
\end{note}

\subsubsection{Undefined Terms}\label{sec:warn:undefterm}
This warning may occur within an arithmetic evaluation (cf.~Section~\ref{subsec:gringo:arith})
or if an error occurs while evaluating an external function (cf.~Section~\ref{subsec:lang:extfun}):
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: warning: term undefined:
  @\textit{Term}@
...
\end{lstlisting}
%
It typically means that either a (symbolic) constant or a compound term (over an uninterpreted function)
has occurred in the scope of some built-in arithmetic function.
%
The string~\codeit{Term} depicts the term that failed to evaluate.
%
The warning message might be followed by further notes.
For example, 
if the evaluation of an external function failed,
by a trace indicating the location of the error within the source code of the external function.
%
Typically, it is simple to fix occurrences of this warning
- for example, if the term ``\code{X/Y}'' causes a warning,
it can be silenced by adding the comparison literal~``\code{Y!=0}'' to the body of a rule (or condition).
We suggest to silence all of these warnings in this manner
and not simply to disable the warning.

\begin{note}
Instantiations of rules, \code{\#show} statements, \code{\#external} statements, weak constraints, aggregate elements, and conditional literals
that contain undefined terms are discarded.
\end{note}

\subsubsection{Undefined Atoms}\label{sec:warn:undefatm}
This warning is emitted if an atom appears in the body of a rule or condition
that is never defined in the head of a rule or external statement:
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: warning: atom is undefined:
  @\textit{Atom}@
\end{lstlisting}
%
where \codeit{Atom} is the atom occurrence without a definition.
Often, this error indicates that a predicate has been misspelled 
or that an argument has accidentally been omitted.

\subsubsection{Nonmonotone Aggregates}\label{sec:warn:nonmon}
This warning is emitted if a nonmonotone aggregate is outputted during grounding:
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: warning: unstratified nonmonotone aggregate:
  @\textit{Information}@
  (applied translation might produce counter-intuitive results)
\end{lstlisting}
where \codeit{Information} indicates why an aggregate is undefined
- for example, if a \code{\#sum} aggregate contains negative weights.
Keep in mind that \gringo\ performs a static dependency analysis,
which is only an approximation of the dependencies of a logic program.
The aggregate occurrence might actually be stratified~(cf.~\cite{twgng03,aspcore2}),
in which case the warning can be silenced using option \code{-Wno-nonmonotone-aggregate} (cf.~Section~\ref{subsec:opt:gringo}).
In general, it is a good idea to use non-monotone aggregates only in integrity constraints,
where the aggregate is guaranteed to be stratified.

\begin{note}
The \smodels\ format only supports monotone aggregates.
All aggregates supported by \gringo\ are translated into monotone aggregates.
This translation might produce counter-intuitive results
if a nonmonotone aggregate is used recursively~(cf.~\cite{ferlif05a}).
\end{note}

\subsubsection{File Included Multiple Times}\label{sec:warn:incfile}
If a file is included multiple times,
either on the command line or with an include directive,
then the following warning is emitted:
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{Location}@: warning: already included file:
  @\textit{Filename}@
\end{lstlisting}


\begin{note}
Only the first include of a file is considered.
All additional includes are ignored.
\end{note}
