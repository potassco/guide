\section{Input Languages}\label{sec:language}

This section provides an overview of the input languages of
grounder \gringo, combined grounder and solver \clingo, and solver \clasp.
The joint input language of \gringo\ and \clingo\ is detailed in
Section~\ref{subsec:lang:gringo}.
Finally, Section~\ref{subsec:lang:clasp} is dedicated to the inputs handled by \clasp.

\subsection{Input Language of \gringo\ and \clingo}\label{subsec:lang:gringo}

The tool \gringo~\cite{gescth07a} is a grounder capable of translating
user-defined logic programs (usually, containing variables) into
equivalent ground (that is, variable-free) programs.
The output of \gringo\ can be piped into solver \clasp~\cite{gekanesc07a,gekasc09c},
which then computes answer sets.
System \clingo\ internally couples \gringo\ and \clasp, thus,
it takes care of both grounding and solving.
In contrast to \gringo\ outputting ground programs,
\clingo\ returns answer sets.

Usually, logic programs are specified in one or more (text) files whose names are
% passed via the command line
provided as arguments
in an invocation of either \gringo\ or \clingo.
% We below provide a description of
In what follows, we describe the
constructs belonging to the input language of \gringo\ and \clingo.

\subsubsection{Normal Programs and Integrity Constraints}\label{subsec:gringo:normal}
\index{Terms}
\index{Terms!Constants}
\index{Terms!Strings}
\index{Terms!Variables}
\index{Terms!Variables!Anonymous}
\index{Terms!Functions}
\index{Terms!\code{\#sup}}
\index{Terms!\code{\#inf}}

\begin{figure}
\railnontermfont{\rmfamily\itshape}%
\railalias{rusc}{\tt\char95}\railterm{rusc}
\railalias{rlsc}{[A-Za-z0-9\tt\char95']}\railterm{rlsc}
\railalias{any}{[\^{}\symbol{92}"$\dlsh$]}\railterm{any}
\railalias{bs}{\symbol{92}}\railterm{bs}
\railalias{esc}{[\symbol{92}"n]}\railterm{esc}
\begin{rail}
  term        : simpleterm | function | tuple;
  simpleterm  : (integer | constant | string | variable | rusc | '\#sup' | '\#inf');
  constant    : (rusc*) '[a-z]' (rlsc*);
  string      : '"' ((any | (bs esc))*) '"';
  variable    : (rusc*) '[A-Z]' (rlsc*);
  function    : constant '(' term (',' term*) ')';
  tuple       :          '(' (term (',' | ',' term+))? ')';
\end{rail}
\caption{Grammar for Terms.\label{fig:terms}}
\end{figure}

Every (non-propositional) logic program includes \emph{terms},
mainly to specify the arguments of atoms (see below).
The grammar for \gringo's (and \clingo's) terms is shown in Figure~\ref{fig:terms}.
The basic building blocks are simple terms:
\emph{integers}, \emph{constants}, \emph{strings}, and \emph{variables}
as well as the tokens `\var{\char`\_}', \const{\#sup}, and \const{\#inf}.
An integer is represented by means of an arithmetic expression,
further explained in Section~\ref{subsec:gringo:arith}.
Constants and variables are distinguished by their first letters,
which are \emph{lowercase} and \emph{uppercase}, respectively,
where leading occurrences of `\code{\char`\_}' are allowed
(may be useful to circumvent name clashes).
Furthermore, a string is an arbitrary sequence of characters
enclosed in double quotes (\code{"$\cdot$"}),
where any occurrences of `\code{\textbackslash}', newline, and double quote
must be escaped via `\code{\textbackslash\textbackslash}', `\code{\textbackslash n}',
and `\code{\textbackslash"}' respectively.
While a constant or string represents itself,
a variable is a placeholder for \emph{all} variable-free terms
in the language of a logic program.%
\footnote{The set of all terms constructible from the available
          constants and function symbols is called \emph{Herbrand universe}.}
Unlike a variable name whose recurrences within a rule refer to the same variable,
the token `\var{\char`\_}' (not followed by any letter)
stands for an \emph{anonymous variable} that does not recur anywhere.
(One can view this as if a new variable name is invented on each
 occurrence of `\var{\char`\_}'.)
In addition, there are the special constants \const{\#sup} and \const{\#inf}
representing the largest and smallest element among all variable-free terms, respectively;
we illustrate their use in Section~\ref{subsec:gringo:aggregate}.
Next, (uninterpreted) \emph{functions} are complex terms composed of a name (like a constant)
and one or more terms as arguments.
For instance,
\code{\const{at}(\const{peter},\const{time}(12),X)}
is a function with three arguments:
constant \const{peter}, another function \code{\const{time}(12)}
with an integer argument, and variable~\var{X}.
Finally, there are \emph{tuples}, which are similar to \emph{functions} but without a name.
Examples for tuples are:
the empty tuple \code{()} and
the tuple \code{(\const{at},\const{peter},\const{time}(12),X)} with four elements.
Tuples may optionally end in a comma `\code{,}'
for distinguishing one-elementary tuples.
That is, \code{($t$,)} is a one-elementary tuple,
while a term of form \code{($t$)} is equivalent to \code{$t$}.
Thus, \code{(42,)} is a one-elementary tuple, whereas \code{(42)} is not.
The above quadruple is equivalent to \code{(\const{at},\const{peter},\const{time}(12),X,)}.

Rules of the following forms are admitted in a
\emph{normal logic program} (with integrity constraints):
\par
\medskip
\begin{tabular}{rl@{}l}\label{eq:normal:rule}
\textbf{Rule:} & $A_0$&~\code{:-}~$L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Fact:} & $A_0$&\code{.}
\\
\textbf{Integrity Constraint:} & &~\code{:-}~$L_1\code{,}\dots\code{,}L_n$\code{.}
\end{tabular}
\index{Logic Programs}
\index{Logic Programs!Rules}%
\index{Logic Programs!Facts}%
\index{Logic Programs!Integrity Constraints}%
\par
\medskip
\noindent
The \emph{head}~$A_0$ of a rule or a fact is an \emph{atom} of the same
syntactic form as a constant or function.
\index{Logic Programs!Atoms}%
In the \emph{body} of a rule or an integrity constraint,
every $L_j$ for $1\leq j\leq n$ is a \emph{literal} of the form $A$ or $\code{not}~A$,
where $A$ is an atom and
the connective \code{not} denotes default negation.
\index{Logic Programs!Literals}%
\index{Logic Programs!Literals!Default Negation}%
We say that a literal~$L$ is \emph{positive} if it is an atom,
and \emph{negative} otherwise.
While the head atom~$A_0$ of a fact must unconditionally be true,
the intuitive reading of a rule corresponds to an implication:
if all positive literals in the rule's body are true and all negative
literals are satisfied, then~$A_0$ must be true.
On the other hand, an integrity constraint is a rule that filters solution candidates,
meaning that the literals in its body must not jointly be satisfied.

A set of propositional atoms is called a \emph{model} of a logic program if it satisfies all rules, facts, and integrity constraints.
Atoms are considered true if and only if they are in the model.
In ASP, a model is called an \emph{answer set} if every atom in the model has an (acyclic) derivation from the program.
%
See~\cite{gellif88b,gelfond08a,lifschitz08a} for formal definitions of answer sets of logic programs.

To get the idea, let us consider some small examples.
%
\begin{example}\label{ex:as:one}
Consider the following logic program:
%
\begin{lstlisting}[numbers=none]
a :- b.
b :- a.
\end{lstlisting}
%
When \pred{a} and \pred{b} are false, the bodies of both rules are false as well,
so that the rules are satisfied.
Furthermore, there is no (true) atom to be derived,
which shows that the empty set is an answer set.
On the other hand, 
if \pred{a} is true but \pred{b} is not,
then the first rule is unsatisfied because the body holds but the head does not.
Similarly, the second rule is unsatisfied if \pred{b} is true and \pred{a} is not.
Hence, an answer set cannot contain only one of the atoms \pred{a} and~\pred{b}.
It remains to investigate the set including both \pred{a} and~\pred{b}.
Although both rules are satisfied,
\pred{a} and~\pred{b} cannot be derived acyclically:
\pred{a} relies on~\pred{b}, and vice versa.
That is, the set including both \pred{a} and~\pred{b} is not an answer set.
Hence, the empty set is the only answer set of the logic program.
We say that there is a positive cycle through \pred{a} and~\pred{b}
subject to minimization.
\end{example}

Consider the following logic program:
%
\begin{lstlisting}[numbers=none]
a :- not b.
b :- not a.
\end{lstlisting}
%
Here, the empty set is not a model because both rules are unsatisfied.
However, the sets containing only~\pred{a} or only~\pred{b} are models.
To see that each of them is an answer set,
note that~\pred{a} is derived by the rule \code{\pred{a}\,:-\:not\:\pred{b}.}
if \pred{b} is false;
similarly,
\pred{b} is derived by \code{\pred{b}\,:-\:not\:\pred{a}.}
if \pred{a} is false.
Note that the set including both~\pred{a} and~\pred{b} is not an answer set
because neither atom can be derived if both are assumed to be true:
the bodies of the rules
\code{\pred{a}\,:-\:not\:\pred{b}.} and
\code{\pred{b}\,:-\:not\:\pred{a}.} are false.
Hence, we have that
either~\pred{a} or~\pred{b} belongs to
an answer set of the logic program.

To illustrate the use of facts and integrity constraints,
let us augment the previous logic program:
\begin{lstlisting}[numbers=none]
a :- not b.
b :- not a.
c.
:- c, not b.
\end{lstlisting}
Since \code{\pred{c}.} is a fact,
atom \pred{c} must unconditionally be true, i.e.,
it belongs to every model.
In view of this,
the integrity constraint
\code{:-\:c,\:not\:\pred{b}.}
tells us that \pred{b} must be true as well
in order to prevent its body from being satisfied.
However, this kind of reasoning does not provide us with
a derivation of \pred{b}.
Rather, we still need to make sure that the body
of the rule \code{\pred{b}\,:-\:not\:\pred{a}.} is satisfied,
so that atom~\pred{a} must be false.
Hence, the set containing \pred{b} and~\pred{c}
is the only answer set of our logic program.

In the above examples,
we used propositional logic programs to exemplify the idea
of an answer set: a model of a logic program such that all its true atoms are
(acyclically) derivable.
In practice, logic programs are typically non-propositional, i.e.,
they include schematic rules with variables.
The next example illustrates this.

\begin{example}\label{ex:flies}
Consider a child from the south pole watching cartoons,
where it sees a yellow bird that is not a penguin.
The child knows that penguins can definitely not fly (due to small wingspread),
but it is unsure about whether the yellow bird flies.
This knowledge is generalized by
the following schematic rules:
%
\lstinputlisting{examples/fly.lp} %[firstnumber=3]
%
The first rule expresses that it is generally possible that a bird flies,
unless the contrary, subject to the second rule, is the case.
The definite knowledge that penguins cannot fly
is specified by the third rule.

Later on, the child learns that the yellow bird
is a chicken called ``tweety'',
while its favorite penguin is called ``tux''.
The knowledge about these two individuals is
represented by the following facts:
\lstinputlisting[firstnumber=4]{examples/bird.lp}

When we instantiate the variable~\var{X} in the three schematic rules
with \const{tweety} and \const{tux},
we obtain the following ground rules:
%
\lstinputlisting[numbers=none,xrightmargin=-15pt,nolol]{examples/gfly.lp}
%
Further taking into account that \const{tweety} and \const{tux} are known to
be birds, that \const{tux} is a penguin, while \const{tweety} is not, and that
penguins can definitely not fly,
we can simplify the previous ground rules to obtain the following ones:%
\marginlabel{The reader can reproduce these ground rules
             by invoking:\\
             \code{\mbox{~}clingo --text \textbackslash\\
                   \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/fly.lp}{fly.lp}}\\
             or alternatively:\\
             \code{\mbox{~}gringo --text \textbackslash\\
                   \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/fly.lp}{fly.lp}}}
%
\lstinputlisting[numbers=none,nolol]{examples/sfly.lp}
%
Now it becomes apparent that \const{tweety}
may fly or not, while \const{tux} surely does not fly.
Thus, there are two answer sets for the three schematic rules above,
instantiated with \const{tweety} and \const{tux}.%
\marginlabel{To compute both answer sets,
             invoke:\\
             \code{\mbox{~}clingo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
                   \mbox{~}\attach{examples/fly.lp}{fly.lp} 0}\\
             or alternatively:\\
             \code{\mbox{~}gringo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
                   \mbox{~}\attach{examples/fly.lp}{fly.lp} | clasp 0}}
\end{example}

The above example illustrated how variables are used to represent all instances of
rules w.r.t.\ the language of a logic program.
In fact, grounder \gringo\ (or the grounding component of \clingo)
takes care of instantiating variables
such that an equivalent propositional logic program is obtained.
To this end,
rules are required to be \emph{safe},
\label{pg:safe}%
\index{Logic Programs!Safety}%
i.e.,
all variables in a rule must occur in some positive literal
(a literal not preceded by \code{not}) in the body of the rule.
For instance, the first two schematic rules in Example~\ref{ex:flies}
are safe because they include \code{\pred{bird}(\var{X})} in their positive bodies.
This tells \gringo\ (or the grounding component of \clingo)
that the values to be substituted for~\var{X} are limited to birds.

Up to now, we have introduced terms, facts, (normal) rules, and integrity constraints.
Before we proceed to describe handy extensions to this simple core language,
keep in mind that the role of a rule (or fact) is that an atom in the
head can be derived to be true if the body is satisfied.
Unlike this, an integrity constraint implements a test,
but it cannot be used to derive any atom.
This universal meaning still applies when more sophisticated language constructs,
as described in the following, are used.

\subsubsection{Classical Negation}\label{subsec:gringo:negation}
\index{Logic Programs!Literals!Classical Negation}

The connective \code{not} expresses default negation,
i.e., a literal $\code{not}~A$ is assumed to hold unless atom~$A$ is derived to be true.
In contrast, the classical (or strong) negation of an atom~\cite{gellif91a}
holds only if it can be derived.
Classical negation, indicated by symbol `\code{-}', is permitted in front of atoms.
That is, if $A$ is an atom, then $\code{-}A$ is
an atom representing the complement of~$A$.
The semantic relationship between $A$ and~$\code{-}A$
is simply that they
must not jointly hold.
Hence,
classical negation can be understood as a syntactic feature
allowing us to impose an integrity constraint \code{:-\;$A$,\:-$A$.}
without explicitly writing it in a logic program.
Depending on the logic program at hand,
it may be possible that neither~$A$ nor~$\code{-}A$ is contained in an answer set,
thus representing a state where the truth and the falsity of~$A$ are both unknown.

\begin{example}\label{ex:flies:neg}
Using classical negation,
we can rewrite the schematic rules in Example~\ref{ex:flies}
in the following way:
%
\lstinputlisting{examples/flycn.lp} % [firstnumber=3]
%
Given the individuals \const{tweety} and \const{tux},
classical negation is reflected by
the following (implicit) integrity constraints:%
\marginlabel{By invoking:\\
  \code{\mbox{~}clingo --text \textbackslash\\
        \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/flycn.lp}{flycn.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash\\
        \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/flycn.lp}{flycn.lp}}\\
the reader can observe
that the integrity constraint in Line~4 is indeed part of the grounding.
The second one in Line 5 is not printed;
it becomes obsolete by a static analysis exhibiting that
\const{tux} does surely not fly.}
%
\begin{lstlisting}[firstnumber=4]
:- flies(tweety), -flies(tweety).
:- flies(tux),    -flies(tux).
\end{lstlisting}
There are still two answer sets,
containing \code{-\pred{flies}(\const{tux})} and
either \code{\pred{flies}(\const{tweety})} or \code{-\pred{flies}(\const{tweety})}.

Now assume that we add the following fact to the program:
\begin{lstlisting}[numbers=none]
flies(tux).
\end{lstlisting}
Then,
\code{\pred{flies}(\const{tux})} must unconditionally be true,
and \code{-\pred{flies}(\const{tux})} is still derived by
an instance of the third schematic rule.
% There no longer is any answer set for our new program using classical negation.
% In fact, answer set candidates that contain both
Since every answer set candidate containing
both \code{\pred{flies}(\const{tux})} and \code{-\pred{flies}(\const{tux})}
triggers
% \code{\pred{flies}(\const{tux})} and
% \code{\pred{-flies}(\const{tux})} violate
the (implicit) integrity constraint in Line~5,
there is no longer any answer set.
\end{example}

\subsubsection{Disjunction}\label{subsec:gringo:disjunction}
\index{Logic Programs!Disjunction}
Disjunctive logic programs permit connective~`\code{;}' between atoms in rule heads.%
\footnote{Note that disjunction in rule heads was not supported by \clasp\ and \clingo\ versions before series~3 and~4, respectively.}
\par
\medskip
\begin{tabular}{rl@{}l}\label{eq:disjunctive:rule}
\textbf{Rule:} & $A_0\text{\code{;}}\dots\text{\code{;}}A_m$&~\code{:-}~$L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Fact:} & $A_0\text{\code{;}}\dots\text{\code{;}}A_m$&\code{.}
\end{tabular}
\index{Logic Programs}
\index{Logic Programs!Rules!Disjunctive}%
\index{Logic Programs!Facts!Disjunctive}%
\par
\medskip
\noindent
A disjunctive head holds if at least one of its atoms is true.
Answer sets of a disjunctive logic program satisfy a minimality criterion
that we do not detail here
(see~\cite{eitpol06a,gekasc11b} for an implementation methodology in disjunctive ASP).
We only mention that the simple disjunctive program \code{\pred{a};\pred{b}.} has two answer sets,
one containing~\pred{a} and another one containing~\pred{b},
while both atoms do not jointly belong to an answer set.
After adding the rules of Example~\ref{ex:as:one}, a single answer set containing both~\pred{a} and~\pred{b} is obtained.
This illustrates that disjunction in ASP is neither strictly exclusive or inclusive but subject to minimization.

In general, the use of disjunction may increase
computational complexity~\cite{eitgot95a}.
We thus suggest to use ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
instead of disjunction, unless the latter is required for complexity reasons.

\subsubsection{Double Negation and Head Literals}\label{subsec:gringo:double}
\index{Logic Programs!Literals!Double Default Negation}
\index{Logic Programs!Literals!Head}

\com{JR: I got lost :( 
             What about something like what is written below?
             ``They are satisfied whenever their positive counterparts are,
             but they do not have to be finitely derivable. And then move to the example.''
         RK: I agree that this was puzzling and tried to fix some problems.
             Actually, I think it is wrong to say that double negated literals do not need a proof.
             Because in fact they do.
             We just can do classical proofs *with* them instead of intuitionistic ones.
           }

The input language of \gringo\ also supports double default negated literals,
written $\code{not}~\code{not}~A$.
They are satisfied whenever their positive counterparts are.
But unlike (purely) positive literals,
they do not span positive cycles subject to minimization.
Consider the logic program:
\begin{lstlisting}[numbers=none]
a :- not not b.
b :- not not a.
\end{lstlisting}
%
This program has the same stable model as the one in Example~\ref{ex:as:one}
as well as the additional stable model containing both \pred{a} and \pred{b}.
Because in contrast to Example~\ref{ex:as:one},
the above program induces no positive cycle between~\pred{a} and~\pred{b} subject to minimization.

Also, there are literals in the head of rules.
These offer just another way to write integrity constraints,
putting the emphasis on the head literal.
In fact, the rule
\(\code{not}~A_0\)~\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n\)\code{.}
is equivalent to
\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n,\code{not}~\code{not}~A_0\)\code{.}
and with double negation in the head, rule
\(\code{not}~\code{not}~A_0\)~\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n\)\code{.}
is equivalent to
\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n,\code{not}~A_0\)\code{.}

\begin{example}\label{ex:as:flynn}
Consider the logic program:

\marginlabel{To compute both answer sets, invoke:\\
  \code{\mbox{~}clingo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
        \mbox{~}\attach{examples/flynn.lp}{flynn.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo~\attach{examples/bird.lp}{bird.lp} \textbackslash\\
        \mbox{~}\attach{examples/flynn.lp}{flynn.lp} | clasp 0}
}
\lstinputlisting{examples/flynn.lp}
The possibility that a bird flies is expressed with a double negation here in the first line.
Solutions with flying penguins are filtered out in the second line.
Like in Example~\ref{ex:flies} there are two answer sets
but without an explicit atom to indicate that a bird does not fly.
Hence, the answer set where Tweety does not fly contains no atoms over predicate \pred{flies}/$1$.
\end{example}

\begin{note}
  Note that negative head literals are also supported in disjunctions.
  For more information see \cite{litatu99a}.
\end{note}

\subsubsection{Boolean Constants}
\index{Boolean Constants}
\index{Logic Programs!Atoms!Boolean Constants}
%
Sometimes it is useful to have literals possessing a constant truth value.
Literals over the two \emph{Boolean constants} \code{\#true} and \code{\#false},
which are always true or false, respectively,
have a constant truth value.

\begin{example}
Consider the following program:
\marginlabel{%
  The unique answer set of the program,
  can be inspected by invoking:\\
  \code{\mbox{~}clingo \attach{examples/bool.lp}{bool.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/bool.lp}{bool.lp} \textbackslash \\ \mbox{~}| clasp 0}\\
  Note that this program simply produces an empty grounding:
  \code{\mbox{~}gringo --text \\ \mbox{~}\attach{examples/bool.lp}{bool.lp}}\\
  or alternatively:\\
  \code{\mbox{~}clingo --text \\ \mbox{~}\attach{examples/bool.lp}{bool.lp}}
  }
%
\lstinputlisting{examples/bool.lp}
The first rule uses \code{\#true} in the head.
Because this rule is a fact, it is trivially satisfied.
Similarly, the rules in lines~2 and~3 have satisfied heads.
The bodies of the last three integrity constraints are false.
Hence, the constraints do not cause a conflict.
Note that neither of the rules above derive any atoms.
Thus, we obtain the empty answer set for the program.
\end{example}
See Example~\ref{ex:sort} below for an application of interest.
\subsubsection{Built-in Arithmetic Functions}\label{subsec:gringo:arith}
\index{Terms!Integers}
\index{Terms!Arithmetic Functions}
\index{Arithmetic Functions}
\index{Arithmetic Functions!Integers}
\index{Arithmetic Functions!Addition, \code{+}}
\index{Arithmetic Functions!Subtraction, \code{-}}
\index{Arithmetic Functions!Unary Minus, \code{-}}
\index{Arithmetic Functions!Multiplication, \code{*}}
\index{Arithmetic Functions!Division, \code{/}}
\index{Arithmetic Functions!Modulo, \code{\textbackslash}}
\index{Arithmetic Functions!Exponentiation, \code{**}}
\index{Arithmetic Functions!Absolute Value, \mbox{\textbar$\cdot$\textbar}}
\index{Arithmetic Functions!Bitwise AND, \code{\&}}
\index{Arithmetic Functions!Bitwise OR, \code{?}}
\index{Arithmetic Functions!Bitwise XOR, \code{\^}}
\index{Arithmetic Functions!Bitwise Complement, \code{\textasciitilde}}

Besides integers (constant arithmetic functions),
written as sequences of the digits \code{0}\dots\code{9}
possibly preceded by `\code{-}',
\gringo\ and \clingo\ support a variety of arithmetic functions that
are evaluated during grounding.
The following symbols are used for these functions:
\code{+} (addition),
\code{-} (subtraction, unary minus),
\code{*} (multiplication),
\code{/} (integer division),
\code{\textbackslash} (modulo),
\code{**} (exponentiation),
\code{|$\cdot$|} (absolute value),
\code{\&} (bitwise AND),
\code{?} (bitwise OR),
\code{\^} (bitwise exclusive OR), and
\code{\textasciitilde} (bitwise complement).

\begin{example}\label{ex:arith:fun}
The usage of arithmetic functions is illustrated by the program:%
\marginlabel{%
  The unique answer set of the program,
  obtained after evaluating all arithmetic functions,
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/arithf.lp}{arithf.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/arithf.lp}{arithf.lp}}}
%
\lstinputlisting{examples/arithf.lp}
%
Note that the variables~\var{L} and~\var{R} are instantiated to~\const{7} and~\const{2},
respectively, before arithmetic evaluations.
Consecutive and non-separative (e.g., before `\code{(}')
spaces can optionally be dropped.
The four bitwise functions apply to signed integers,
using two's complement arithmetic. % of a negative integer.
\end{example}

\begin{note}
An occurrence of a variable in the scope of an arithmetic function
only counts as positive in the sense of safety for simple arithmetic terms (cf.\ Page~\pageref{pg:safe}).
Such simple arithmetic terms are terms with exactly one variable occurrence
composed of the arithmetic functions \code{+}, \code{-} and \code{*}, and integers.
Moreover,
if multiplication is used, then the constant part must not evaluate to $0$ for the variable occurrence to be considered positive.
E.g., the rule~\code{\pred{q}(\var{X})\,:-\:\pred{p}(\const{2}*(\var{X}+\const{1})).}
is considered safe, but
the rule~\code{\pred{q}(\var{X})\,:-\:\pred{p}(\var{X}+\const{X}).} is not.
\index{Logic Programs!Safety}%
\end{note}

\subsubsection{Built-in Comparison Predicates}\label{subsec:gringo:comp}
\index{Comparison Literals}
\index{Comparison Predicates}
\index{Comparison Predicates!Inequality, \code{"!=}}
\index{Comparison Predicates!Less, \code{<}}
\index{Comparison Predicates!Less or Equal, \code{<=}}
\index{Comparison Predicates!Greater, \code{>}}
\index{Comparison Predicates!Greater or Equal, \code{>=}}
\index{Logic Programs!Atoms!Comparison Predicates}

Grounder \gringo\ and the grounding component of \clingo\
feature a total order among variable-free terms.
The built-in predicates to compare terms are
\code{!=} (not equal),
\code{<} (less than),
\code{<=} (less than or equal),
\code{>} (greater than), and
\code{>=} (greater than or equal).
\emph{Comparison literals} over the above \emph{comparison predicates} are used like predicate literals (cf.\ Section~\pageref{subsec:gringo:normal})
but are evaluated during grounding.

\begin{example}\label{ex:arith:pred}
The application of comparison literals to integers
is illustrated by the following program:%
\marginlabel{%
  The simplified ground program obtained by evaluating built-ins
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash}\\
  \code{\mbox{~}\attach{examples/arithc.lp}{arithc.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash}\\
  \code{\mbox{~}\attach{examples/arithc.lp}{arithc.lp}}}
%
\lstinputlisting{examples/arithc.lp}
%
The last two lines hint at the fact that arithmetic functions are evaluated
before comparison literals, so that the latter actually compare the
results of arithmetic evaluations.
\end{example}

\begin{example}\label{ex:symb:pred}
Comparison literals can also be applied to constants and functions,
as illustrated by the following program:%
\marginlabel{%
  As above, by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/symbc.lp}{symbc.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/symbc.lp}{symbc.lp}}\\
  one can inspect the simplified ground program
  obtained by evaluating built-ins.}
%
\lstinputlisting{examples/symbc.lp}
%
Integers are compared in the usual way, constants are ordered lexicographically,
and functions both structurally and lexicographically.
% Function symbols are compared first using their arity.
% If the arity differs, then the name of the function symbol is compared lexicographically.
% If again the name differs, then arguments are compared component wise.
Furthermore, all integers are smaller than constants,
which in turn are smaller than functions.
%\comment{add \#sup and \#inf?}
\end{example}

\begin{note}
An occurrence of a variable in the scope of a built-in comparison literal
does not count as a positive occurrence in the sense of safety (cf.\ Page~\pageref{pg:safe}),
i.e.,
comparison literals are not considered to be positive.
Note that comparison literals can be preceded by \code{not} or \code{not}~\code{not}.
In the first case, this is equivalent to using the complementary comparison literal
(e.g., \code{<} and \code{>=} complement each other).
In the second case, the prefix has no effect on the meaning of the literal.
\index{Logic Programs!Safety}%
\end{note}

\subsubsection{Assignments}\label{subsec:gringo:assign}
\index{Terms!Variables!Assignments}
\index{Assignments}
\index{Assignments!Variable Assignment, \code{=}}
\index{Logic Programs!Atoms!Assignments}

Sometimes, it is desirable to define the value of a variable relative to a term,
and then reuse the variable as a shorthand.
The built-in predicate~`\code{=}' unifies
(while solving simple arithmetic terms; see Section~\ref{subsec:gringo:arith})
variables on one side with terms on the other side,
whenever the resulting assignment atom occurs
in the bodies of rules or on the right-hand sides of conditions
(detailed in Section~\ref{subsec:gringo:condition}).

\begin{example}\label{ex:assign}
The usage of variable assignments is illustrated by the following program:%
\marginlabel{%
  The simplified ground program obtained from assignments
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/assign.lp}{assign.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/assign.lp}{assign.lp}}}
%
\lstinputlisting[lastline=2,belowskip=0pt]{examples/assign.lp}%
\lstinputlisting[firstline=3,aboveskip=0pt,numbers=none,nolol]{examples/assign.lp}
%
The body of the rule in Line~2 contains four variable assignments,
which directly or indirectly depend on~\var{X} and~\var{Y}.
The values of~\var{X} and~\var{Y} are obtained via instances of the predicate \pred{num}/$1$.
The first assignment depends on~\var{X} to provide shortcut~\var{XX}.
Similarly, the second assignment depends on~\var{Y} to provide shortcut~\var{YY}.
The third assignment provides variable \var{Y'} because it occurs in a simple arithmetic expression,
which is solved during unification.
The last assignment provides no variables and,
hence, is just a test,
checking if its left-hand side equals its right-hand side.
\end{example}

\begin{example}\label{ex:unify}
This example illustrates how to unify with function terms and tuples:
\marginlabel{%
  The simplified ground program obtained from unifications
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/unify.lp}{unify.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/unify.lp}{unify.lp}}}
%
\lstinputlisting{examples/unify.lp}
%
Here, \code{\const{f}(\const{a},\var{X},\var{X}+\const{1})} or
\code{(\const{a},\var{X},\var{X}+\const{1})}, respectively,
is unified with instances of the predicate \code{sym}/$1$.
To this end,
arguments of \code{sym}/$1$ with matching arity
are used to instantiate the variable~\var{X} occurring
as the second argument in terms on the left-hand sides of~\code{=}.
With a value for~\var{X} at hand,
we can further check whether the arithmetic evaluation of~\code{\var{X}+\const{1}},
occurring as the third argument, coincides with the
corresponding value given on the right-hand side of~\code{=}.
%
% Note the usage of \code{X+1} in the term.
% \gringo{} does not try to unify any term containing arithmetic
% but in this example \code{X} occurs also directly as second argument of the argument
% and can thus be unified with.
% The term $X+1$ is merely a test that is deferred and checked later.
% For example, the fourth line is equivalent to:
% \begin{lstlisting}[firstnumber=6]
% unifyf(X) :- f(a,X,Y) := F, sym(F), Y == X + 1.
% \end{lstlisting}%
\end{example}

\begin{note}
If a variable assignment is preceded by \code{not},
no unification happens.
Instead, the expression $\code{not}~t_1~\code{=}~t_n$ is equivalent to $t_1~\code{!=}~t_n$.
Like with comparison literals, the prefix `\code{not~not}' has no effect.
Unlike with built-in comparison literals,
an assignment is considered as
a positive (body) literal in the sense of safety (cf.\ Page~\pageref{pg:safe}),
so that variables occurring on one side can be instantiated.
However, this only works if assignments
can be made acyclicly, i.e.,
it must be possible to instantiate one side
without knowing the values of variables on
the other side.
E.g., the rule `\code{\pred{p}(\var{X})\,:-\:\var{X}\:=\:\var{Y},\:\var{Y}\:=\:\var{X}.}'
is not accepted by \gringo\ (or the grounding component of \clingo)
because values for~\var{X} rely on values for~\var{Y}, and vice versa.
\index{Logic Programs!Safety}%
%
% that assignments to some extent can bind variables.
% Of course cyclic assignments cannot bind variables.
% For example the rule  is rejected by \gringo{}.
% Either \code{X} or \code{Y} has to be provided by some positive predicate in this case.
% Additionally, unification is restricted to ground terms on the right hand side of the assignment,
% that is, all variables on the right hand side have to be bound by some other predicate.
\end{note}

\subsubsection{Intervals}\label{subsec:gringo:interval}
\index{Terms!Intervals}

In Line~1 of Example~\ref{ex:assign},
five facts of the form~`\code{\pred{num}($k$).}'
over consecutive integers~$k$ are given.
For a more compact representation,
\gringo\ and \clingo\ support integer intervals of the form $i$\code{..}$j$.
% , where~$i$ and~$j$ are integers.
Such an interval, representing each integer~$k$ such that $i\leq k\leq j$,
is expanded during grounding.
An interval is expanded differently depending on where it occurs.
In the head of a rule, an interval is expanded conjunctively.
While in the body of a rule an interval is expanded disjunctively.
So we could have simply used the fact \code{num(1..5).} to represent the five facts.

\begin{example}\label{ex:int}
Consider the following program:
\marginlabel{%
  The simplified ground program obtained from intervals
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/int.lp}{int.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/int.lp}{int.lp}}}
\lstinputlisting{examples/int.lp}
Because all intervals in the second rule occur in the rule head,
they expand conjunctively.
Furthermore, the two intervals expand into the cross product \code{(1..3)$\times$(1..3)},
resulting in the following set of facts:
\begin{lstlisting}[numbers=none]
grid(1,1).  grid(1,2).  grid(1,3).
grid(2,1).  grid(2,2).  grid(2,3).
grid(3,1).  grid(3,2).  grid(3,3).
\end{lstlisting}
Similarly, intervals can be used in a rule body.
Typically, this is done in assignments, which expand disjunctively:
\begin{lstlisting}[firstnumber=2]
grid(X,Y) :- X=1..S, Y=1..S, size(S).
\end{lstlisting}
This rule expands into the same set of facts as before.
But intervals in assignments have the advantage that additional constraints can be added.
For example, one could add the comparison literals \code{X-Y!=0} and \code{X+Y-1!=S}
to the rule body to exclude the diagonals of the grid.
\end{example}

\begin{note}
An occurrence of a variable in the specification of the bounds
of an integer interval, like~\var{S} in Line~2 of Example~\ref{ex:int},
does not count as a positive occurrence
in the sense of safety (cf.\ Page~\pageref{pg:safe}).
Hence, such a variable must also have another positive occurrence elsewhere;
here in \lstinline{size(S)}.
\index{Logic Programs!Safety}%
\end{note}

\subsubsection{Pooling}\label{subsec:gringo:pool}
\index{Terms!Pooling, \code{;}}
\index{Logic Programs!Atoms!Pooling, \code{;}}

The token `\code{;}' admits pooling alternative terms
to be used as arguments of an atom, function, or tuple. % for writing rules more compactly.
Argument lists written in the form \code{($\dots$,X;Y,$\dots$)} abbreviate multiple options:
\code{($\dots$,X),\linebreak[1]\:(Y,$\dots$)}.
Pools are expanded just like intervals, i.e.,
conjunctively in the head and disjunctively in the body of a rule.
In fact, the interval \code{1..3} is equivalent to the pool \code{(1;2;3)}.%
\footnote{%
  This example uses the fact that there are no one-elementary tuples (cf.~Section~\ref{subsec:gringo:normal}).
For example, the tuple \code{(1;2,3)} expands into \code{(1)} and \code{(2,3)}.
Hence, \code{(1)} is not a tuple here but equal to integer \code{1}.}
\begin{example}\label{ex:pool}
The following program makes use of pooling.
It is similar to Example~\ref{ex:int}
but with the difference that unlike intervals, pools have a fixed size:%
\marginlabel{%
  The simplified ground program obtained from pools
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash\newline\mbox{~}\attach{examples/pool.lp}{pool.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/pool.lp}{pool.lp}}}
\lstinputlisting[xrightmargin=-5pt]{examples/pool.lp}
%
Because all pools in this rule occur in the head,
they are expanded conjunctively.
Furthermore, the two pools expand into the cross product \code{(1..3)$\times$(1..3)},
resulting in the following set of facts:
\begin{lstlisting}[numbers=none]
grid(1,1).  grid(1,2).  grid(1,3).
grid(2,1).  grid(2,2).  grid(2,3).
grid(3,1).  grid(3,2).  grid(3,3).
\end{lstlisting}
Like intervals, pools can also be used in the body of a rule,
where they are expanded disjunctively:
\begin{lstlisting}
grid(X,Y) :- X=(1;2;3), Y=(1;2;3).
\end{lstlisting}
This rule expands into the same set of facts as before.
As in Example~\ref{ex:int}, additional constraints involving~\code{X} and~\code{Y} can be added.
\end{example}

For another example on pooling, featuring non-consecutive elements, see Section~\ref{subsec:color:instance}.

\subsubsection{Conditions and Conditional Literals}\label{subsec:gringo:condition}
\index{Aggregates!Conditions}
\index{Logic Programs!Literals!Conditions}%
%
A \emph{conditional literal} is of form $L:\boldsymbol{L}$,
where $L$ is a literal and $\boldsymbol{L}$ is a tuple 
\comment{JR: this ``tuple'' strikes me a bit, then I have the doubt about whether they should go in parentheses. RK: we could add that we do not write parenthesis}
of literals, called \textit{condition}.
As in mathematical set notation,
we use the symbol~`\code{:}' to formulate conditions.
Whenever $\boldsymbol{L}$ is empty, we get a regular literal and denote it as usual by $L$.

For example, the rule
\begin{lstlisting}[numbers=none]
a :- b:c.
\end{lstlisting}
yields \code{a} whenever either \code{c} is false (and thus no matter whether \code{b} holds or not) or both \code{b} and \code{c} are true.

\begin{note}
Logically, $L$ and $\boldsymbol{L}$ act as head and body respectively,
which gives the conditional literal $L:\boldsymbol{L}$ the flavor of a nested implication
(see~\cite{haliya14a} for details).
\end{note}

Together with variables,
conditions allow for specifying collections of expressions within a single rule or aggregate.
This is particularly useful for encoding conjunctions (or disjunctions) over
arbitrarily many ground atoms as well as for the compact representation of aggregates
(detailed in Section~\ref{subsec:gringo:aggregate}).

\begin{example}\label{ex:cond}
The following program uses in Line~5 and~6 conditions in a rule body and in a rule head, respectively:
%
\lstinputlisting{examples/cond.lp}
%
The rules in Line~5 and~6 are instantiated as follows:%
\marginlabel{%
  The reader can reproduce these ground rules by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/cond.lp}{cond.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/cond.lp}{cond.lp}}}
% %[firstnumber=5]
\begin{lstlisting}[numbers=none]
meet :- available(jane), available(john).
on(mon); on(tue); on(wed); on(thu); on(fri) :- meet.
\end{lstlisting}
%
The conjunction in the body of the first ground rule is obtained by replacing~\var{X} in
\code{\pred{available}(\var{X})} with all ground terms~$t$ such that
\code{\pred{person}($t$)} holds, namely, with $t=\const{jane}$ and $t=\const{john}$.
Furthermore, the condition in the head of the rule in Line~6 turns into
a disjunction over all ground instances of
\code{\pred{on}(\var{X})} where~\var{X} is substituted by all terms~$t$
for which \code{\pred{day}($t$)} holds.
That is, conditions in the body and in the head of a rule
are expanded to different basic language constructs.\footnote{%
Recall our suggestion from Section~\ref{subsec:gringo:disjunction}
to use ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
instead of disjunction, unless the latter is required for complexity reasons.
This also means that conditions must
not be used \emph{outside of aggregates} in rule heads
if disjunction is unintended.}
\end{example}

Further following set notation,
a condition can be composed by separating literals with a comma, viz~`\code{,}'.
Note that commas are used to separate both literals in rule bodies as well as conditions.
To resolve this ambiguity,
a condition is terminated with a semicolon `\code{;}' (rather than `\code{,}'), if further body literals follow.

\begin{example}\label{ex:sort}
The following program uses a literal with a composite condition in the middle of the rule body.
Note the semicolon `\code{;}' after the condition:
%
\lstinputlisting{examples/sort.lp}
%
The conditional literal in the second rule evaluates to false
whenever there is an element~\code{Y} between~\code{X} and~\code{Z}.
Hence, all rule instantiations where~\code{X} and~\code{Z} are not direct successors are discarded
because they have a false body.
On the other hand, whenever~\code{X} and~\code{Z} succeed each other,
the condition is false for all elements~\code{Y}.
This means that the literal with condition stands for an empty conjunction, which is true:%
\marginlabel{%
  The reader can reproduce these ground rules by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/sort.lp}{sort.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/sort.lp}{sort.lp}}}%
\begin{lstlisting}[numbers=none]
set(1). set(2). set(3). set(4).
next(1,2). next(2,3). next(3,4).
\end{lstlisting}
We obtain an answer set where the elements of \code{set}/$1$ are ordered via \code{next}/$2$.
\end{example}

\begin{note}
There are three important issues about the usage of conditions:
\begin{enumerate}
%
\item
Any variable occurring within a condition
does not count as a positive occurrence outside the condition
in the sense of safety (cf.\ Page~\pageref{pg:safe}).
Variables occurring in atoms not subject to any condition are \emph{global}.
Each variable within an atom in front of a condition
must be global or have a positive occurrence on the right-hand side of
the condition.
%
\item
During grounding,
the instantiation of global variables take precedence over non-global ones,
that is, the former are instantiated before the latter.
As a consequence, variables that occur globally are substituted by terms
before a condition is further evaluated.
Hence, the names of variables in conditions must be chosen with care,
making sure that they do not \emph{accidentally} match the names of global variables.
%
\item
We suggest using \emph{domain predicates}~\cite{lparseManual}
or built-ins (both used in lines~2 and~3  of Example~\ref{ex:sort})
in conditions.
\index{Aggregates!Conditions!Domain Predicates}%
\index{Logic Programs!Literals!Domain Predicates}%
\label{pg:domain}%
Literals over such predicates are completely evaluated during grounding.
In a logic program, domain predicates can be recognized by observing
that they are neither subject to negative recursion (through \code{not})
nor to disjunction or ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
in the head of any rule.
The domain predicates defined in Example~\ref{ex:sort} are:
\pred{set}/$1$ and \pred{next}/$1$.
Literals with such conditions expand to arbitrary length disjunctions or conjunctions in the head or body of a rule, respectively.
Otherwise, they give rise to nested implications.
For further details see~\cite{haliya14a}.
\end{enumerate}
\end{note}

\subsubsection{Aggregates}\label{subsec:gringo:aggregate}
\index{Logic Programs!Atoms!Aggregates}
\index{Aggregates}
\index{Aggregates!Weights}

Aggregates are one of the most useful modeling constructs since they allow for forming values from groups of selected items.
\comment{JR: Style: ``they allow to form values''? RK: ``allow to'' does not exist in English}
Together with comparisons
they allow for expressing conditions over these items.
For instance, we can express that the sum of a semester's course credits must be at least 20,
or that the sum of the prizes of my shopping items should not exceed 30 euros.

More formally,
an aggregate is a function on a set of tuples that are normally subject to conditions.
By comparing an aggregated value with given values, we can extract a truth value from an aggregate's evaluation,
thus,
\comment{JR: Style: I would get rid of this comma. RK: The comma is optional. But we have used commas after adverbs modifying a sentence throughout the whole document.}
obtaining an aggregate atom.
Aggregate atoms come in two variants depending whether they occur in a rule head or body.

\paragraph{Body Aggregates}
The form of an \emph{aggregate atom} occurring in a rule body is as follows:
\index{Aggregates!Body}
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1\prec_1\alpha$?{?$\boldsymbol{t}_1$?:?$\boldsymbol{L}_1$?;?\,\dots\,?;?$\boldsymbol{t}_n$?:?$\boldsymbol{L}_n$?}?$\prec_2 s_2$?
\end{lstlisting}
%
Here, all $\boldsymbol{t}_i$ and $\boldsymbol{L}_i$, forming \emph{aggregate elements}, are non-empty tuples of terms and literals, respectively
(as introduced in Section~\ref{subsec:gringo:normal}).
$\alpha$ is the name of some function that is to be applied to the term tuples $\boldsymbol{t}_i$
that remain after evaluating the conditions expressed by $\boldsymbol{L}_i$.
%
Finally,
the result of applying $\alpha$ is compared by means of the comparison predicates $\prec_1$ and $\prec_2$
to the terms $s_1$ and~$s_2$ (usually representing arithmetic functions), respectively.
\comment{JR: the meaning of ``usually representing arithmetic functions'' is not clear to me. RK: Agree this part can simply be removed.}
Note that one of the \emph{guards} `$s_1\prec_1$' or `$\prec_2 s_2$'%
(or even both) can be omitted;
left out comparison predicates $\prec_1$ or $\prec_2$ default to `\code{<=}' (thus interpreting~$s_1$ or~$s_2$ as lower and upper bounds, respectively).

Currently, \gringo\ (and \clingo) support the aggregates
\code{\#count}
\index{Aggregates!Count, \code{\#count}}%
(the number of elements; used for expressing cardinality constraints),
\code{\#sum}
\index{Aggregates!Sum, \code{\#sum}}%
(the sum of weights; used for expressing weight constraints),
\code{\#sum+}
\index{Aggregates!Sum plus, \code{\#sum+}}%
(the sum of positive weights),
\code{\#min}
\index{Aggregates!Minimum, \code{\#min}}%
(the minimum weight), and
\code{\#max}
\index{Aggregates!Maximum, \code{\#max}}%
(the maximum weight).
The weight refers to the first element of a term tuple.
\comment{JR: Maybe the fact that the first element is the weight could be stressed more,
             but I am not sure about how to do it.
         RK: I think this is okay.
             Aggregates are complex and thus the section is not that easy to read.
             That's why we have a lot of examples including some with \#sum aggregates with weights.
           }%JR
Aggregate atoms, as described above, are obtained by writing
either \code{\#count}, \code{\#sum}, \code{\#sum+}, \code{\#min}, or \code{\#max} for $\alpha$.
%
Note that unlike the other aggregates, the \code{\#count} aggregate does not require a weight.

For example,
instances of the natural language examples for aggregates given at the beginning of this section
can be expressed as follows.

\begin{lstlisting}[numbers=none]
20 <= #sum { 4:course(db);      6:course(ai);
             8:course(project); 3:course(xml) }

#sum { 3:bananas; 25:cigars; 10:broomstick } <= 30
\end{lstlisting}
Both aggregate atoms can be used like any other atom, possibly preceded by negation, in the body of a rule.
Within both aggregate atoms,
symbolic atoms like \lstinline{course(ai)} or \lstinline{broomstick} are associated with costs.
Assuming that \lstinline{course(db)}, \lstinline{course(ai)} as well as \lstinline{bananas} and \lstinline{broomstick} are true,
the aggregates inner sets evaluate to \lstinline[mathescape]{$\{$4;6$\}$} and \lstinline[mathescape]{$\{$3;10$\}$}, respectively.
After applying the \lstinline{#sum} aggregate function to both sets, we get \lstinline{20 <= 10} and \lstinline{13 <= 30};
hence, in this case, the second aggregate atom holds while the first does not.

As indicated by the curly braces, the elements within aggregates are treated as members of a set.
Hence, duplicates are not accounted for twice.
%
For instance, the following aggregate atoms express the same:
\begin{lstlisting}[numbers=none,escapechar=@]
#count {42:a;       t:not b         } = 2@\textnormal{ and}@
#count {42:a; 42:a; t:not b; t:not b} = 2@\textnormal{.}@
\end{lstlisting}
That is, if \lstinline{a} holds but not \lstinline{b}, both inner sets reduce to \lstinline[mathescape]{$\{$42;t$\}$};
and so both aggregate atoms evaluate to true.
%
However, both are different from the aggregates
\begin{lstlisting}[numbers=none,escapechar=@]
#count {42:a;       t:not b; s:not b} = 2@\textnormal{ and}@
#count {42:a; 42:a; t:not b; s:not b} = 2
\end{lstlisting}
which hold if both \lstinline{a} and \lstinline{b} are false,
yielding \lstinline[mathescape]{#count$\{$t;s$\}$ = 2}.

Likewise, the literals of other aggregates are understood as sets.
\comment{JR: This is a bit confusing to me. Literals of aggregates are understood as sets, 
             but here I think the point is more that term tuples whose conditions are satisfied are understood as sets.
         RK: Agree definitely not literals!}%JR
%
Consider the next two summation aggregates:
\begin{lstlisting}[numbers=none,escapechar=@]
#sum { 3    :cost(1,2,3); 3    :cost(2,3,3) } = 3@\textnormal{ and}@
#sum { 3,1,2:cost(1,2,3); 3,2,3:cost(2,3,3) } = 6@\textnormal{.}@
\end{lstlisting}
As done in Section~\ref{subsec:tsp:instance},
an atom like \lstinline{cost(1,2,3)} can be used to represent an arc from node \lstinline{1} to \lstinline{2} with cost \lstinline{3}.
If both \lstinline{cost(1,2,3)} and \lstinline{cost(2,3,3)} hold,
the first sum evaluates to \lstinline{3} while the second yields \lstinline{6}.
Note that all term tuples, the singular tuple \lstinline{3} as well as the ternary tuples \lstinline{3,1,2} and \lstinline{3,2,3}
share the same weight, viz.~\lstinline{3}.
However,
the set property makes the first aggregate count edges with the same cost only once,
while the second one accounts for each edge no matter whether they have the same cost or not.
To see this, observe that after evaluating the conditions in each aggregate, the first one reduces to
\lstinline[mathescape]{#sum $\{$ 3 $\}$}, while the second results in \lstinline[mathescape]{#sum $\{$ 3,1,2; 3,2,3 $\}$}.
In other words, associating each cost with its respective arc enforces a multi-set property;
in this way, the same cost can be accounted for several times.

\paragraph{Head Aggregates}
Whenever a rule head is a (single) aggregate atom, the derivable head literals must be distinguished.
This is done by appending such atoms (or in general literals) separated by an additional `:' to the tuples of the aggregate elements:
\index{Aggregates!Head}
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1\prec_1\alpha$?{?$\boldsymbol{t}_1$?:?$L_1$?:?$\boldsymbol{L_1}$?;?\,\dots\,?;?$\boldsymbol{t}_n$?:?$L_n$?:?$\boldsymbol{L_n}$?}?$\prec_2 s_2$?
\end{lstlisting}
%
Here, all $L_i$ are symbolic literals as introduced in Section~\ref{subsec:gringo:normal}, while all other entities are as described above.
The second colon in
\lstinline[mathescape]{$\boldsymbol{t}_i$:$L_i$:$\boldsymbol{L_i}$}
is dropped whenever $\boldsymbol{L_i}$ is empty,
yielding
\lstinline[mathescape]{$\boldsymbol{t}_i$:$L_i$}.
%
Unlike with body aggregates, only singular head aggregates are supported.
\comment{JR: I would explain a bit what is a ``singular head aggregate''. 
             Above the word ``singular'' is used to refer to a term tuple, %JR
             and I think that's all said so far about it.
         RK: I would simply remove the sentence.
             The comparison with body aggregates is inadequate anyway.}%JR
\begin{note}
Aggregate atoms in the head can be understood as a combination of unrestricted choices with body aggregates enforcing the constraint expressed by the
original head aggregate.
In fact, when producing \smodels\ format, all aggregate atoms occurring in rule heads are transformed away.
For details consult~\cite{siniso02a,gekakasc12a}.
\end{note}

\paragraph{Shortcuts}
There are some shorthands that can be used in the syntactic representation of aggregates.
%
The expression
%
\begin{lstlisting}[numbers=none,mathescape]
$s_1 \prec_1 ${$L_1$:$\boldsymbol{L_1}$;$\,\dots\,$;$L_n$:$\boldsymbol{L_n}$}$ \prec_2 s_2$
\end{lstlisting}
%
where all entities are defined as above
is a shortcut for
%
\begin{lstlisting}[numbers=none,mathescape]
$s_1 \prec_1$ #count { $\boldsymbol{t}_1$:$L_1$:$\boldsymbol{L_1}$;$\,\dots\,$;$\boldsymbol{t}_n$:$L_n$:$\boldsymbol{L_n} $} $\prec_2 s_2$
\end{lstlisting}
%
if it appears in the head of a rule, and
it is a shortcut for
%
\begin{lstlisting}[numbers=none,mathescape]
$s_1 \prec_1$ #count {$\boldsymbol{t}_1$:$L_1$,$\boldsymbol{L_1}$;$\,\dots\,$;$\boldsymbol{t}_n$:$L_n$,$\boldsymbol{L_n}$} $\prec_2 s_2$
\end{lstlisting}
%
if it appears in the body of a rule.
In both cases, all $\boldsymbol{t}_i$ are pairwisely distinct term tuples generated by \gringo\
whenever the distinguished head literals $L_i$ are different.
%
Just like with aggregates, the guards~`$s_1\prec_1$' and~`$\prec_2 s_2$' are optional, and the symbols `$\prec_1$' and `$\prec_2$' default to `\code{<=}' if omitted.

For example, the rule
\begin{lstlisting}[numbers=none]
{ a ; b }.
\end{lstlisting}
is expanded by \gringo\ to
\begin{lstlisting}[numbers=none]
#count{ 0,a : a; 0,b : b }.
\end{lstlisting}
Here, \gringo\ generates two distinct term tuples \lstinline{0,a} and \lstinline{0,b}.
With \clingo, we obtain four answer sets representing all sets over \code{a} and \code{b}.

Same head literals yield identical terms, as we see next.
The rule
\begin{lstlisting}[numbers=none]
{ a ; a }.
\end{lstlisting}
is expanded by \gringo\ to
\begin{lstlisting}[numbers=none]
#count{ 0,a : a; 0,a : a }.
\end{lstlisting}

In fact, within the term tuple produced by \gringo,
the first term indicates the number of preceding default negations,
and the second reproduces the atom as a term in order to make the whole term tuple unique.

To see this, observe that the rule
\begin{lstlisting}[numbers=none]
:- {a; not b; not not c} > 0.
\end{lstlisting}
is expanded by \gringo\ to
\begin{lstlisting}[numbers=none]
:- #count{ 0,a : a;
           1,b : not b;
           2,c : not not c } > 0.
\end{lstlisting}

\begin{note}
By allowing the omission of \const{\#count},
so-called ``cardinality constraints''~\cite{siniso02a}
can almost be written in their traditional notation (without keyword, yet different separators),
as put forward in the legendary \lparse\ grounder~\cite{lparseManual}.
\end{note}

\paragraph{Assignment Aggregates}
Having discussed aggregate atoms,
let us note that there is a second way to use aggregates:
the values obtained by evaluating them can be assigned to variables.
To this end, \gringo\ and \clingo\ allow for using aggregates
\code{\#sum}, \code{\#min}, \code{\#max}, and \code{\#count} in assignments.
\index{Aggregates!Assignments}%
\index{Assignments!Aggregates}%
For instance, the following rules assign the obtained values to a variable:
\begin{lstlisting}[numbers=none]
sum(X) :- X = #sum   { 2:a; 3:a }.
min(X) :- X = #min   { 2:a; 3:a }.
max(X) :- X = #max   { 2:a; 3:a }.
cnt(X) :- X = #count { 2:a; 3:a }.
\end{lstlisting}
Under the assumption that atom~\pred{a} holds,
the atoms \code{\pred{sum}(\const{5})}, \code{\pred{min}(\const{2})},
\code{\pred{max}(\const{3})}, and \code{\pred{cnt}(\const{2})} are
derived by the above rules.
If~\pred{a} does not hold, we derive
\code{\pred{sum}(\const{0})}, \code{\pred{min}(\const{\#sup})},
\code{\pred{max}(\const{\#inf})}, and \code{\pred{cnt}(\const{0})}.
%
Here, the special constants \const{\#sup} and \const{\#inf}
(introduced in Section~\ref{subsec:gringo:normal}),
obtained by applying \code{\#min} and \code{\#max} to the empty set of weights, respectively,
indicate the neutral elements of the aggregates.
%
These constants can also be used as weights, subject to
\code{\#min} and \code{\#max} (in order to exceed any other ground term):
\begin{lstlisting}[numbers=none]
bot :-      #min { #inf : a } -1000.
top :- 1000 #max { #sup : a }.
\end{lstlisting}
Assuming that atom~\pred{a} holds,
the atoms~\pred{bot} and~\pred{top} are derived by the above rules
because both \code{\#inf <= -1000} and \code{1000 <= \#sup} hold.

\begin{note}\label{rem:aggr-assign}
Although it seems convenient to use assignments of aggregates' values,
this feature should be used with care.
If the literals of an aggregate belong to domain predicates
(see Page~\pageref{pg:domain}) or built-ins,
\gringo\ or \clingo\ evaluates the aggregate during grounding, so obtaining
a unique value to be assigned.
\index{Aggregates!Assignments!Domain Predicates}%
\index{Assignments!Aggregates!Domain Predicates}%
Otherwise, if the literals do not belong to domain predicates,
the value of an aggregate is not known during grounding,
in which case \gringo\ or \clingo\ unwraps all possible outcomes of the
aggregate's evaluation.
The latter can lead to a space blow-up,
which should be taken into account
because this often leads to problems for larger instances.
\end{note}

% In particular, if there are multiple occurrences
% $L\code{=}w_1,\dots,L\code{=}w_k$
% of a literal~$L$, in combination with \const{\#min} and \const{\#max},
% it is not the same like having $L\code{=}w_1+\dots+w_k$.
% To see this, note that the program consisting of the facts:
% \begin{lstlisting}[numbers=none]
% 2 #max [a=2].  2 #min [a=2].
% \end{lstlisting}
% has $\{\code{a}\}$ as its unique answer set, while there is no answer set for:
% \begin{lstlisting}[numbers=none]
% 2 #max [a,a].  2 #min [a,a].
% \end{lstlisting}

% If literals ought not to be repeated,
% we can use \const{\#count} instead of \const{\#sum}.
% Syntactically, \const{\#count} requires curly instead of square
% brackets, and there must not be any weights within a \const{\#count} aggregate.
% Regarding semantics,
% % \begin{equation*}%\label{eq:aggregate:atom}
% $(
%   l\,
%   \const{\#count}
%   \,
%   \code{\char`\{}
%   \,
%   L_1\code{,}
%   \dots\code{,}
%   L_n
%   \,
%   \code{\char`\}}
%   \,
%   u
% )$
% %\end{equation*}
% reduces to
% $(
%   l\,
%   \const{sum}
%   \,
%   \code{[}
%   \,
%   L_1\code{=}\const{1}\code{,}
%   \dots\code{,}
%   L_m\code{=}\const{1}
%   \,
%   \code{]}
%   \,
%   u
% )$,
% where $\{L_1,\dots,L_m\}=\{L_i \mid 1\leq i\leq n\}$ is obtained by dropping
% repeated literals.
% Of course, the use of~$l$ and~$u$ is optional also with \const{\#count}.
% As an example, note that the next aggregate atoms express the same:
% \begin{lstlisting}[numbers=none,escapechar=@]
% 1 #sum   [a=1, not b=1]     1  @\textnormal{and}@
% 1 #count {a,a, not b,not b} 1@\textnormal{.}@
% \end{lstlisting}
% Keyword \const{\#count} can be omitted (like \const{\#sum}),
% so that the following are synonyms:
% \begin{lstlisting}[numbers=none,escapechar=@]
% 1 #count {a, not b} 1  @\textnormal{and}@
% 1        {a, not b} 1@\textnormal{.}@
% \end{lstlisting}
% The last notation is similar to the one of so-called
% ``cardinality constraints''~\cite{siniso02a,lparseManual},
% which are aggregate atoms using counting as their operation.

\paragraph{Non-ground Aggregates}

After considering the syntax and semantics of ground aggregate atoms,
we now turn our attention to non-ground aggregates.
Regarding contained variables,
only variable occurrences in the guards 
\comment{JR: Style: I would write here the symbols $s_1\prec_1$ and $\prec_2 s_2$ to remember what a guard is. RK: disagree}
give rise to global variables.
Hence, any variable in an aggregate element must be bound by
either a positive global occurrence or
a variable that occurs positively in its condition $\boldsymbol{L_i}$.
\index{Logic Programs!Safety}
Variable names in aggregate elements have to be chosen carefully to avoid clashes with global variables.
Furthermore, pools and intervals in aggregate elements give rise to multiple aggregate elements;
very similar to the disjunctive unpacking of pools and intervals in rules.
The following example, making exhaustive use of aggregates,
demonstrates a lot of different features
(note that it ignores Remark~\ref{rem:aggr-assign}).

\begin{example}\label{ex:aggr}
Consider a situation where an informatics student
wants to enroll for a number of courses at the beginning of a new term.
In the university calendar, eight courses are found eligible,
and they are represented by the following facts:
%
\lstinputlisting[xrightmargin=-20pt,lastline=8,basicstyle=\ttfamily\small]{examples/aggr.lp}
%
In an instance of \const{course}/$3$,
the first argument is a number identifying one of the eight courses,
and the third argument provides the course's contact hours per week.
The second argument stands for a subject area:
\const{1} corresponding to ``theoretical informatics'',
\const{2}               to ``practical informatics'',
\const{3}               to ``technical informatics'',
and~\const{4}               to ``applied informatics''.
For instance, atom \code{\const{course}(\const{1},\const{2},\const{5})}
expresses that course~\const{1} accounts for~\const{5} contact hours per week
that may be credited to subject area~\const{2} (``practical informatics'').
Observe that a single course is usually eligible for multiple
subject areas.

After specifying the above facts,
the student starts to provide personal constraints on the courses to enroll.
The first condition is that~\const{3} to~\const{6} courses should be enrolled:
\comment{JR: Style: this ``should be enrolled'' sounded a bit strange to me, but maybe it's me ;) RK: strictly speaking one should use have to but I consider this as nitpicking :)}
%
\lstinputlisting[nolol,firstline=11,lastline=11,firstnumber=9]{examples/aggr.lp}
%
Instantiating the above \const{\#count} aggregate
yields the following ground rule:%
\marginlabel{%
  The full ground program is obtained by invoking:\\
  \code{\mbox{~}gringo --text \attach{examples/aggr.lp}{aggr.lp}}}
%
\begin{lstlisting}[numbers=none]
3 <= #count { 0,enroll(1) : enroll(1);
              0,enroll(2) : enroll(2);
              0,enroll(3) : enroll(3);
              0,enroll(4) : enroll(4);
              0,enroll(5) : enroll(5);
              0,enroll(6) : enroll(6);
              0,enroll(7) : enroll(7);
              0,enroll(8) : enroll(8) } <= 6.
\end{lstlisting}
%
Observe that an instance of atom~\code{\const{enroll}(\var{C})} is included for each
instantiation of~\var{C} such that \code{\const{course}(\var{C},\var{S},\var{H})}
holds for some values of~\var{S} and~\var{H}.
Duplicates resulting from distinct values for~\var{S} are removed, thus,
obtaining the above set of ground atoms.

The next constraints of the student regard the subject areas of enrolled courses:
%
\lstinputlisting[nolol,firstline=13,lastline=16,firstnumber=10]{examples/aggr.lp}
%
Each of the three integrity constraints above contains a \code{\#count} aggregate.
Recall that aggregates operate on sets and thus duplicates are removed;
hence we use terms tuples to take into account courses together with their subject areas.
Thus, the integrity constraint in Line~10 is instantiated as follows:
\footnote{Because contact hours are uniquely associated to a course,
\gringo's shortcut expansion of \lstinline{:- \{ course(C,S,H) : enroll(C) \} 10.} is equivalent to the rule in Line~10 here.
Similar equivalences exist for the other \code{\#count} aggregates.}
%
\begin{lstlisting}[firstnumber=10,stepnumber=10]
:- 10 >= #count { 1,1:enroll(1); 1,2:enroll(1);
                  2,1:enroll(2); 2,2:enroll(2);
                  3,1:enroll(3); 3,3:enroll(3);
 4,1,3:enroll(4); 4,3:enroll(4); 4,4:enroll(4);
                  5,1:enroll(5); 5,4:enroll(5);
                  6,2:enroll(6); 6,3:enroll(6);
 7,2,4:enroll(7); 7,3:enroll(7); 7,4:enroll(7);
                  8,3:enroll(8); 8,4:enroll(8) }.
\end{lstlisting}
%
Note that courses~\const{4} and~\const{7} count three times because
they are eligible for three subject areas, viz., there are three
distinct instantiations for~\var{S} in
\code{\const{course}(\var{4},\var{S},\const{3})} and
\code{\const{course}(\var{7},\var{S},\const{4})}, respectively.
Comparing the above ground instance,
the meaning of the integrity constraint in Line~10 is that the
number of eligible subject areas over all enrolled courses
must be more than~\const{10}.
Similarly, the integrity constraint in Line~11 expresses the requirement
that at most one course of subject area~\const{2} (``practical informatics'')
is not enrolled,
while Line~12 stipulates that the enrolled courses
amount to less than six nominations of
subject area~\const{3} (``technical informatics'')
or~\const{4} (``applied informatics'').

The remaining constraints of the student deal with contact hours.
To express them, we first introduce an auxiliary rule and a fact:
%
\lstinputlisting[nolol,firstline=18,lastline=19,firstnumber=13]{examples/aggr.lp}
%
The rule in Line~13 projects instances of \pred{course}/$3$ to
\pred{hours}/$2$, thereby, dropping courses' subject areas.
This is used to not consider 
\comment{JR: Style: sounds strange (to me?) RK: but okay to me}
the same course multiple times within the following
integrity constraints:
\footnote{Alternatively, we could also use \lstinline{course(C,_,H).}}
%
\lstinputlisting[nolol,firstline=21,lastline=23,firstnumber=15]{examples/aggr.lp}
%
\comment{JR: Style: This change of numbers lost me, although I recovered ;) RK: good to hear. I would keep everything as is. :)}
As Line~15 shows,
we may use default negation via `\code{not}' in front of aggregate atoms,
and bounds may be specified in terms of variables.
In fact, by instantiating~\var{M} to~\const{20},
we obtain the following ground instance of the integrity constraint in Line~15:
%
\begin{lstlisting}[firstnumber=15,stepnumber=15]
:- not 18 <= #sum { 5,1 : enroll(1); 4,2 : enroll(2);
                    6,3 : enroll(3); 3,4 : enroll(4);
                    4,5 : enroll(5); 2,6 : enroll(6);
                    4,7 : enroll(7); 5,8 : enroll(8) } <= 20.
\end{lstlisting}
%
The above integrity constraint states that the \const{\#sum} of contact hours per week
must lie in-between~\const{18} and~\const{20}.
Note that the \const{\#min} and \const{\#max} aggregates in Line~16 and~17, respectively,
work on the same set of aggregate elements as in Line~15.
While the integrity constraint in Line~16 stipulates that any course to enroll
must include more than~\const{2} contact hours,
the one in Line~17 prohibits enrolling for courses of~\const{6} or more contact hours.
Of course, the last two requirements could also be formulated as follows:
%
\begin{lstlisting}[firstnumber=16]
:- enroll(C), hours(C,H), H <= 2.
:- enroll(C), hours(C,H), H >= 6.
\end{lstlisting}

Finally, the following rules illustrate the use of aggregates within assignments:
%
\lstinputlisting[nolol,firstline=25,lastline=26,firstnumber=18]{examples/aggr.lp}
%
Note that similar aggregates have already been used in Line~9 and~15, respectively.
In Line~9, the keyword \const{\#count} has been omitted for convenience.
Moreover, Line~9 distinguishes eight terms, while Line~18 discerns only five.
More importantly, the usage of aggregates in the last two lines is different from before,
as they now serve to assign an integer to a variable~\var{N}.
In this context, bounds are not permitted, and so none are provided in Line~18 and~19.
The effect of these two lines is that the student can read off the number of
courses to enroll and the amount of contact hours per week from instances of
\pred{courses}/$1$ and \pred{hours}/$1$ belonging to an answer set.%
\marginlabel{%
  To compute the unique answer set of the program, invoke:\\
  \code{\mbox{~}gringo \attach{examples/aggr.lp}{aggr.lp} | \textbackslash\\
        \mbox{~}clasp -n 0}\\
  or alternatively:\\
  \code{\mbox{~}clingo -n 0 \attach{examples/aggr.lp}{aggr.lp}}}
%
In fact, running \clasp\ shows the student that a unique
collection of~\const{5} courses to enroll satisfies all requirements:
the courses~\const{1}, \const{2}, \const{4}, \const{5}, and~\const{7},
amounting to~\const{20} contact hours per week.

As mentioned in Section~\ref{subsec:gringo:condition},
multiple literals may be connected via `\code{,}' in order to construct
composite conditions within an aggregate.
Furthermore, the usage of non-domain predicates within an aggregate
together with an assignment (like \pred{enroll}/$1$ in Line~18 and~19 above)
is not recommended in general because the space blow-up may be significant.
\end{example}

\begin{note}
Users familiar with \gringo~3 might remember that conditions in aggregates
had to be either literals over domain predicates or built-ins.
This restriction does not exist anymore in \gringo\ and \clingo~4.
\end{note}

\subsubsection{Optimization}\label{subsec:gringo:optimize}
\index{Statements!Optimize Statements}
Optimization statements extend the basic question of
whether a set of atoms is an answer set to
whether it is an optimal answer set.
To support this reasoning mode, \gringo\ and \clingo\ adopt \dlv's weak constraints~\cite{bflnrp00}.
The form of weak constraints is similar to integrity constraints (cf.~Section \ref{subsec:gringo:normal})
being associated with a term tuple:
\index{Statements!Weak Constraints}%
\[
    \code{:{\raise.17ex\hbox{$\scriptstyle\sim$}}~$L_1$,$\dots$,$L_n$.~[$w$@$p$,$t_1$,$\dots$,$t_n$]}
\]
The priority \code{@$p$} is optional.
For simplicity, we first consider the non-prioritized case omitting \code{@$p$}.
Whenever the body of a weak constraint is satisfied,
it contributes its term tuple (as with aggregates, duplicates are ignored) to a cost function.
This cost function accumulates the integer weights $w$ of all contributed tuples just like a \#sum aggregate does.
The semantics of a program with weak constraints is intuitive:
an answer set is \emph{optimal}
if the obtained cost is minimal among all answer sets of the given program.
Whenever there are different priorities attached to tuples,
we obtain a (possibly zero) cost for each priority.
To determine whether an answer set is optimal,
we do not just compare two single costs
but lexicographically compare cost tuples whose elements are ordered by priority (greater is more important).
Note that a tuple is always associated with a priority;
if it is omitted, then the priority defaults to zero.
\index{Logic Programs!Safety}
A weak constraint is safe if the variables in its term tuples are bound by the atoms in the body
and the safety requirements for the body itself are the same as for integrity constraints.

As an alternative way to express an optimization problem,
there are optimization statements,
which provide another way to write weak constraints.
A minimize constraint of form:
\comment{JR: No weights here? $w_1$@$p_1$,$\boldsymbol{t}_1$:$\boldsymbol{L}_1$ RK: using this would make things really hard to read. The $t_i$ is meant to stand for a term tuple with an optional priority.}
\[
    \code{\#minimize \{ $\boldsymbol{t}_1$:$\boldsymbol{L}_1$,$\dots$,$\boldsymbol{t}_n$:$\boldsymbol{L}_n$ \}.}
\]
represents the following $n$ weak constraints:
\[
    \code{:{\raise.17ex\hbox{$\scriptstyle\sim$}}~$\boldsymbol{L}_1$.~[$\boldsymbol{t}_1$]}
    \quad \dots \quad
    \code{:{\raise.17ex\hbox{$\scriptstyle\sim$}}~$\boldsymbol{L}_n$.~[$\boldsymbol{t}_n$]}
\]
And finally there are maximize constraints.
Again, these are defined as shortcuts.
To maximize, the integer weights of the tuples are simply inverted.
Hence, a maximize statement of form:
\[
    \code{\#maximize \{ $w_1$@$p_1$,$\boldsymbol{t}_1$:$\boldsymbol{L}_1$,$\dots$,$w_1$@$p_1$,$\boldsymbol{t}_n$:$\boldsymbol{L}_n$ \}.}
\]
represents the following $n$ weak constraints:
\[
    \code{:{\raise.17ex\hbox{$\scriptstyle\sim$}}~$\boldsymbol{L}_1$.~[-$w$@$p$,$\boldsymbol{t}_1$]}
    \quad \dots \quad
    \code{:{\raise.17ex\hbox{$\scriptstyle\sim$}}~$\boldsymbol{L}_n$.~[-$w$@$p$,$\boldsymbol{t}_n$]}
\]

\begin{example}\label{ex:opt}
To illustrate optimization, we consider a hotel booking situation
where we want to choose one among five available hotels.
The hotels are identified via numbers assigned in descending order of stars.
Of course, the more stars a hotel has, the more it costs per night.
As ancillary information, we know that hotel~\const{4} is located
on a main street, which is why we expect its rooms to be noisy.
This knowledge is specified in Line~1--5 of the following program:
%
\lstinputlisting[xrightmargin=-26pt]{examples/opt.lp}
%
Line~6--8 contribute optimization statements in inverse order of significance,
according to which we want to choose the best hotel to book.
The most significant optimization statement in Line~8 states that
avoiding noise is our main priority.
The secondary optimization criterion in Line~7 consists of
minimizing the cost per star.
Finally, the third optimization statement in Line~6 specifies that we want
to maximize the number of stars among hotels that are otherwise indistinguishable.
The optimization statements in Line~6--8 are instantiated as follows:%
\marginlabel{%
  The full ground program is obtained by invoking:\\
  \code{\mbox{~}gringo --text \attach{examples/opt.lp}{opt.lp}}}
%
\begin{lstlisting}[firstnumber=6,breakindent=0pt,escapechar=&]
:~ hotel(1). [-5@1,1]&\\&:~ hotel(2). [-4@1,2]&\\&:~ hotel(3). [-3@1,3]&\\&:~ hotel(4). [-3@1,4]&\\&:~ hotel(5). [-2@1,5]
:~ hotel(1). [34@2,1]&\\&:~ hotel(2). [35@2,2]&\\&:~ hotel(3). [30@2,3]&\\&:~ hotel(4). [25@2,4]&\\&:~ hotel(5). [30@2,5]
:~ noisy. [ 1@3 ]
\end{lstlisting}
If we now use \clasp\ or \clingo\ to compute an optimal answer set,%
\marginlabel{%
  To compute the unique optimal answer set, invoke:\\
  \code{\mbox{~}gringo \attach{examples/opt.lp}{opt.lp} | \textbackslash\\
        \mbox{~}clasp -n 0}\\
  or alternatively:\\
  \code{\mbox{~}clingo -n 0 \attach{examples/opt.lp}{opt.lp}}}
we find that hotel~\const{4} is not eligible because it implies \pred{noisy}.
Thus, hotel~\const{3} and~\const{5} remain as optimal w.r.t.\ the second most
significant optimization statement in Line~7.
This tie is broken via the least significant optimization statement in Line~6
because hotel~\const{3} has one star more than hotel~\const{5}.
We thus decide to book hotel~\const{3} offering~\const{3} stars
to cost~\const{90} per night.
\end{example}


\subsubsection{External Functions}\label{subsec:lang:extfun}
\index{Terms!External Functions}%
\index{External Functions}%
\index{Lua}%
\index{Python}%
Utilizing the scripting languages Lua or Python\footnote{\url{http://lua.org} and \url{http://python.org}},
\gringo's input language can be enriched by arbitrary functions.
We focus on functions that are evaluated during grounding here.
In Section~\ref{sec:multi},
we show how to take complete control of the grounding and solving process using the scripting API.
We do not give an introduction to Lua or Python here (there are numerous tutorials on the web),
but give some examples showing the capabilities of this integration.
In the following, we show code snippets for both scripting languages.
Note that our precompiled binaries ship with Lua support and can be used to run the Lua examples.
To enable Python support, \gringo\ and \clingo\ have to be compiled from source (cf. Section~\ref{sec:install}).
\begin{example}\label{ex:gcd}
The first example shows how to add a simple arithmetic function:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.51\textwidth}
\lstinputlisting[language=GringoLua]{examples/gcd-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.51\textwidth}
\lstinputlisting[language=GringoPython]{examples/gcd-py.lp}
\end{minipage}\\
In Line~3, we add a function that calculates the greatest common divisor of two numbers.
Integers from a logic program are directly mapped to their Lua and Python equivalents
and can be returned from the function.
The \code{gcd} function can then be used in a logic program:
\lstinputlisting{examples/gcd.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/gcd-lua.lp}{gcd-lua.lp} \attach{examples/gcd.lp}{gcd.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/gcd-lua.lp}{gcd-py.lp} \attach{examples/gcd.lp}{gcd.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{gcd}/$3$.
Note that external function calls look like function symbols but are preceded by `\code{@}'.
\index{External Functions!Calling}%
Regarding binding of variables, the same restrictions as with arithmetic in Section \ref{subsec:gringo:arith} apply.
\end{example}

\begin{example}
This example shows how to return multiple values from a function:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.53\textwidth}
\lstinputlisting[language=GringoLua]{examples/rng-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.49\textwidth}
\lstinputlisting[language=GringoPython]{examples/rng-py.lp}
\end{minipage}\\
In Line~3, we add a function that emulates an interval.
Instead of just returning one number,
this function returns a table of numbers in Lua and a list of numbers in Python, respectively.
The \code{rng} function can then be used in a logic program:
\lstinputlisting{examples/rng.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/rng-lua.lp}{rng-lua.lp} \attach{examples/rng.lp}{rng.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/rng-lua.lp}{rng-py.lp} \attach{examples/rng.lp}{rng.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{rng}/$3$.
The values in the table or list returned from a call to \code{\@rng(X,Y)} are then successively inserted.
In fact, this function behaves exactly like the interval~\code{X..Y}.
\index{External Functions!Term Insertion}

An interesting use case for returning multiple values is to pull whole
instances from external sources, like for example a database or some text file not already in fact format.
\end{example}

As we have seen in the previous example,
numbers are mapped to their Lua and Python equivalents.
The same holds for quoted strings.
To capture constants and functions,
there are the \code{Id} and \code{Fun} classes, respectively, in both Python and Lua.%
\footnote{Strictly speaking there are no classes in Lua, the Userdata data type together with a metatable is used to emulate classes.}
Both objects have a \code{name()} method to access the string representation of the constant and the name of the function, respectively.
A \code{Fun} object has an additional function \code{args()} returning the table of arguments and list of arguments in Lua and Python, respectively.
In Python, tuples are mapped to Python's tuple data structure.
And because there are no dedicated tuples in Lua, tuple terms are mapped to \code{Fun} objects
that have an empty name in Lua.
Finally, the terms \code{\#sup} and \code{\#inf} are mapped to the constants \code{Sup} and \code{Inf}.

To construct terms from within the scripting language,
the \code{Id} and \code{Fun} classes have a constructor to create objects (in Lua it is a global function).
To create an object representing a constant,
there is the \code{Id(name)} constructor,
which  simply takes the string representation of the constant as argument.
Similarly, for functions
there is the \code{Fun(name,args)} constructor,
taking a string representation of the name of the function
together with a sequence or table of terms representing the arguments of the function
as arguments.
Furthermore, there is the global function \code{Tuple(args)} in Lua,
which is a shortcut for \code{Fun("",args)},
to create an object representing a tuple.
The remaining terms,
which have equivalents in the scripting languages,
use the standard constructors or literals available in Lua and Python.

\begin{example}
This example shows how to inspect and create terms:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.57\textwidth}
\lstinputlisting[language=GringoLua]{examples/term-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\lstinputlisting[language=GringoPython]{examples/term-py.lp}
\end{minipage}\\
In Line~5, we add function~\code{g},
which takes a constant and a tuple as arguments,
and returns a function with the name of the constant and the tuple as arguments.
Note the different handling of tuples in Lua and Python.
Whereas in Lua tuples are represented using \code{Fun} objects,
in Python the tuple can directly be passed to the \code{Fun} constructor.
\lstinputlisting{examples/term.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/term-lua.lp}{term-lua.lp} \attach{examples/term.lp}{term.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/term-lua.lp}{term-py.lp} \attach{examples/term.lp}{term.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{g}/$3$.
Using this scheme,
new terms can be created during grounding
that cannot be constructed by means of plain ASP.
Another interesting application might be string concatenation.
\end{example}

The last function of interest here is the \code{cmp(a,b)} function,
which compares two terms \code{a} and \code{b}
as \gringo's built-in comparison predicates (cf. Section \ref{subsec:gringo:comp}) would do.
It returns a negative integer if \code{a < b}, zero if \code{a = b}, and a positive integer if \code{a > b}.
A complete reference for the Python scripting API is available at: \url{http://potassco.sourceforge.net/gringo.html}
\begin{example}
This example shows how to implement the \code{max} function:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.57\textwidth}
\lstinputlisting[language=GringoLua]{examples/cmp-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\lstinputlisting[language=GringoPython]{examples/cmp-py.lp}
\end{minipage}\\
In Line~5, we add function~\code{max},
which takes two terms as arguments
and returns the maximum of both.
We are using the \code{cmp} here to compare terms.
We cannot use the \code{>} relation here
because it cannot compare objects of different types,
e.g., integers and strings.
\lstinputlisting{examples/cmp.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/cmp-lua.lp}{cmp-lua.lp} \attach{examples/cmp.lp}{cmp.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/cmp-lua.lp}{cmp-py.lp} \attach{examples/cmp.lp}{cmp.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{max}/$3$.
Note that the maximum of constant \code{a} and integer \code{3} is \code{a}.
\end{example}

\begin{note}~
\begin{enumerate}
\item The grounder assumes that all external functions are deterministic.
That is, if a function is called during grounding multiple times with the same arguments,
then it should always return the same values.
Adding non-deterministic functions can lead to undesired results.
\item If an error occurs during the evaluation of an external function,
then a warning is printed and the current substitution is thrown away.
For example, when calling the~\code{gcd} function in Example~\ref{ex:gcd} with non-integer arguments.
\end{enumerate}
\end{note}

\subsubsection{Meta-Statements}\label{subsec:gringo:meta}
\index{Meta-Statements}

After considering the language of logic programs,
we now introduce features going beyond the contents of a program.

\paragraph{Comments}
\index{Meta-Statements!Comments}
To annotate the source code of a logic program,
a logic program file may include comments.
A comment until the end of a line is initiated by symbol `\code{\%}',
and a comment within one or over multiple lines is enclosed
in `\code{\%*}' and `\code{*\%}'.
As an abstract example, consider:
%
\begin{lstlisting}[numbers=none,escapechar=@]
tos(jim).    %* enclosed comment *%  tos(spock).
tos(bones).  % comment till end of line
tos(scotty). tos(chekov).
%*
comment over multiple lines
*%
tos(uhura).  tos(sulu).
\end{lstlisting}

\paragraph{Show Statements}
\index{Meta-Statements!Show Statements, \code{\#show}}%
Sometimes, one may be interested only in a subset of the atoms belonging
to an answer set.
In order to suppress the atoms of ``irrelevant'' predicates from the output
or even to show arbitrary terms,
the \code{\#show} directive can be used.
There are three different statements:
%
\par
\medskip
\begin{tabular}{rl}
\textbf{Show atoms:}   & $\code{\#show}~p\code{/}n\code{.}$
\\
\textbf{Show terms:}   & $\code{\#show}~t_0~\code{:}~L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Show nothing:} & \code{\#show.}
\end{tabular}
\par
\medskip
\noindent
%
The first~\code{\#show} statement is the most commonly used form.
Whenever there is at least one statement of this form, all atoms are hidden,
except those over predicates~$p/n$ given by the respective~\code{\#show} statements.
The second form can be used to show arbitrary terms.
The term~$t_0$ is part of the output if the literals in the condition after the~\code{:} hold.
Unlike the previous form,
this statement does not automatically hide all atoms.
To hide all atoms in this case and only show selected terms,
the last statement (mnemonic: show nothing) can be added to suppress all atoms in the output.

\begin{example}
This example depicts the standard use case to selectively show atoms:
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/showa.lp}{showa.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/showa.lp}{showa.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
\lstinputlisting{examples/showa.lp}
Only atoms over $a/0$ and $q/1$ appear in the output here.
\end{example}

\begin{example}
This example depicts how to show terms:
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/showt.lp}{showt.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/showt.lp}{showt.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
%
\lstinputlisting{examples/showt.lp}
%
When running this example,
the same output as in the previous example is produced.
This feature is especially handy when applying meta-programming techniques (cf.~Section~\ref{sec:meta})
where the signatures of the reified atoms are unknown and the \code{holds($\cdot$)} atoms would just clutter the output.
\end{example}

\begin{note}
The second form of \code{\#show} statements to show terms may contain variables.
Regarding safety, it behaves similarly to a rule,
where the term $t_0$ takes the role of the head
and the condition after the colon the role of the body.
\index{Logic Programs!Safety}
\end{note}

\paragraph{Const Statements}
\index{Meta-Statements!Const Statements, \code{\#const}}%
Constants appearing in a logic program may actually be placeholders for
concrete values provided by a user.
An example of this is given in Section~\ref{subsec:ex:color}.
Via the \code{\#const} directive,
one may define a default value to be inserted for a constant.
Such a default value can still be overridden via command line option
\code{--const} (cf.\ Section~\ref{subsec:opt:gringo}).
Syntactically, \code{\#const} must be followed by an assignment having
a (symbolic) constant on the left-hand side and a term without variables, pools, intervals on the right-hand side.

\begin{example}
This example is about using the grounder as a simple calculator:
%
\lstinputlisting{examples/const.lp}
%
Try running this example using the following calls:
\begin{lstlisting}[numbers=none,escapeinside={\$}{\$}]
 gringo --text $\attach{examples/const.lp}{const.lp}$
 gringo --text $\attach{examples/const.lp}{const.lp}$ -c x=6   -c h=6
 gringo --text $\attach{examples/const.lp}{const.lp}$ -c x=6+6 -c y=6
 gringo --text $\attach{examples/const.lp}{const.lp}$ -c x="6+6*6"
\end{lstlisting}
Note that to prevent the shell from expanding the \code{*} in the last call
or from interpreting parentheses in functions,
quotes have to be added.
\end{example}

\paragraph{External Statements}
\index{Meta-Statements!External Statements, \code{\#external}}%
External statements are used to mark atoms as external.
This means that those atoms are not subject to certain simplifications.
Namely,
atoms marked external are not removed from the bodies of rules, conditions, etc.
even if they do not appear in the head of any rule.
Although this does not affect the semantics of a logic program,
we will see an effect in the text output of the example below.
Their main use case is to implement extensions to plain ASP solving,
like multi-shot solving detailed in Section~\ref{sec:multi}.
An external statement has the following form:
%
\par
\medskip
\begin{tabular}{l}
$\code{\#external}~A_0~\code{:}~L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\end{tabular}
\par
\medskip
\noindent
%
Here~$A_0$ is an atom over some predicate and
the part following the~\code{:} is a condition.
The condition is instantiated to obtain a set of external atoms.
Note that the condition is discarded after grounding,
hence, it is a good idea to only use domain predicates or built-ins after the colon.%
\footnote{Non-domain predicates are supported too
because in some situations it might be very inconvenient to specify domain predicates.}

\begin{example}
Consider the following example:
%
\marginlabel{%
To inspect the instantiation of externals, invoke:\\
\code{%
\mbox{~}gringo --text \attach{examples/ext.lp}{ext.lp}}\\
or:\\
\code{%
\mbox{~}clingo --text \attach{examples/ext.lp}{ext.lp}}
}
%
\lstinputlisting{examples/ext.lp}
%
The external statement in Line~2 gives rise to three external atoms,
which appear accordingly in the text output.
With these three atoms,
the rule in Line~4 yields three ground instantiations,
where atoms~\code{q(2)} and~\code{q(3)} appear in the body.
Because we have the fact \code{q(1)} in Line~3,
the atom \code{q(1)} is still subject to simplification
and removed from the body of the respective instantiation of the rule in Line~4.
The idea here is that no matter how \code{q(1)} is supplied externally,
there can never be an answer set that does not contain \code{q(1)}.
\end{example}

\begin{note}
External statements that contain variables
have very similar requirements regarding safety as rules.
The atom $A_0$ takes the role of the head
and the condition after the colon the role of the body.
\index{Logic Programs!Safety}
\end{note}
\paragraph{Program Parts}
\index{Meta-Statements!Program Parts, \code{\#program}}
A logic program can be organized in multiple program parts.
To begin a new program part, we write the following statement:
%
\par
\medskip
\begin{tabular}{l}
\code{\#program~$p$($s_1$,\dots,$s_n$).}
\end{tabular}
\par
\medskip
\noindent
%
where $p$ is the program part name and the parameters $s_i$ are symbolic constants.
If $n$ is zero, then the parentheses can be omitted.
All rules, external statements, and show statements for terms following such a directive up to the next program part directive or the end of the file belong to the program part $p/n$.
All rules not subject to a program part directive belong to the $\code{base}/0$ part.

The default behavior of \gringo\ is to ground (and solve in the case of \clingo) the base part.
Using the scripting API,
we can ground other parts than $\code{base}/0$ too.
Occurrences of symbolic constants
that are parameters of a part
are replaced with ground terms when instantiating the program part.

\begin{example}
The following example shows how to instantiate program parts:
\lstinputlisting[language=GringoLua]{examples/part.lp}
The above program is organized in two parts $\code{base}/0$ and $\code{a}/2$.
Note that the fact in the first line is implicitly in the $\code{base}/0$ part.
Solving the program as is results in answer set $\{\code{a}, \code{c}\}$,
because the $\code{base}/0$ part is instantiated by default.
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.51\textwidth}
\lstinputlisting[language=GringoLua]{examples/part-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.51\textwidth}
\lstinputlisting[language=GringoPython]{examples/part-py.lp}
\end{minipage}\\
%
\marginlabel{%
To inspect the instantiation of program parts, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\\
\mbox{~}\attach{examples/part.lp}{part.lp} \attach{examples/part-lua.lp}{part-lua.lp}}\\
or:\\
\code{%
\mbox{~}clingo --text \textbackslash\\
\mbox{~}\attach{examples/part.lp}{part.lp} \attach{examples/part-py.lp}{part-py.lp}}
}%
%
The above script grounds (Line 9) the $\code{base}/0$ part (Line 7) as well as the $\code{a}/2$ part with parameters \code{1} and \code{3} (Line 8).
Note the call to solve in Line 10.
This is essential to solve the program with \clingo,
and even in \gringo\ some post-processing happens in solve - e.g.,
printing the symbol table of the \smodels\ format~\cite{lparseManual}.
\end{example}

\begin{note}
Program parts are mainly interesting for incremental grounding and solving of logic programs detailed in Section~\ref{sec:multi}.
For single shot solving, program parts should not be used.
The feature is merely listed for completeness here.
\end{note}

\paragraph{Include Statements}
Include statements allow for including files from within another file.
They have the following form:
%
\par
\medskip
\begin{tabular}{l}
\code{\#include~"{\itshape file}".}
\end{tabular}
\par
\medskip
\noindent
%
where \codeit{file} is a path to an encoding file.
When including a file it is first looked up relative to the current working directory.
If it is not found there, then it is looked up relative to the file it was included from.
Note that program part directives do not have an influence on included files,
that is, including a file is equivalent to passing it on the command line.

\begin{example}
Suppose we have file \attach{examples/include.lp}{include.lp} with the following program:
%
\lstinputlisting{examples/include.lp}
%
\marginlabel{%
To inspect the instantiation, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\\
\mbox{~}\attach{examples/include.lp}{include.lp}}\\
or:\\
\code{%
\mbox{~}clingo --text \textbackslash\\
\mbox{~}\attach{examples/include.lp}{include.lp}}
}%
%
We can simply pass the file on the command line
to include file \attach{examples/bird.lp}{bird.lp} from Example~\ref{ex:flies}.

Because files are included from the current working,
the following invocation with the given directory layout works too:
\begin{lstlisting}[numbers=none]
.
|-- bird.lp
\-- examples
    \-- include.lp

clingo examples/include.lp
\end{lstlisting}

And because files are included relative to the file with the include statement,
the following works too:
\begin{lstlisting}[numbers=none]
.
\-- examples
    |-- bird.lp
    \-- include.lp

clingo examples/include.lp
\end{lstlisting}
\end{example}

\subsection{Input Language of \clasp}\label{subsec:lang:clasp}

Solver \clasp~\cite{gekanesc07b} can be used to solve ASP, SAT, Maximum Satisfiability (MaxSAT; \cite{liman09a}),
and Pseudo-Boolean (PB; \cite{rouman09a}) constraint satisfaction/optimization problems.
To this end, \clasp\ accepts logic programs in \smodels\ format~\cite{lparseManual},
SAT and MaxSAT instances in DIMACS-cnf\footnote{\url{http://www.satcompetition.org/2009/format-benchmarks2009.html}}
and DIMACS-wcnf\footnote{\url{http://www.maxsat.udl.cat/12/requirements/index.html}} format,
and PB problems in OPB/WBO\footnote{\url{http://www.cril.univ-artois.fr/PB12/format.pdf}} format.
% To this end, \clasp\ accepts problems in
% \smodels\ format~\cite{lparseManual},
% DIMACS-cnf format\footnote{\url{http://www.satcompetition.org/2009/format-benchmarks2009.html}},
% DIMACS-wcnf format\footnote{\url{http://www.maxsat.udl.cat/12/requirements/index.html}},
% and OPB/WBO format\footnote{\url{http://www.cril.univ-artois.fr/PB12/format.pdf}}.

For ASP solving,
\clasp\ is typically invoked in a pipe reading
a logic program output by \gringo:
%
\begin{lstlisting}[numbers=none]
gringo [ options | files ] | clasp [ number | options ]
\end{lstlisting}
%
Note that \code{number} may be provided to specify a maximum number of answer sets
to be computed, where~\code{0} makes \clasp\ compute all answer sets.
This maximum number can also be set via
option \code{--models} or its abbreviation \code{-n}
(cf.\ Section~\ref{subsec:opt:clasp}).
By default, \clasp\ computes one answer set (if it exists).

To solve a problem in one of the supported formats stored in a \code{file},
an invocation of \clasp\ looks as follows:%
\begin{lstlisting}[numbers=none]
clasp [ number | options ] file
\end{lstlisting}
In general, \clasp\ autodetects the input format. However,
option \code{--opt-sat} is necessary to distinguish a
MaxSAT instance in DIMACS-cnf format from a normal SAT instance.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "guide"
%%% End:
