\section{Input Languages}\label{sec:language}

This section provides an overview of the input languages of
grounder \gringo, combined grounder and solver \clingo, 
and of solver \clasp.
The joint input language of \gringo\ and \clingo\ is detailed in
Section~\ref{subsec:lang:gringo}.
The control capacities of \clingo\ needed for multi-shot solving are detailed in Section~\ref{subsec:lang:clingo}.
This includes a few directives and their interplay with a scripting API.
Finally, Section~\ref{subsec:lang:clasp} is dedicated to the inputs handled by \clasp.

\subsection{Input Language of \gringo\ and \clingo}\label{subsec:lang:gringo}

The tool \gringo~\cite{gescth07a} is a grounder capable of translating
user-defined logic programs (usually, containing variables) into 
equivalent ground (that is, variable-free) programs.
The output of \gringo\ can be piped into solver \clasp~\cite{gekanesc07a,gekasc09c},
which then computes answer sets.
System \clingo\ internally couples \gringo\ and \clasp, thus,
it takes care of both grounding and solving.
In contrast to \gringo\ outputting ground programs, 
\clingo\ returns answer sets.

Usually, logic programs are specified in one or more (text) files whose names are
% passed via the command line
provided as arguments
in an invocation of either \gringo\ or \clingo.
% We below provide a description of 
In what follows, we describe the 
constructs belonging to the input language of \gringo\ and \clingo.

\subsubsection{Normal Programs and Integrity Constraints}\label{subsec:gringo:normal}
\index{Terms}
\index{Terms!Constants}
\index{Terms!Strings}
\index{Terms!Variables}
\index{Terms!Variables!Anonymous}
\index{Terms!Functions}
\index{Terms!\code{\#sup}}
\index{Terms!\code{\#inf}}

\begin{figure}
\vspace*{-19mm}
\railnontermfont{\rmfamily\itshape}%
\railalias{rusc}{\tt\char95}\railterm{rusc}
\railalias{rlsc}{[A-Za-z0-9\tt\char95']}\railterm{rlsc}
\railalias{any}{[\^{}\symbol{92}"$\dlsh$]}\railterm{any}
\railalias{bs}{\symbol{92}}\railterm{bs}
\railalias{esc}{[\symbol{92}"n]}\railterm{esc}
\begin{rail}
  term        : simpleterm | function | tuple;
  simpleterm  : (integer | constant | string | variable | rusc | '\#sup' | '\#inf');
  constant    : (rusc*) '[a-z]' (rlsc*);
  string      : '"' ((any | (bs esc))*) '"';
  variable    : (rusc*) '[A-Z]' (rlsc*);
  function    : constant '(' term (',' term*) ')';
  tuple       :          '(' term (',' term*) ')';
\end{rail}
\caption{Grammar for Terms.\label{fig:terms}}
\end{figure}

Every (non-propositional) logic program includes \emph{terms},
mainly to specify the arguments of atoms (see below).
The grammar for \gringo's (and \clingo's) terms is shown in Figure~\ref{fig:terms}.
The basic building blocks are simple terms:
\emph{integers}, \emph{constants}, \emph{strings}, and \emph{variables}
as well as the tokens ``\var{\char`\_},'' \const{\#sup}, and \const{\#inf}.
An integer is represented by means of an arithmetic expression,
further explained in Section~\ref{subsec:gringo:arith}.
Constants and variables are distinguished by their first letters, 
which are \emph{lowercase} or \emph{uppercase}, respectively,
where leading occurrences of ``\code{\char`\_}'' are allowed
(may be useful to circumvent name clashes).
Furthermore, a string is an arbitrary sequence of characters
enclosed in inverted comma (\code{"$\cdot$"}),
where any occurrences of ``\code{\textbackslash},'' newline, and inverted comma
must be masked via ``\code{\textbackslash\textbackslash},'' ``\code{\textbackslash n},''
and ``\code{\textbackslash"}.''
While a constant or string represents itself,
a variable is a placeholder for \emph{all} variable-free terms
in the language of a logic program.%
\footnote{The set of all terms constructible from the available
          constants and function symbols is called \emph{Herbrand universe}.}
Unlike with a variable name whose recurrences within a rule refer to the same variable,
the token ``\var{\char`\_}'' (not followed by any letter)
stands for an \emph{anonymous variable} that does not recur anywhere. 
(One can view this as if a new variable name is invented on each
 occurrence of ``\var{\char`\_}.'')
In addition, there are the special constants \const{\#sup} and \const{\#inf}
representing the largest and smallest element among all variable-free terms, respectively;
we illustrate their use in Section~\ref{subsec:gringo:aggregate}.
% the largest and the smallest possible values, respectively,
% which behave essentially like constants.
Next, (uninterpreted) \emph{functions} are complex terms composed of a name (like a constant)
and one or more terms as arguments. % ,
% surrounded by parentheses and separated by comma.
For instance, 
\code{\const{at}(\const{peter},\const{time}(12),X)}
is a function with three arguments:
constant \const{peter}, another function \code{\const{time}(12)}
with an integer argument, and variable~\var{X}.
Finally, there are \emph{tuples}, which are similar to \emph{functions} but without a name.
Note that there are no one-elementary tuples; a term of form \code{($t$)} is equivalent to \code{$t$}.
Examples for tuples are:
the empty tuple \code{()} and 
the tuple \code{(\const{at},\const{peter},\const{time}(12),X)} with four elements.

Rules of the following forms are admitted in a 
\emph{normal logic program} (with integrity constraints):
\par
\medskip
\begin{tabular}{rl@{}l}\label{eq:normal:rule}
\textbf{Rule:} & $A_0$&~\code{:-}~$L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Fact:} & $A_0$&\code{.}
\\
\textbf{Integrity Constraint:} & &~\code{:-}~$L_1\code{,}\dots\code{,}L_n$\code{.}
\end{tabular}
\index{Logic Programs}
\index{Logic Programs!Rules}%
\index{Logic Programs!Facts}%
\index{Logic Programs!Integrity Constraints}%
\par
\medskip
\noindent
The \emph{head}~$A_0$ of a rule or a fact is an \emph{atom} of the same 
syntactic form as a constant or function.
\index{Logic Programs!Atoms}%
In the \emph{body} of a rule or an integrity constraint,
every $L_j$ for $1\leq j\leq n$ is a \emph{literal} of the form $A$ or $\code{not}~A$,
where $A$ is an atom and
the connective \code{not} denotes default negation.
%\index{Literals}%
\index{Logic Programs!Literals}%
\index{Logic Programs!Literals!Default Negation}%
% The set of literals $\{L_1,\dots,L_n\}$ is called the body of the rule.
% Facts have an empty body.
We say that a literal~$L$ is \emph{positive} if it is an atom,
and \emph{negative} otherwise.
While the head atom~$A_0$ of a fact must unconditionally be true,
the intuitive reading of a rule corresponds to an implication:
if all positive literals in the rule's body are true and all negative
literals are satisfied, then~$A_0$ must be true.
On the other hand, an integrity constraint is a rule that filters solution candidates,
meaning that the literals in its body must not jointly be satisfied.

In ASP, the intended models of a logic program, i.e.,
sets of variable-free atoms such that all rules
(including facts and integrity constraints)
of the program are satisfied when the atoms in the set are true, 
are such that every true atom has an (acyclic) derivation from the program.
Such models are called \emph{answer sets}.
To get the idea, let us consider some small examples.

\begin{example}\label{ex:as:one}
Consider the following logic program:
%
\begin{lstlisting}[numbers=none]
a :- b.
b :- a.
\end{lstlisting}
%
When \pred{a} and \pred{b} are false, the bodies of both rules are false as well,
so that the rules are satisfied.
Furthermore, there is no (true) atom to be derived,
which shows that the empty set is an answer set. 
On the other hand, if only either \pred{a} or~\pred{b} is true,
the second or the first rule, respectively, is unsatisfied:
the body holds, but not the head.
Hence, an answer set cannot contain \pred{a} or~\pred{b} only.
It remains to investigate the set including both \pred{a} and~\pred{b}.
Although both rules are satisfied, % it is also clear that
\pred{a} and~\pred{b} cannot be derived acyclicly:
\pred{a} relies on~\pred{b}, and vice versa.
That is, the set including both \pred{a} and~\pred{b} is not an answer set. % either.
Hence, the empty set is the only answer set of the logic program.
\eexample
\end{example}

\begin{example}\label{ex:as:two}
For a second example, consider the following logic program:
%
\begin{lstlisting}[numbers=none]
a :- not b.
b :- not a.
\end{lstlisting}
%
Here, the empty set is not a model because both rules are unsatisfied.
However, the sets containing only either~\pred{a} or~\pred{b} are models.
To see that each of them is an answer set,
note that~\pred{a} is derived by the rule \code{\pred{a}\,:-\:not\:\pred{b}.}
if \pred{b} is false;
similarly,
\pred{b} is derived by \code{\pred{b}\,:-\:not\:\pred{a}.}
if \pred{a} is false.
Note that the set including both~\pred{a} and~\pred{b} is not an answer set
because neither atom can be derived if both are assumed to be true:
the bodies of the rules
\code{\pred{a}\,:-\:not\:\pred{b}.} and
\code{\pred{b}\,:-\:not\:\pred{a}.} are false.
Hence, we have that
either~\pred{a} or~\pred{b} belongs to
an answer set of the logic program.
\eexample
\end{example}

\begin{example}\label{ex:as:three}
To illustrate the use of facts and integrity constraints,
let us augment the logic program in Example~\ref{ex:as:two}:
\begin{lstlisting}[numbers=none]
a :- not b.
b :- not a.
c.
:- c, not b.
\end{lstlisting}
Since \code{\pred{c}.} is a fact,
atom \pred{c} must unconditionally be true, i.e.,
it belongs to every model.
In view of this,
the integrity constraint 
\code{:-\:c,\:not\:\pred{b}.}
tells us that \pred{b} must be true as well
in order to prevent its body from being satisfied.
However, this kind of reasoning does not provide us with
a derivation of \pred{b}.
Rather, we still need to make sure that the body
of the rule \code{\pred{b}\,:-\:not\:\pred{a}.} is satisfied,
so that atom~\pred{a} must be false.
Hence, the set containing \pred{b} and~\pred{c}
is the only answer set of the logic program
in Example~\ref{ex:as:three}.
\eexample
\end{example}

In the above examples, 
we used propositional logic programs to exemplify the idea
of an answer set: a model of a logic program such that all its true atoms are 
(acyclicly) derivable.
In practice, logic programs are typically non-propositional, i.e.,
they include schematic rules with variables.
The next example illustrates this.

\begin{example}\label{ex:flies}
Consider a child from the south pole watching cartoons,
where it sees a yellow bird that is not a penguin.
The child knows that penguins can definitely not fly (due to small wingspread),
but it is unsure about whether the yellow bird flies.
This knowledge is generalized by
the following schematic rules:
%
\lstinputlisting{examples/fly.lp} %[firstnumber=3]
%
The first rule expresses that it is generally possible that a bird flies,
unless the contrary, subject of the second rule, is the case.
The definite knowledge that penguins cannot fly
is specified by the third rule.

Later on, the child learns that the yellow bird
is a chicken called ``tweety,''
while its favorite penguin is called ``tux.''
The knowledge about these two individuals is
represented by the following facts:
\lstinputlisting[firstnumber=4]{examples/bird.lp}

When we instantiate the variable~\var{X} in the three schematic rules
with \const{tweety} and \const{tux},
we obtain the following ground rules:
%
\lstinputlisting[numbers=none,xrightmargin=-15pt,nolol]{examples/gfly.lp}
%
Further taking into account that \const{tweety} and \const{tux} are known to
be birds, that \const{tux} is a penguin, while \const{tweety} is not, and that
penguins can definitely not fly,
we can simplify the previous ground rules to obtain the following ones:%
\marginlabel{The reader can reproduce these ground rules
             by invoking:\\
             \code{\mbox{~}clingo --text \textbackslash\\
                   \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/fly.lp}{fly.lp}}\\
             or alternatively:\\
             \code{\mbox{~}gringo --text \textbackslash\\
                   \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/fly.lp}{fly.lp}}}
%
\lstinputlisting[numbers=none,nolol]{examples/sfly.lp}
%
Now it becomes apparent that \const{tweety}
may fly or not, while \const{tux} surely does not fly.
Thus, there are two answer sets for the three schematic rules above,
instantiated with \const{tweety} and \const{tux}.%
\marginlabel{To compute both answer sets, 
             invoke:\\
             \code{\mbox{~}clingo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
                   \mbox{~}\attach{examples/fly.lp}{fly.lp} 0}\\
             or alternatively:\\
             \code{\mbox{~}gringo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
                   \mbox{~}\attach{examples/fly.lp}{fly.lp} | clasp 0}}
\eexample
\end{example}

The above example illustrated how variables are used to represent all instances of
rules w.r.t.\ the language of a logic program.
In fact, grounder \gringo\ (or the grounding component of \clingo)
takes care of instantiating variables
such that an equivalent propositional logic program is obtained.
To this end,
rules are required to be \emph{safe}, 
\label{pg:safe}%
\index{Logic Programs!Safety}%
i.e.,
all variables in a rule must occur in some positive literal
(a literal not preceded by \code{not}) in the body of the rule.%
\footnote{%
The only exception to this are \emph{local} variables, % bound by conditions,
detailed in Section~\ref{subsec:gringo:condition} and~\ref{subsec:gringo:aggregate}.} 
For instance, the first two schematic rules in Example~\ref{ex:flies} 
are safe because they include \code{\pred{bird}(\var{X})} in their positive bodies.
This tells \gringo\ (or the grounding component of \clingo)
that the values to be substituted for~\var{X} are limited to birds.

%If a variable appears positively in some predicate, then we say that this predicate binds the variable.

Up to now, we have introduced terms, facts, (normal) rules, and integrity constraints.
Before we proceed to describe handy extensions to this simple core language,
keep in mind that the role of a rule (or fact) is that an atom in the
head can be derived to be true if the body is satisfied.
Unlike this, an integrity constraint implements a test,
but it cannot be used to derive any atom.
This universal meaning still applies when more sophisticated language constructs,
as described in the following, are used.

% Throughout this section we further extend the predicates that can be used 
% in a rule including comparison predicates (Section \ref{subsec:gringo:comp}) and aggregates (Section \ref{subsec:gringo:aggregate}).
% Furthermore, \gringo{} expects rules to be safe, i.e., \index{Safe Program}
% all variables that appear in a rule have to appear in some positive literal (a literal not preceded by \code{not}) in the body.
% If a variable appears positively in some predicate, then we say that this predicate binds the variable.
%
% Intuitively, the head of a rule has to be true whenever all its body literals are true.
% In ASP every atom needs some derivation, i.e., 
% an atom cannot be true if there is no rule deriving it.
% This implies that only atoms appearing in some head can appear in answer sets.
% Furthermore, derivations%
% \footnote{There are extensions like disjunctions 
% that go beyond simple derivability and also require minimality w.r.t. a reduct. 
% We do not cover the semantics of such constraints in this guide.}%
% have to be acyclic,
% a feature that is important to model reachability.
% As a simple example, consider the program \code{a :- b. b :- a.}
% The only answer set to this program is the empty set.
% Adding either \code{a.} or \code{b.} to the program results in the answer set $\{a,b\}$.
% Finally, note that default negation is ignored when checking for acyclic derivations 
% (we do not need a reason for an atom being false).
% Default negation can be used to express choices, e.g., the program \code{a :- not b. b :- not a.} 
% has the two answer sets $\{a\}$ and $\{b\}$.
% But in practice it is never needed to express choices this way.
% For example in the introductory example in Section~\ref{sec:quickstart} we used a cardinality 
% constraint, which provides a much more readable way to introduce choices.
% %\com{This paragraph contains a lot of information. Could someone help me making it more readable?}
%
% A fact has an empty body and thus its associated head predicate is always true 
% and appears in all answer sets.
% On the other hand, integrity constraints eliminate answer set candidates.
% They are merely tests that discard unwanted answer sets.
% That is, there are no answer sets that satisfy all literals in an integrity constraint.
% Elaborate examples on the usage of facts, rules, and integrity constraints
% are provided in Section~\ref{sec:examples}.

\subsubsection{Classical Negation}\label{subsec:gringo:negation}
\index{Logic Programs!Literals!Classical Negation}

% In logic programs, 
The connective \code{not} expresses default negation,
i.e., a literal $\code{not}~A$ is assumed to hold unless atom~$A$ is derived to be true.
In contrast, the classical (or strong) negation of an atom~\cite{gellif91a} % proposition
holds only if % the complement of the proposition 
it can be derived.
Classical negation, indicated by symbol ``\code{-},'' is permitted in front of atoms.
That is, if $A$ is an atom, then $\code{-}A$ is 
an atom representing the complement of~$A$.
% Semantically, $\code{-}A$ is simply a new atom,
The semantic relationship between $A$ and~$\code{-}A$
is simply that they 
% with the additional condition that~$A$ and~$\code{-}A$
must not jointly hold.
Hence,
classical negation can be understood as a syntactic feature
allowing us to impose an integrity constraint \code{:-\;$A$,\:-$A$.}
without explicitly writing it in a logic program.
Depending on the logic program at hand,
it may be possible that neither~$A$ nor~$\code{-}A$ is contained in an answer set,
thus representing a state where the truth and the falsity of~$A$ are both unknown.
% Observe that 
% that can be
% implemented via integrity constraints whose effect is to eliminate
% any answer set candidate containing complementary atoms.

\begin{example}\label{ex:flies:neg}
Using classical negation,
we can rewrite the schematic rules in Example~\ref{ex:flies}
in the following way:
% Consider a logic program comprising the following facts:
%
% \lstinputlisting[nolol]{examples/bird.lp}
\lstinputlisting{examples/flycn.lp} % [firstnumber=3]
%
Given the individuals \const{tweety} and \const{tux},
classical negation is reflected by 
the following (implicit) integrity constraints:%
\marginlabel{By invoking:\\
  \code{\mbox{~}clingo --text \textbackslash\\
        \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/flycn.lp}{flycn.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash\\
        \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/flycn.lp}{flycn.lp}}\\
the reader can observe that % \gringo\ indeed produces 
the integrity constraint in Line~4 is indeed part of the grounding.
The second one in Line 5 is not printed;
it becomes obsolete by a static analysis exhibiting that
\const{tux} does surely not fly.}
%
\begin{lstlisting}[firstnumber=4]
:- flies(tweety), -flies(tweety).
:- flies(tux),    -flies(tux).
\end{lstlisting}
There are still two answer sets,
containing \code{-\pred{flies}(\const{tux})} and 
either \code{\pred{flies}(\const{tweety})} or \code{-\pred{flies}(\const{tweety})}.

Now assume that we add the following fact to the program:
\begin{lstlisting}[numbers=none]
flies(tux).
\end{lstlisting}
Then,
\code{\pred{flies}(\const{tux})} must unconditionally be true,
and \code{-\pred{flies}(\const{tux})} is still derived by 
an instance of the third schematic rule.
% There no longer is any answer set for our new program using classical negation.
% In fact, answer set candidates that contain both
Since every answer set candidate containing
both \code{\pred{flies}(\const{tux})} and \code{-\pred{flies}(\const{tux})}
triggers
% \code{\pred{flies}(\const{tux})} and
% \code{\pred{-flies}(\const{tux})} violate 
the (implicit) integrity constraint in Line~5,
there no longer is any answer set.
\eexample
\end{example}

\subsubsection{Disjunction}\label{subsec:gringo:disjunction}
\index{Logic Programs!Disjunction}
\comment{R: We could add a section about disjunctive modeling later on though?}
Disjunctive logic programs permit connective~``\code{;}'' between atoms in rule heads.%
\footnote{Note that disjunction in rule heads was not supported by \clasp\ versions before series~4.}
\par
\medskip
\begin{tabular}{rl@{}l}\label{eq:disjunctive:rule}
\textbf{Rule:} & $A_0\text{\code{;}}\dots\text{\code{;}}A_m$&~\code{:-}~$L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Fact:} & $A_0\text{\code{;}}\dots\text{\code{;}}A_m$&\code{.}
\end{tabular}
\index{Logic Programs}
\index{Logic Programs!Rules!Disjunctive}%
\index{Logic Programs!Facts!Disjunctive}%
\par
\medskip
\noindent
A disjunctive head holds if at least one of its atoms is true.
Answer sets of a disjunctive logic program satisfy a minimality criterion
that we do not detail here
(see~\cite{eitpol06a,gekasc11b} for an implementation methodology in disjunctive ASP).
We only mention that the simple disjunctive program \code{\pred{a};\pred{b}.} has two answer sets,
one containing~\pred{a} and another one containing~\pred{b},
while both atoms do not jointly belong to an answer set.
After adding the rules of Example~\ref{ex:as:one}, a single answer set containing both~\pred{a} and~\pred{b} is obtained.
This illustrates that disjunction in ASP in neither strictly exclusive or inclusive but subject to minimization.

In general, the use of disjunction may increase
computational complexity~\cite{eitgot95a}.
% This is why \clingo%
% \footnote{Run as a monolithic system performing both grounding and \emph{solving}.}
% and solvers like 
% \assat~\cite{linzha04a},
% \clasp~\cite{gekanesc07a,gekasc09c},
% \nomorepp~\cite{angelinesc05c},
% \smodels~\cite{siniso02a}, and
% \smodelscc~\cite{warsch04a}
% do not % work on 
% handle disjunctive programs.
% Rather,
% \claspD~\cite{drgegrkakoossc08a},
% \cmodels~\cite{gilima06a,lierler05a}, or
% \gnt~\cite{janisesiyo06a}
% is needed % to be used 
% for solving a disjunctive program.%
% \footnote{% System 
%   \dlv~\cite{dlv03a} also deals with disjunctive programs,
%   but it uses a different syntax than presented here.}
We thus suggest to use ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
instead of disjunction, unless the latter is required for complexity reasons.

\subsubsection{Double Negation and Head Literals}\label{subsec:gringo:double}
\index{Logic Programs!Literals!Double Default Negation}
\index{Logic Programs!Literals!Head}

The input language of \gringo\ also supports double default negated literals,
written $\code{not}~\code{not}~A$.
They are satisfied whenever their positive counter-parts are but not vice versa. 
Unlike (purely) positive literals,
such literals do require a proof of $A$;
in other words, they cannot span positive cycles subject to minimization.
%
\begin{example}\label{ex:as:dneg}
Consider the logic program:

\begin{lstlisting}[numbers=none]
a :- not not b.
b :- not not a.
\end{lstlisting}
%
This program has the same stable models as the one in Example~\ref{ex:as:one} 
as well as the additional stable model containing both \pred{a} and \pred{b}.
This is because neither ``\code{not not a}'' nor ``\code{not not b}'' must be (finitely) derivable.
In fact, in contrast to Example~\ref{ex:as:one}, 
the above program induces no positive cycle between~\pred{a} and~\pred{b} that is subject to minimization.
\eexample
\end{example}

Also, there are literals in the head of rules.
These offer just another way to write integrity constraints,
putting the emphasis on the head literal.
In fact, the rule
\(\code{not}~A_0\)~\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n\)\code{.}
is equivalent to 
\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n,\code{not}~\code{not}~A_0\)\code{.}
and with double negation in the head, rule
\(\code{not}~\code{not}~A_0\)~\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n\)\code{.}
is equivalent to 
\code{:-}~\(L_1\text{\code{,}}\dots\text{\code{,}}L_n,\code{not}~A_0\)\code{.}

\begin{example}\label{ex:as:flynn}
Consider the logic program:

\marginlabel{To compute both answer sets, invoke:\\
  \code{\mbox{~}clingo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
        \mbox{~}\attach{examples/flynn.lp}{flynn.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo~\attach{examples/bird.lp}{bird.lp} \textbackslash\\
        \mbox{~}\attach{examples/flynn.lp}{flynn.lp} | clasp 0}
}
\lstinputlisting{examples/flynn.lp}
The possibility that a bird flies is expressed with a double negation here in the first line.
Solutions with flying penguins are filtered out in the second line.
Like in Example~\ref{ex:flies} there are two answer sets
but without an explicit atom to indicate that a bird does not fly.
Hence, the answer set where Tweety does not fly contains no atoms over predicate \pred{flies}/$1$.
\eexample
\end{example}

\begin{note}
  Note that negative head literals are also supported in disjunctions.
  For more information see \cite{litatu99a}.
\end{note}

\subsubsection{Boolean Constants}
\index{Boolean Constants}
\index{Logic Programs!Atoms!Boolean Constants}
%
Sometimes it is useful to have literals possessing a constant truth value.
Literals over the two \emph{Boolean constants} \code{\#true} and \code{\#false},
which are always true or false, respectively,
have a constant truth value.

\begin{example}
Consider the following program:
\marginlabel{%
  The unique answer set of the program,
  can be inspected by invoking:\\
  \code{\mbox{~}clingo \attach{examples/bool.lp}{bool.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/bool.lp}{bool.lp} \textbackslash \\ \mbox{~}| clasp 0}\\
  Note that this program simply produces an empty grounding:
  \code{\mbox{~}gringo --text \\ \mbox{~}\attach{examples/bool.lp}{bool.lp}}\\
  or alternatively:\\
  \code{\mbox{~}clingo --text \\ \mbox{~}\attach{examples/bool.lp}{bool.lp}}
  }
%
\lstinputlisting{examples/bool.lp}
The first rule uses \code{\#true} in the head.
Because this rule is a fact, it is trivially satisfied.
Similarly, the rules in lines~2 and~3 have satisfied heads.
The bodies of the last three integrity constraints are false.
Hence, the constraints do not cause a conflict.
Note that neither of the rules above derive any atoms.
Thus, we obtain the empty answer set for the program.
\eexample
\end{example}
See Example~\ref{ex:sort} below for an application of interest.
\subsubsection{Built-In Arithmetic Functions}\label{subsec:gringo:arith}
\index{Terms!Integers}
\index{Terms!Arithmetic Functions}
\index{Arithmetic Functions}
\index{Arithmetic Functions!Integers}
\index{Arithmetic Functions!Addition, \code{+}}
\index{Arithmetic Functions!Subtraction, \code{-}}
\index{Arithmetic Functions!Unary Minus, \code{-}}
\index{Arithmetic Functions!Multiplication, \code{*}}
\index{Arithmetic Functions!Division, \code{/}}
\index{Arithmetic Functions!Modulo, \code{\textbackslash}}
\index{Arithmetic Functions!Exponentiation, \code{**}}
\index{Arithmetic Functions!Absolute Value, \mbox{\textbar$\cdot$\textbar}}
\index{Arithmetic Functions!Bitwise AND, \code{\&}}
\index{Arithmetic Functions!Bitwise OR, \code{?}}
\index{Arithmetic Functions!Bitwise XOR, \code{\^}}
\index{Arithmetic Functions!Bitwise Complement, \code{\textasciitilde}}

Besides integers (constant arithmetic functions),
written as sequences of the digits \code{0}\dots\code{9}
possibly preceded by ``\code{-},''
\gringo\ and \clingo\ support a variety of arithmetic functions that
are evaluated during grounding.
The following symbols are used for these functions:
\code{+} (addition),
\code{-} (subtraction, unary minus),
\code{*} (multiplication),
\code{/} (integer division),
\code{\textbackslash} (modulo),
\code{**} (exponentiation),
\code{|$\cdot$|} (absolute value),
\code{\&} (bitwise AND),
\code{?} (bitwise OR),
\code{\^} (bitwise exclusive OR), and
\code{\textasciitilde} (bitwise complement).

\begin{example}\label{ex:arith:fun}
The usage of arithmetic functions is illustrated by the program:%
\marginlabel{%
  The unique answer set of the program,
  obtained after evaluating all arithmetic functions,
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/arithf.lp}{arithf.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/arithf.lp}{arithf.lp}}}
%
\lstinputlisting{examples/arithf.lp}
%
Note that the variables~\var{L} and~\var{R} are instantiated to~\const{7} and~\const{2},
respectively, before arithmetic evaluations.
Consecutive and non-separative (e.g., before ``\code{(}'')
spaces can optionally be dropped.
The four bitwise functions apply to signed integers,
using two's complement arithmetic. % of a negative integer.
\eexample
\end{example}

\begin{note}
An occurrence of a variable in the scope of an arithmetic function
only counts as positive in the sense of safety for simple arithmetic terms (cf.\ Page~\pageref{pg:safe}).
Such simple arithmetic terms are terms with exactly one variable occurrence
composed of the arithmetic functions \code{+}, \code{-} and \code{*}, and integers.
Moreover,
if multiplication is used, then the constant part must not evaluate to $0$ for the variable occurrence to be considered positive. 
E.g., the rule~\code{\pred{q}(\var{X})\,:-\:\pred{p}(\const{2}*(\var{X}+\const{1})).}
is considered safe, but
the rule~\code{\pred{q}(\var{X})\,:-\:\pred{p}(\var{X}+\const{X}).} is not.
\index{Logic Programs!Safety}%
\end{note}

\subsubsection{Built-In Comparison Predicates}\label{subsec:gringo:comp}
\index{Comparison Literals}
\index{Comparison Predicates}
\index{Comparison Predicates!Inequality, \code{"!=}}
\index{Comparison Predicates!Less, \code{<}}
\index{Comparison Predicates!Less or Equal, \code{<=}}
\index{Comparison Predicates!Greater, \code{>}}
\index{Comparison Predicates!Greater or Equal, \code{>=}}
\index{Logic Programs!Atoms!Comparison Predicates}

Grounder \gringo\ and the grounding component of \clingo\ 
feature a total order among variable-free terms.
The following built-in predicates to compare terms are
\code{!=} (not equal),
\code{<} (less than),
\code{<=} (less than or equal),
\code{>} (greater than), and
\code{>=} (greater than or equal).
\emph{Comparison literals} over the above \emph{comparison predicates} are used like predicate literals (cf.\ Section~\pageref{subsec:gringo:normal})
but are evaluated during grounding.

\begin{example}\label{ex:arith:pred}
The application of comparison literals to integers
is illustrated by the following program:%
\marginlabel{%
  The simplified ground program obtained by evaluating built-ins
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash}\\
  \code{\mbox{~}\attach{examples/arithc.lp}{arithc.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash}\\
  \code{\mbox{~}\attach{examples/arithc.lp}{arithc.lp}}}
%
\lstinputlisting{examples/arithc.lp}
%
The last two lines hint at the fact that arithmetic functions are evaluated
before comparison literals, so that the latter actually compare the
results of arithmetic evaluations.
\eexample
\end{example}

\begin{example}\label{ex:symb:pred}
Comparison literals can also be applied to constants and functions,
as illustrated by the following program:%
\marginlabel{%
  As above, by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/symbc.lp}{symbc.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/symbc.lp}{symbc.lp}}\\
  one can inspect the simplified ground program
  obtained by evaluating built-ins.}
%
\lstinputlisting{examples/symbc.lp}
%
Integers are compared in the usual way, constants are ordered lexicographically,
and functions both structurally and lexicographically.
% Function symbols are compared first using their arity.
% If the arity differs, then the name of the function symbol is compared lexicographically.
% If again the name differs, then arguments are compared component wise.
Furthermore, all integers are smaller than constants,
which in turn are smaller than functions.
\eexample
%\comment{add \#sup and \#inf?}
\end{example}

\begin{note}
An occurrence of a variable in the scope of a built-in comparison literal
does not count as a positive occurrence in the sense of safety (cf.\ Page~\pageref{pg:safe}),
i.e.,
comparison literals are not considered to be positive.
Note that comparison literals can be preceded with \code{not} or \code{not}~\code{not}.
In the first case, this is equivalent to using the complementary comparison literal 
(e.g., \code{<} and \code{>=} complement one another).
In the second case, the prefix has no effect on the meaning of the literal.
\index{Logic Programs!Safety}%
\end{note}

\subsubsection{Assignments}\label{subsec:gringo:assign}
\index{Terms!Variables!Assignments}
\index{Assignments}
\index{Assignments!Variable Assignment, \code{=}}
\index{Logic Programs!Atoms!Assignments}

Sometimes, it is desirable to define the value of a variable relative to a term, 
and to then reuse the variable as a shorthand.
The built-in predicate~''\code{=}'' admits unifying
(while solving simple arithmetic terms; see Section~\ref{subsec:gringo:arith})
variables on one side with terms on its other side,
whenever the resulting assignment atom occurs
in the bodies of rules or on the right-hand sides of conditions
(detailed in Section~\ref{subsec:gringo:condition}).

\begin{example}\label{ex:assign}
The usage of variable assignments is illustrated by the following program:%
\marginlabel{%
  The simplified ground program obtained from assignments
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/assign.lp}{assign.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/assign.lp}{assign.lp}}}
%
\lstinputlisting[lastline=2,belowskip=0pt]{examples/assign.lp}%
\lstinputlisting[firstline=3,aboveskip=0pt,numbers=none,nolol]{examples/assign.lp}
%
The body of the rule in Line~2 contains four variable assignments,
which directly or indirectly depend on~\var{X} and~\var{Y}.
The values of~\var{X} and~\var{Y} are obtained via atoms of the predicate \pred{num}/$1$.
The first assignment depends on~\var{X} to provide shortcut~\var{XX}.
Similarly, the second assignment depends on~\var{Y} to provide shortcut~\var{YY}.
The third assignment provides variable \var{Y'} because it occurs in a simple arithmetic expression,
winch is solved during unification.
The last assignment provides no variables and,
hence, is just a test,
checking if its left-hand side equals its right-hand side.
\eexample
\end{example}

\begin{example}\label{ex:unify}
This example illustrates how to unify with function terms and tuples:
\marginlabel{%
  The simplified ground program obtained from unifications
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/unify.lp}{unify.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/unify.lp}{unify.lp}}}
%
\lstinputlisting{examples/unify.lp}
%
Here, \code{\const{f}(\const{a},\var{X},\var{X}+\const{1})} or
\code{(\const{a},\var{X},\var{X}+\const{1})}, respectively,
is unified with instances of the predicate \code{sym}/$1$.
To this end,
arguments of \code{sym}/$1$ with matching arity
are used to instantiate the variable~\var{X} occurring
as the second argument in terms on the left-hand sides of~\code{=}.
With a value for~\var{X} at hand,
we can further check whether the arithmetic evaluation of~\code{\var{X}+\const{1}},
occurring as the third argument, coincides with the 
corresponding value given on the right-hand side of~\code{=}.
%
% Note the usage of \code{X+1} in the term.
% \gringo{} does not try to unify any term containing arithmetic 
% but in this example \code{X} occurs also directly as second argument of the argument
% and can thus be unified with.
% The term $X+1$ is merely a test that is deferred and checked later.
% For example, the fourth line is equivalent to:
% \begin{lstlisting}[firstnumber=6]
% unifyf(X) :- f(a,X,Y) := F, sym(F), Y == X + 1.
% \end{lstlisting}%
\eexample
\end{example}

\begin{note}
If a variable assignment is preceded by \code{not}, 
no unification happens.
Instead, the expression $\code{not}~t_1~\code{=}~t_n$ is equivalent to $t_1~\code{!=}~t_n$.
Like with comparison literals, the prefix ``\code{not~not}'' has no effect.
Unlike with built-in comparison literals,
an assignment is considered as
a positive (body) literal in the sense of safety (cf.\ Page~\pageref{pg:safe}),
so that variables occurring on one side can be instantiated.
However, this only works if assignments
can be made acyclicly, i.e.,
it must be possible to instantiate one side
without knowing the values of variables on
the other side.
E.g., the rule \code{\pred{p}(\var{X})\,:-\:\var{X}\:=\:\var{Y},\:\var{Y}\:=\:\var{X}.}
is not accepted by \gringo\ (or the grounding component of \clingo)
because values for~\var{X} rely on values for~\var{Y}, and vice versa.
\index{Logic Programs!Safety}%
%
% that assignments to some extent can bind variables.
% Of course cyclic assignments cannot bind variables.
% For example the rule  is rejected by \gringo{}.
% Either \code{X} or \code{Y} has to be provided by some positive predicate in this case.
% Additionally, unification is restricted to ground terms on the right hand side of the assignment, 
% that is, all variables on the right hand side have to be bound by some other predicate.
\end{note}

\subsubsection{Intervals}\label{subsec:gringo:interval}
\index{Terms!Intervals}

In Line~1 of Example~\ref{ex:assign},
there are five facts of the form~\code{\pred{num}($k$).}
over consecutive integers~$k$.
For a more compact representation,
\gringo\ and \clingo\ support integer intervals of the form $i$\code{..}$j$.
% , where~$i$ and~$j$ are integers.
Such an interval, representing each integer~$k$ such that $i\leq k\leq j$,
is expanded during grounding.
An interval is expanded differently depending on where it occurs.
In the head of a rule, an interval is expanded conjunctively
and in the body of a rule, disjunctively.
So we could have simply used the fact \code{num(1..5).} to represent the five facts.

\begin{example}\label{ex:int}
Consider the following program:
\marginlabel{%
  The simplified ground program obtained from intervals
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/int.lp}{int.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/int.lp}{int.lp}}}
\lstinputlisting{examples/int.lp}
Because the intervals in the second rule all occur in the rule head,
the intervals expand conjunctively.
Furthermore, the two intervals expand into the cross product \code{(1..3)$\times$(1..3)},
resulting in the following set of facts:
\begin{lstlisting}[numbers=none]
grid(1,1).  grid(1,2).  grid(1,3).
grid(2,1).  grid(2,2).  grid(2,3).
grid(3,1).  grid(3,2).  grid(3,3).
\end{lstlisting}
Similarly, intervals can be used in a rule body.
Typically, this is done in assignments, which expand disjunctively:
\begin{lstlisting}[firstnumber=2]
grid(X,Y) :- X=1..S, Y=1..S, size(S).
\end{lstlisting}
This rule expands into the same set of facts as before.
But intervals in assignments have the advantage that additional constraints can be added.
For example, one could add the comparison literals \code{X-Y!=0} and \code{X+Y-1!=S}
to the rule body to exclude the diagonals of the grid.
\eexample
\end{example}

\begin{note}
An occurrence of a variable in the specification of the bounds
of an integer interval, like~\var{S} in Line~2 of Example~\ref{ex:int}, 
does not count as a positive occurrence
in the sense of safety (cf.\ Page~\pageref{pg:safe}).
Hence, such a variable must also have another positive occurrence elsewhere;
here in \lstinline{size(S)}.
\index{Logic Programs!Safety}%
\end{note}

\subsubsection{Pooling}\label{subsec:gringo:pool}
\index{Terms!Pooling, \code{;}}
\index{Logic Programs!Atoms!Pooling, \code{;}}

The token ``\code{;}'' admits pooling alternative terms
to be used as arguments of an atom, function, or tuple. % for writing rules more compactly.
Argument lists written in the form \code{($\dots$,X;Y,$\dots$)} abbreviate multiple options:
\code{($\dots$,X),\linebreak[1]\:(Y,$\dots$)}.
Pools are expanded just like intervals, i.e.,
conjunctively in the head and disjunctively in the body of a rule.
In fact, the interval \code{1..3} is equivalent to the pool \code{(1;2;3)}.%
\footnote{%
This example uses the fact that there are no one-elementary tuples.
For example, the tuple \code{(1;2,3)} expands into \code{(1)} and \code{(2,3)}.
Hence, \code{(1)} is not a tuple here but equal to integer \code{1}.}

\begin{example}\label{ex:pool}
The following program makes use of pooling. 
It is similar to Example~\ref{ex:int}
but with the difference that unlike intervals pools have a fixed size:%
\marginlabel{%
  The simplified ground program obtained from pools
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/pool.lp}{pool.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/pool.lp}{pool.lp}}}
\lstinputlisting[xrightmargin=-5pt]{examples/pool.lp}
%
Because the pools in this rule all occur in the head,
the pools expand conjunctively.
Furthermore, the two pools expand into the cross product \code{(1..3)$\times$(1..3)},
resulting in the following set of facts:
\begin{lstlisting}[numbers=none]
grid(1,1).  grid(1,2).  grid(1,3).
grid(2,1).  grid(2,2).  grid(2,3).
grid(3,1).  grid(3,2).  grid(3,3).
\end{lstlisting}
Like intervals, pools can also be used in the body of a rule where they expand disjunctively:
\begin{lstlisting}
grid(X,Y) :- X=(1;2;3), Y=(1;2;3).
\end{lstlisting}
This rule expands into the same set of facts as before.
As in Example~\ref{ex:int}, additional constraints involving~\code{X} and~\code{Y} can be added.
\eexample
\end{example}

\subsubsection{Conditions and Conditional Literals}\label{subsec:gringo:condition}
\comment{RK: how do we structure the index? T: As you wish :) RK: better discuss this live some time :)}
\index{Aggregates!Conditions}
\index{Logic Programs!Literals!Conditions}%
%
A \emph{conditional literal} is of form $L:\boldsymbol{L}$,
where $L$ is a literal and $\boldsymbol{L}$ is a tuple of literals, called \textit{conditions}.
As in mathematical set notation,
we use the symbol~``\code{:}'' to formulate conditions.
Whenever $\boldsymbol{L}$ is empty, we get a regular literal and denote it as usual by $L$.

\begin{example}
The rule
\begin{lstlisting}[numbers=none]
a :- b:c.
\end{lstlisting}
yields \code{a} whenever either \code{c} is false (and thus no matter whether \code{b} holds or not) or both \code{b} and \code{c} are true.
\end{example}

\begin{note}
Logically, $L$ and $\boldsymbol{L}$ act as head and body,
which gives the conditional literal $L:\boldsymbol{L}$ the flavor of a nested implication
(see~\cite{haliya14a} for details).
\eexample{}
\end{note}

Together with variables,
conditions allow for specifying collections of expressions within a single rule or aggregate.
This is particularly useful for encoding conjunctions (or disjunctions) over
arbitrarily many ground atoms as well as for the compact representation of aggregates
(detailed in Section~\ref{subsec:gringo:aggregate}).

\begin{example}\label{ex:cond}
The following program uses in Line~5 and~6 conditions in a rule body and in a rule head, respectively:
%
\lstinputlisting{examples/cond.lp}
%
The rules in Line~5 and~6 are instantiated as follows:%
\marginlabel{%
  The reader can reproduce these ground rules by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/cond.lp}{cond.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/cond.lp}{cond.lp}}}
% %[firstnumber=5]
\begin{lstlisting}[numbers=none]
meet :- available(jane), available(john).
on(mon); on(tue); on(wed); on(thu); on(fri) :- meet.
\end{lstlisting}
%
The conjunction in the body of the first ground rule is obtained by replacing~\var{X} in
\code{\pred{available}(\var{X})} with all ground terms~$t$ such that
\code{\pred{person}($t$)} holds, namely, with $t=\const{jane}$ and $t=\const{john}$.
Furthermore, the condition in the head of the rule in Line~6 turns into
a disjunction over all ground instances of
\code{\pred{on}(\var{X})} where~\var{X} is substituted by all terms~$t$
for which \code{\pred{day}($t$)} holds.
That is, conditions in the body and in the head of a rule
are expanded to different basic language constructs.\footnote{%
Recall our suggestion from Section~\ref{subsec:gringo:disjunction}
to use ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
instead of disjunction, unless the latter is required for complexity reasons.
This also means that conditions must 
not be used \emph{outside of aggregates} in rule heads
if disjunction is unintended.}
\eexample
\end{example}

Further following set notation,
several conditions can be imposed by separating them through a comma, viz~``\code{,}''.
Note that commas are used to separate both literals in rule bodies as well as conditions.
To resolve this ambiguity, 
a condition is terminated with a semicolon ``\code{;}'' (rather than ``\code{,}''), if further body literals follow.

\begin{example}\label{ex:sort}
The following program uses a literal with a composite condition in the middle of the rule body. 
Note the semicolon ``\code{;}'' after the condition:
%
\lstinputlisting{examples/sort.lp}
%
The conditional literal in the second rule evaluates to false
whenever there is an element~\code{Y} between~\code{X} and~\code{Z}.
Hence, all rule instantiations where~\code{X} and~\code{Z} are not direct successors are discarded
because they have a false body.
On the other hand, whenever~\code{X} and~\code{Z} succeed each other,
the condition is false for all elements~\code{Z}.
This means that the literal with condition stands for an empty conjunction, which is true:%
\marginlabel{%
  The reader can reproduce these ground rules by invoking:\\
  \code{\mbox{~}clingo --text \textbackslash \\ \mbox{~}\attach{examples/sort.lp}{sort.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash \\ \mbox{~}\attach{examples/sort.lp}{sort.lp}}}%
\begin{lstlisting}[numbers=none]
set(1). set(2). set(3). set(4).
next(1,2). next(2,3). next(3,4).
\end{lstlisting}
We obtain an answer set where the elements of \code{set}/$1$ are ordered via \code{next}/$2$.
\eexample
\end{example}

\begin{note}
There are three important issues about the usage of conditions:
\begin{enumerate}
%
\item 
Any variable occurring within a condition 
does not count as a positive occurrence outside the condition
in the sense of safety (cf.\ Page~\pageref{pg:safe}).
Variables occurring in atoms not subject to any condition are \emph{global}. 
Each variable within an atom in front of a condition 
must be global or have a positive occurrence on the right-hand side of
the condition.
%
\item
During grounding,
the instantiation of global variables take precedence over non-global ones,
that is, the former are instantiated before the latter.
As a consequence, variables that occur globally are substituted by terms
before a condition is further evaluated.
Hence, the names of variables in conditions must be chosen with care,
making sure that they do not \emph{accidentally} match the names of global variables.
%
\item 
We suggest to use \emph{domain predicates}~\cite{lparseManual}
or built-ins (both used in lines~2 and~3  of Example~\ref{ex:sort})
in conditions.
\index{Aggregates!Conditions!Domain Predicates}%
\index{Logic Programs!Literals!Domain Predicates}%
\label{pg:domain}%
Literals over such predicates are completely evaluated during grounding.
In a logic program, domain predicates can be recognized by observing
that they are neither subject to negative recursion (through \code{not})
nor to disjunction or ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
in the head of any rule.
The domain predicates defined in Example~\ref{ex:sort} are:
\pred{set}/$1$ and \pred{next}/$1$.
Literals with such conditions expand to arbitrary length disjunctions or conjunctions in the head or body of a rule, respectively.
Otherwise, they give rise to nested implications.
For further details see~\cite{haliya14a}.
\end{enumerate}
\end{note}

\subsubsection{Aggregates}\label{subsec:gringo:aggregate}
\index{Logic Programs!Atoms!Aggregates}
\index{Aggregates}
\index{Aggregates!Weights}

Aggregates are one of the most useful modeling constructs since they allow for forming values from groups of selected items.
Together with comparisons they allow for expressing conditions over these items.
For instance, we can express that the sum of a semester's course credits must be at least 20, 
or that the sum of the prizes of my shopping items should not exceed 30 euros.

More formally,
an aggregate is a function on a set of tuples that are normally subject to conditions. 
By comparing an aggregated value with given values, we can extract a truth value from an aggregate's evaluation,
thus, obtaining an aggregate atom.
Aggregate atoms come in two variants depending whether they occur in a rule head or body.

The form of an \emph{aggregate atom} occurring in a rule body is as follows:
\index{Aggregates!Body}
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1\prec_1\alpha$?{?$\boldsymbol{t}_1$?:?$\boldsymbol{L}_1$?;?\,\dots\,?;?$\boldsymbol{t}_n$?:?$\boldsymbol{L}_n$?}?$\prec_2 s_2$?
\end{lstlisting}
%
Here, all $\boldsymbol{t}_i$ and $\boldsymbol{L}_i$ are non-empty tuples of terms and literals, respectively
(as introduced in Section~\ref{subsec:gringo:normal}). 
$\alpha$ is the name of some function that is to be applied to the term tuples $\boldsymbol{t}_i$
that remain after evaluating the conditions expressed by $\boldsymbol{L}_i$.
%
Finally, 
the result of applying $\alpha$ is compared by means of the comparison predicates $\prec_1$ and $\prec_2$ 
to the terms $s_1$ and~$s_2$ (usually representing arithmetic functions), respectively.
Note that one of `$s_1\prec_1$' or `$\prec_2 s_2$'%
\comment{RK: Martin always used double quotes for this stuff (and he put punctuation in the quotes)}
(or even both) can be omitted;
left out comparison predicates $\prec_1$ or $\prec_2$ default to ``\code{<=}'' (thus interpreting $s_1$ or~$s_2$ as lower and upper bounds),
respectively.

Currently, \gringo\ (and \clingo) support the aggregates 
\code{\#count}
\index{Aggregates!Count, \code{\#count}}%
(the number of elements), 
\code{\#sum}
\index{Aggregates!Sum, \code{\#sum}}%
(the sum of weights), 
\code{\#sum+}
\index{Aggregates!Sum plus, \code{\#sum+}}%
(the sum of positive weights), 
\code{\#min}
\index{Aggregates!Minimum, \code{\#min}}%
(the minimum weight), and
\code{\#max}
\index{Aggregates!Maximum, \code{\#max}}%
(the maximum weight).
The weight refers to the first element of a term tuple.
Aggregate atoms, as described above, are obtained by writing
either \code{\#count}, \code{\#sum}, \code{\#sum+}, \code{\#min}, or \code{\#max} for $\alpha$.
%
Note that unlike the other aggregates, the \code{\#count} aggregate does not require a weight.

\begin{example}
For example,
instances of the natural language examples for aggregates given at the beginning of this section
can be expressed as follows.

\begin{lstlisting}[numbers=none]
20 <= #sum { 4:course(db);      6:course(ai); 
             8:course(project); 3:course(xml) }

#sum { 3:bananas; 25:cigars; 10:broomstick } <= 30
\end{lstlisting}
Both aggregate atoms can be used as any other atom, possibly preceded by negation, in a body of a rule.
Within both aggregate atoms,
symbolic atoms like \lstinline{course(ai)} or \lstinline{broomstick} are associated with costs.
Assuming that \lstinline{course(ai)}, \lstinline{course(ai)} as well as \lstinline{bananas} and \lstinline{broomstick} are true, 
the aggregates inner sets get evaluated to \lstinline[mathescape]{$\{$4;6$\}$} and \lstinline[mathescape]{$\{$3;10$\}$}, respectively.
After applying the \lstinline{#sum} aggregate function to both sets, we get \lstinline{20 <= 10} and \lstinline{13 <= 30};
hence, in this case, the second aggregate atom holds while the first does not.\eexample
\end{example}

As indicated by the curly brackets, the literals within aggregates are treated as members of a set.
Hence, duplicates are not accounted for twice.
%
\begin{example}
For instance, the following aggregate atoms express the same:
\begin{lstlisting}[numbers=none,escapechar=@]
#count {42:a;       t:not b         } = 2@\textnormal{ and}@ 
#count {42:a; 42:a; t:not b; t:not b} = 2@\textnormal{.}@  
\end{lstlisting}
That is, if \lstinline{a} holds but not \lstinline{b}, both inner sets reduce to \lstinline[mathescape]{$\{$42;t$\}$};
and so both aggregate atoms evaluate to true.
%
However, both are different from the aggregates
\begin{lstlisting}[numbers=none,escapechar=@]
#count {42:a;       t:not b; s:not b} = 2@\textnormal{ and}@
#count {42:a; 42:a; t:not b; s:not b} = 2
\end{lstlisting}
which hold if both \lstinline{a} and \lstinline{b} are false,
yielding \lstinline[mathescape]{#count$\{$t;s$\}$ = 2}.
\eexample
\end{example}

Likewise, the literals of other aggregates are understood as sets.
%
\begin{example}
Consider the next two summation aggregates:
\begin{lstlisting}[numbers=none,escapechar=@]
#sum { 3    :cost(1,2,3); 3    :cost(2,3,3) } = 3@\textnormal{ and}@ 
#sum { 3,1,2:cost(1,2,3); 3,2,3:cost(2,3,3) } = 6@\textnormal{.}@
\end{lstlisting}
As done in Section~\ref{subsec:tsp:instance},
an atom like \lstinline{cost(1,2,3)} can be used to represent an arc from node \lstinline{1} to \lstinline{2} with cost \lstinline{3}.
If both \lstinline{cost(1,2,3)} and \lstinline{cost(2,3,3)} hold,
the first sum evaluates to \lstinline{3} while the second yields \lstinline{6}.
Note that all term tuples, the singular one \lstinline{3} as well as the ternary ones, \lstinline{3,1,2} and \lstinline{3,2,3}, respectively,
share the same weight, viz.~\lstinline{3}.
However,
the set property makes the first aggregate count edges with the same cost only once,
while the second one accounts for each edge no matter whether they have the same cost or not.
To see this, observe that after evaluating the conditions in each aggregate, the first one reduces to
\lstinline[mathescape]{#sum $\{$ 3 $\}$}, while the second results in \lstinline[mathescape]{#sum $\{$ 3,1,2; 3,2,3 $\}$}.
In other words, associating each cost with its respective arc enforces a multi-set property;
in this way, the same cost can be accounted for several times.
\eexample
\end{example}

Whenever a rule head is a (single) aggregate atom, the derivable head literals must be distinguished.
This is done by appending such atoms (or in general literals) separated by an additional `:' to the tuples:
\index{Aggregates!Head}
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1\prec_1\alpha$?{?$\boldsymbol{t}_1$?:?$L_1$?:?$\boldsymbol{L_1}$?;?\,\dots\,?;?$\boldsymbol{t}_n$?:?$L_n$?:?$\boldsymbol{L_n}$?}?$\prec_2 s_2$?
\end{lstlisting}
%
Here, all $L_i$ are symbolic literals as introduced in Section~\ref{subsec:gringo:normal}, while all other entities are as described above.
The second colon in 
\lstinline[mathescape]{$\boldsymbol{t}_i$:$L_i$:$\boldsymbol{L_i}$}
is dropped whenever $\boldsymbol{L_i}$ is empty,
yielding 
\lstinline[mathescape]{$\boldsymbol{t}_i$:$L_i$}.
%
Unlike with body aggregates, only singular head aggregates are supported.

\comment{RK: the translation below only makes sense in the propositional case}
There are some shorthands that can be used in the syntactic representation of aggregates.
%
The expression
%
\begin{lstlisting}[numbers=none,mathescape]
$s_1${$L_1$:$\boldsymbol{L_1}$;$\,\dots\,$;$L_n$:$\boldsymbol{L_n}$}$ s_2$
\end{lstlisting}
%
where all entities are defined as above 
is a shortcut for
%
\begin{lstlisting}[numbers=none,mathescape]
$s_1$ <= #count {$t_1$:$L_1$:$\boldsymbol{L_1}$;$\,\dots\,$;$t_n$:$L_n$:$\boldsymbol{L_n}$} <= $s_2$
\end{lstlisting}
%
if it appears in the head of a rule, and
it is a shortcut for
%
\begin{lstlisting}[numbers=none,mathescape]
$s_1$ <= #count {$t_1$:$L_1$,$\boldsymbol{L_1}$;$\,\dots\,$;$t_n$:$L_n$,$\boldsymbol{L_n}$} <= $s_2$
\end{lstlisting}
%
if it appears in the body of a rule.
In both cases, all $t_i$ are pairwisely distinct terms generated by \gringo\
whenever the distinguished head literals $L_i$ are different.
%
Note that one (or both) of $s_1$ and $s_2$ can be omitted .

\begin{example}
The rule
\begin{lstlisting}[numbers=none]
{ a ; b }.
\end{lstlisting}
is expanded by \gringo\ to
\comment{RK: the example uses not terms but term tuples I would suggest to use $\boldsymbol{t_i}$ above}
\comment{RK: in the next gringo release I will remove the first one from the rewriting}
\begin{lstlisting}[numbers=none]
#count{ 1,0,a : a; 1,0,b : b }.
\end{lstlisting}  
Here, \gringo\ generates two distinct term tuples \lstinline{1,0,a} and \lstinline{1,0,b}.
With \clingo, we obtain four answer sets representing all sets over \code{a} and \code{b}.

Same head literals yield identical terms, as we see next.
The rule
\begin{lstlisting}[numbers=none]
{ a ; a }.
\end{lstlisting}
is expanded by \gringo\ to
\begin{lstlisting}[numbers=none]
#count{ 1,0,a : a; 1,0,a : a }.
\end{lstlisting}  

In fact, within the term tuple produced by \gringo\
the second term indicates the number of preceding default negations,
and the third reproduces the atom as a term in order to make the whole term tuple unique.

To see this, observe that the rule
\begin{lstlisting}[numbers=none]
{a; not a;not not a}.
\end{lstlisting}
is expanded by \gringo\ to\comment{T2R: Was machen wir mit dem \#true? RK: um deine Frage nicht zu beantworten: gringo shifted alles was kein Atom ist in die Condition}
\begin{lstlisting}[numbers=none]
#count{ 1,0,a : a; 
        1,1,a : #true : not a; 
        1,2,a : #true : not not a }.
\end{lstlisting}
\eexample
\end{example}

\begin{note}
By allowing the omission of \const{\#count},
so-called ``cardinality constraints''~\cite{siniso02a}
can almost be written in their traditional notation (without keyword, yet different separators),
as put forward in the legendary \lparse\ grounder~\cite{lparseManual}.  
\comment{RK: we have to do this for all remarks then ...}
\eexample
\end{note}

Having discussed aggregate atoms,
let us note that there is a second way to use aggregates:
the values obtained by evaluating them can be assigned to variables.
To this end, \gringo\ and \clingo\ allow for using aggregates
\code{\#sum}, \code{\#min}, \code{\#max}, and \code{\#count} in assignments.
\index{Aggregates!Assignments}%
\index{Assignments!Aggregates}%
For instances, the following rules assign the obtained values to a variable:
\begin{lstlisting}[numbers=none]
sum(X) :- X = #sum   { 2:a; 3:a }.
min(X) :- X = #min   { 2:a; 3:a }.
max(X) :- X = #max   { 2:a; 3:a }.
cnt(X) :- X = #count { 2:a; 3:a }.
\end{lstlisting}
Under the assumption that atom~\pred{a} holds,
the atoms \code{\pred{sum}(\const{5})}, \code{\pred{min}(\const{2})},
\code{\pred{max}(\const{3})}, and \code{\pred{cnt}(\const{2})} are
derived by the above rules.
If~\pred{a} does not hold, we derive 
\code{\pred{sum}(\const{0})}, \code{\pred{min}(\const{\#sup})},
\code{\pred{max}(\const{\#inf})}, and \code{\pred{cnt}(\const{0})}.
%
Here, the special constants \const{\#sup} and \const{\#inf}
(introduced in Section~\ref{subsec:gringo:normal}),
obtained by applying \code{\#min} and \code{\#max} to the empty set of weights, respectively,
indicate the neutral elements of the aggregates.
%
These constants can also be used as weights subject to 
\code{\#min} and \code{\#max} (in order to exceed any other ground term):
\begin{lstlisting}[numbers=none]
bot :-      #min { #inf : a } -1000.
top :- 1000 #max { #sup : a }.
\end{lstlisting}
Assuming that atom~\pred{a} holds,
the atoms~\pred{bot} and~\pred{top} are derived by the above rules
because both \code{\#inf <= -1000} and \code{1000 <= \#sup} hold.

Although it seems convenient to use assignments of aggregates' values,
this feature should be used with care.
If the literals of an aggregate belong to domain predicates
(see Page~\pageref{pg:domain}) or built-ins,
\gringo\ or \clingo\ evaluates the aggregate during grounding, so obtaining
a unique value to be assigned.
\index{Aggregates!Assignments!Domain Predicates}%
\index{Assignments!Aggregates!Domain Predicates}%
Otherwise, if the literals do not belong to domain predicates,
the value of an aggregate is not known during grounding,
in which case \gringo\ or \clingo\ unwraps all possible outcomes of the
aggregate's evaluation.
The latter can lead to a space blow-up, which should be taken into account
if space becomes a bottleneck.

% In particular, if there are multiple occurrences
% $L\code{=}w_1,\dots,L\code{=}w_k$
% of a literal~$L$, in combination with \const{\#min} and \const{\#max},
% it is not the same like having $L\code{=}w_1+\dots+w_k$.
% To see this, note that the program consisting of the facts:
% \begin{lstlisting}[numbers=none]
% 2 #max [a=2].  2 #min [a=2].
% \end{lstlisting}
% has $\{\code{a}\}$ as its unique answer set, while there is no answer set for:
% \begin{lstlisting}[numbers=none]
% 2 #max [a,a].  2 #min [a,a].
% \end{lstlisting}

% If literals ought not to be repeated,
% we can use \const{\#count} instead of \const{\#sum}.
% Syntactically, \const{\#count} requires curly instead of square
% brackets, and there must not be any weights within a \const{\#count} aggregate.
% Regarding semantics,
% % \begin{equation*}%\label{eq:aggregate:atom}
% $(
%   l\,
%   \const{\#count} 
%   \,
%   \code{\char`\{}
%   \,
%   L_1\code{,}
%   \dots\code{,}
%   L_n
%   \,
%   \code{\char`\}}
%   \,
%   u
% )$ 
% %\end{equation*}
% reduces to
% $(
%   l\,
%   \const{sum}
%   \,
%   \code{[}
%   \,
%   L_1\code{=}\const{1}\code{,}
%   \dots\code{,}
%   L_m\code{=}\const{1}
%   \,
%   \code{]}
%   \,
%   u
% )$,
% where $\{L_1,\dots,L_m\}=\{L_i \mid 1\leq i\leq n\}$ is obtained by dropping
% repeated literals.
% Of course, the use of~$l$ and~$u$ is optional also with \const{\#count}.
% As an example, note that the next aggregate atoms express the same:
% \begin{lstlisting}[numbers=none,escapechar=@]
% 1 #sum   [a=1, not b=1]     1  @\textnormal{and}@ 
% 1 #count {a,a, not b,not b} 1@\textnormal{.}@  
% \end{lstlisting}
% Keyword \const{\#count} can be omitted (like \const{\#sum}),
% so that the following are synonyms:
% \begin{lstlisting}[numbers=none,escapechar=@]
% 1 #count {a, not b} 1  @\textnormal{and}@ 
% 1        {a, not b} 1@\textnormal{.}@  
% \end{lstlisting}
% The last notation is similar to the one of so-called
% ``cardinality constraints''~\cite{siniso02a,lparseManual},
% which are aggregate atoms using counting as their operation.

\com{R2T: please check. I am particularly unhappy with the $s_1$ and $s_2$ but we do not have a name for these. And this just glosses over saftey. More details?}
After considering the syntax and semantics of ground aggregate atoms,
we now turn our attention to non-ground aggregates.
Regarding contained variables,
only variable occurences in the terms $s_1$ and $s_2$ give rise to global variables.
Hence, any variable in an aggregate element must be bound by 
either a positive global occurrence or
a variable that occurs positively in its condition $\boldsymbol{L_i}$.
Variable names in aggregate elements have to be chosen carefully to not accidentally clash with global variables.
Furthermore, pools and intervals in aggregate elements give rise to multiple aggregate elements;
very similar to rules.
Finally, note that aggregates can also be used in assignments,
but using this feature is only recommended for aggregates whose atoms belong to domain predicates
because space blow-up quickly becomes a bottleneck with such assignments.
The following example, making exhaustive use of aggregates,
nonetheless demonstrates this and other features.

\begin{example}\label{ex:aggr}
Consider a situation where an informatics student
wants to enroll for a number of courses at the beginning of a new term.
In the university calendar, eight courses are found eligible,
and they are represented by the following facts:
%
\lstinputlisting[xrightmargin=-20pt,lastline=8,basicstyle=\ttfamily\small]{examples/aggr.lp}
%
In an instance of \const{course}/$3$,
the first argument is a number identifying one of the eight courses,
and the third argument provides the course's contact hours per week.
The second argument stands for a subject area:
\const{1} corresponding to ``theoretical informatics,''
\const{2}               to ``practical informatics,''
\const{3}               to ``technical informatics,''
and~\const{4}               to ``applied informatics.''
For instance, atom \code{\const{course}(\const{1},\const{2},\const{5})}
expresses that course~\const{1} accounts for~\const{5} contact hours per week
that may be credited to subject area~\const{2} (``practical informatics'').
Observe that a single course is usually eligible for multiple
subject areas.

After specifying the above facts,
the student starts to provide personal constraints on the courses to enroll.
The first condition is that~\const{3} to~\const{6} courses should be enrolled:
%
\lstinputlisting[nolol,firstline=11,lastline=11,firstnumber=9]{examples/aggr.lp}
%
Instantiating the above \const{\#count} aggregate
yields the following ground rule:%
\marginlabel{%
  The full ground program is obtained by invoking:\\
  \code{\mbox{~}gringo --text \attach{examples/aggr.lp}{aggr.lp}}}
%
\comment{RK: what is outputted by gringo looks actually quite different}
\begin{lstlisting}[numbers=none]
3 <= #count { 1 : enroll(1); 2 : enroll(2);
              3 : enroll(3); 4 : enroll(4); 
              5 : enroll(5); 6 : enroll(6);
              7 : enroll(7); 8 : enroll(8) } <= 6.
\end{lstlisting}
%
Observe that an instance of atom~\code{\const{enroll}(\var{C})} is included for each
instantiation of~\var{C} such that \code{\const{course}(\var{C},\var{S},\var{H})}
holds for some values of~\var{S} and~\var{H}.
Duplicates resulting from distinct values for~\var{S} are removed, thus,
obtaining the above set of ground atoms.
\footnote{Also, note the difference to \lstinline{3 \{  enroll(C) : course(C,_,_) \} 6.} being always false.}\comment{RK: does the footnote make any sense?}

The next constraints of the student regard the subject areas of enrolled courses:
%
\lstinputlisting[nolol,firstline=13,lastline=16,firstnumber=10]{examples/aggr.lp}
%
Each of the three integrity constraints above contains a cardinality constraint.
Recall that aggregates operate on sets and thus duplicates are removed;
hence we use terms tuples to establish a multiset.
Thus, the integrity constraint in Line~10 is instantiated as follows:
%
% \begin{lstlisting}[firstnumber=10,stepnumber=10]
% :- [ enroll(1) = 1, enroll(1) = 1, 
%      enroll(2) = 1, enroll(2) = 1,
%      enroll(3) = 1, enroll(3) = 1,
%      enroll(4) = 1, enroll(4) = 1, enroll(4) = 1,
%      enroll(5) = 1, enroll(5) = 1,
%      enroll(6) = 1, enroll(6) = 1,
%      enroll(7) = 1, enroll(7) = 1, enroll(7) = 1,
%      enroll(8) = 1, enroll(8) = 1 ] 10.
% \end{lstlisting}
\begin{lstlisting}[firstnumber=10,stepnumber=10]
:- 10 >= #count { 1,1,5:enroll(1); 1,2,5:enroll(1); 
                  2,1,4:enroll(2); 2,2,4:enroll(2); 
                  3,1,6:enroll(3); 3,3,6:enroll(3); 
 4,1,3:enroll(4); 4,3,3:enroll(4); 4,4,3:enroll(4); 
                  5,1,4:enroll(5); 5,4,4:enroll(5); 
                  6,2,2:enroll(6); 6,3,2:enroll(6); 
 7,2,4:enroll(7); 7,3,4:enroll(7); 7,4,4:enroll(7); 
                  8,3,5:enroll(8); 8,4,5:enroll(8) }. 
\end{lstlisting}
%
Note that courses~\const{4} and~\const{7} count three times because
they are eligible for three subject areas, viz., there are three
distinct instantiations for~\var{S} in
\code{\const{course}(\var{4},\var{S},\const{3})} and
\code{\const{course}(\var{7},\var{S},\const{4})}, respectively.
Comparing the above ground instance,
the meaning of the integrity constraint in Line~10 is that the 
number of eligible subject areas over all enrolled courses
must be more than~\const{10}.
Similarly, the integrity constraint in Line~11 expresses the requirement
that at most one course of subject area~\const{2} (``practical informatics'')
is not enrolled,
while Line~12 stipulates that the enrolled courses
amount to less than six nominations of
subject area~\const{3} (``technical informatics'') 
or~\const{4} (``applied informatics'').

The remaining constraints of the student deal with contact hours.
To express them, we first introduce an auxiliary rule and a fact:
%
\lstinputlisting[nolol,firstline=18,lastline=19,firstnumber=13]{examples/aggr.lp}
%
The rule in Line~13 projects instances of \pred{course}/$3$ to
\pred{hours}/$2$, thereby, dropping courses' subject areas.
This is used to not consider the same course multiple times within the following
integrity constraints:
\footnote{Alternatively, we could also use \lstinline{course(C,_,H).}}
%
\lstinputlisting[nolol,firstline=21,lastline=23,firstnumber=15]{examples/aggr.lp}
%
As Line~15 shows,
we may use default negation via ``\code{not}'' in front of aggregate atoms,
and bounds may be specified in terms of variables.
In fact, by instantiating~\var{M} to~\const{20},
we obtain the following ground instance of the integrity constraint in Line~15:
%
\begin{lstlisting}[firstnumber=15,stepnumber=15]
:- not 18 <= #sum { 5,1 : enroll(1); 4,2 : enroll(2);
                    6,3 : enroll(3); 3,4 : enroll(4);
                    4,5 : enroll(5); 2,6 : enroll(6);
                    4,7 : enroll(7); 5,8 : enroll(8) } <= 20.
\end{lstlisting}
%
The above integrity constraint states that the \const{\#sum} of contact hours per week
must lie in-between~\const{18} and~\const{20}.
Note that the \const{\#min} and \const{\#max} aggregates in Line~16 and~17, respectively,
work on the same (multi)set \comment{RK: multiset?} of weighted literals as in Line~15.
While the integrity constraint in Line~16 stipulates that any course to enroll
must include more than~\const{2} contact hours,
the one in Line~17 prohibits enrolling for courses of~\const{6} or more contact hours.
Of course, the last two requirements could also be formulated as follows:
%
\begin{lstlisting}[firstnumber=16]
:- enroll(C), hours(C,H), H <= 2.
:- enroll(C), hours(C,H), H >= 6.
\end{lstlisting}

Finally, the following rules illustrate the use of aggregates within assignments:
%
\lstinputlisting[nolol,firstline=25,lastline=26,firstnumber=18]{examples/aggr.lp}
%
Note that similar aggregates have already been used in Line~9 and~15, respectively.
In Line~9 the keyword \const{\#count} has been omitted for convenience.
Moreover, Line~9 distinguishes eight terms, while Line~18 discerns only five.
More importantly, the usage of aggregates in the last two lines is different from before,
as they now serve to assign an integer to a variable~\var{N}.
In this context, bounds are not permitted, and so none are provided in Line~18 and~19.
The effect of these two lines is that the student can read off the number of
courses to enroll and the amount of contact hours per week from instances of
\pred{courses}/$1$ and \pred{hours}/$1$ belonging to an answer set.%
\marginlabel{%
  To compute the unique answer set of the program, invoke:\\
  \code{\mbox{~}gringo \attach{examples/aggr.lp}{aggr.lp} | \textbackslash\\
        \mbox{~}clasp -n 0}\\
  or alternatively:\\
  \code{\mbox{~}clingo -n 0 \attach{examples/aggr.lp}{aggr.lp}}}
%
In fact, running \clasp\ shows the student that a unique
collection of~\const{5} courses to enroll satisfies all requirements:
the courses~\const{1}, \const{2}, \const{4}, \const{5}, and~\const{7},
amounting to~\const{20} contact hours per week.

As mentioned in Section~\ref{subsec:gringo:condition},
multiple literals may be connected via ``\code{,}'' in order to construct
composite conditions within an aggregate.
Furthermore, the usage of non-domain predicates within an aggregate
together with an assignment (like \pred{enroll}/$1$ in Line~18 and~19 above)
is not recommended in general because the space blow-up may be significant.
\eexample
\end{example}

\begin{note}
\begin{enumerate}
\item 
  Users familiar to \gringo~3 might remember that conditions in aggregates 
  had to be either literals over domain predicates or built-ins.
  This restriction does not exist anymore in \gringo\ and \clingo~4.
\item 
  Aggregate atoms in the head can be understood as a combination of unrestricted choices with body aggregates enforcing the constraint expressed by the
  original head aggregate.
  In fact, when producing \smodels\ format, all aggregate atoms occurring in rule heads are transformed away.
  For details consult~\cite{siniso02a,gekakasc12a}.
\end{enumerate}
\end{note}

%\com{Should we mention stratifed aggregates that do not necessarily need conditions?}

\subsubsection{Optimization}\label{subsec:gringo:optimize}
\index{Statements!Optimize Statements}

Optimization statements extend the basic question of
whether a set of atoms is an answer set to
whether it is an optimal answer set.
To support this reasoning mode, \gringo\ and \clingo\ adopt the
optimization statements of \lparse~\cite{lparseManual},
indicated via keywords \const{\#maximize} and \const{\#minimize}.
As an optimization statement does not admit a body, any (local) variable
in it must also occur in an atom \REW{(over a domain or built-in predicate)}
on the right-hand side of a condition (cf.\ Section~\ref{subsec:gringo:condition})
within the optimization statement.
As with aggregates, duplicate terms are removed;
additionally, priorities can be associated with each weighted literal.
A (ground) optimize statement has the form: 
\index{Statements!Optimize Statements!\#minimize}%
\index{Statements!Optimize Statements!\#maximize}%
\[
\mathsf{\mu}\,\code{\{}\,\boldsymbol{t}_1:\boldsymbol{L}_1,\dots,\boldsymbol{t}_n:\boldsymbol{L}_n\,\code{\}}
\] 
where $\mathsf{\mu}$ is either \code{\#maximize} or \code{\#minimize}, 
$\boldsymbol{t}_i$ and $\boldsymbol{L}_i$ are non-empty tuples of terms and literals, respectively
(as introduced in Section~\ref{subsec:gringo:normal}).
The first element of each tuple $\boldsymbol{t}_i$ is supposed to be an (integer) weight $w_i$
that may optionally be furnished with an (integer) priority $p_i$ by means of term $w_i@p_i$.

The semantics of an optimization statement is intuitive:
an answer set is \emph{optimal} if the sum of weights
% (using~\const{1} for unsupplied weights)
of literals that hold is maximal or minimal, as required by the statement,
among all answer sets of the given program.
This definition is sufficient if a single optimization statement is specified
along with a logic program.
If different priorities occur in the program, 
then, depending on the type of optimize statement,
answer sets whose sum of weights assigned to higher priorities
is maximized or minimized, respectively.

Note that for compatibility with \lparse, if multiple optimize statements are used, 
default priorities are assigned.
The $n$-th statement gets priority $n$, thus, the later statements have higher priorities.\comment{RK: not true anymore}
We suggest that if you want to use more than one optimization statement,
to always specify priorities to make the program more readable and order independent.

\begin{example}\label{ex:opt}
To illustrate optimization, we consider a hotel booking situation
where we want to choose one among five available hotels.
The hotels are identified via numbers assigned in descending order of stars.
Of course, the more stars a hotel has, the more it costs per night.
As ancillary information, we know that hotel~\const{4} is located
on a main street, which is why we expect its rooms to be noisy.
This knowledge is specified in Line~1--5 of the following program:
%
\lstinputlisting[xrightmargin=-26pt]{examples/opt.lp}
%
Line~6--8 contribute optimization statements in inverse order of significance,
according to which we want to choose the best hotel to book.
The most significant optimization statement in Line~8 states that
avoiding noise is our main priority.
The secondary optimization criterion in Line~7 consists of
minimizing the cost per star.
Finally, the third optimization statement in Line~6 specifies that we want
to maximize the number of stars among hotels that are otherwise indistinguishable.
The optimization statements in Line~6--8 are instantiated as follows:%
\marginlabel{%
  The full ground program is obtained by invoking:\\
  \code{\mbox{~}gringo --text \attach{examples/opt.lp}{opt.lp}}}
%
\begin{lstlisting}[firstnumber=6,breakindent=0pt,escapechar=&]
#maximize { 5@1,1:hotel(1), 4@1,2:hotel(2),&\\&            3@1,3:hotel(3), 3@1,4:hotel(4), 2@1,5:hotel(5) }.
#minimize { 34@2,1:hotel(1), 35@2,2:hotel(2),&\\&            30@2,3:hotel(3), 25@2,4:hotel(4), 30@2,5:hotel(5) }.
#minimize { 1@3:noisy }.
\end{lstlisting}
If we now use \clasp\ or \clingo\ to compute an optimal answer set,%
\marginlabel{%
  To compute the unique optimal answer set, invoke:\\
  \code{\mbox{~}gringo \attach{examples/opt.lp}{opt.lp} | \textbackslash\\
        \mbox{~}clasp -n 0}\\
  or alternatively:\\
  \code{\mbox{~}clingo -n 0 \attach{examples/opt.lp}{opt.lp}}}
we find that hotel~\const{4} is not eligible because it implies \pred{noisy}.
Thus, hotel~\const{3} and~\const{5} remain as optimal w.r.t.\ the second most
significant optimization statement in Line~7.
This tie is broken via the least significant optimization statement in Line~6
because hotel~\const{3} has one star more than hotel~\const{5}.
We thus decide to book hotel~\const{3} offering~\const{3} stars
to cost~\const{90} per night.
\eexample
\end{example}


\subsubsection{Meta-Statements}\label{subsec:gringo:meta}
\index{Meta-Statements}

After considering the language of logic programs,
we now introduce features going beyond the contents of a program.

\paragraph{Comments.}
\index{Meta-Statements!Comments}
To annotate the source code of a logic program,
a logic program file may include comments.
A comment until the end of a line is initiated by symbol ``\code{\%},''
and a comment within one or over multiple lines is enclosed
in ``\code{\%*}'' and ``\code{*\%}.''
As an abstract example, consider:
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{logic program}@  %* enclosed comment *%  @\textit{logic program}@
@\textit{logic program}@  % comment till end of line
@\textit{logic program}@
%*
comment over multiple lines
*%
@\textit{logic program}@
\end{lstlisting}

\paragraph{Show Statements.}
\index{Meta-Statements!Show Statements, \code{\#show}}%
Sometimes, one may be interested only in a subset of the atoms belonging
to an answer set.
In order to suppress the atoms of ``irrelevant'' predicates from the output
or even to show arbitrary terms,
the \code{\#show} declarative can be used.
There are three different statements:
%
\par
\medskip
\begin{tabular}{rl}
\textbf{Show atoms:}   & $\code{\#show}~p\code{/}n\code{.}$
\\
\textbf{Show terms:}   & $\code{\#show}~t_0~\code{:}~L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Show nothing:} & \code{\#show.}
\end{tabular}
\par
\medskip
\noindent
%
The first~\code{\#show} statement is the most commonly used form.
Whenever there is at least one statement of this form, all atoms are hidden,
except those over predicates~$p/n$ given by the respective~\code{\#show} statements.
The second form can be used to show arbitrary terms.
The term~$t_0$ is part of the output if the literals in the condition after the~\code{:} hold.
Unlike the previous form,
this statement does not automatically hide all atoms.
To hide all atoms in this case and only show selected terms,
the last statement (mnemonic: show nothing) can be added to suppress all atoms in the output.

\begin{example}
This example depicts the standard use case to selectively show atoms:
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/showa.lp}{showa.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/showa.lp}{showa.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
\lstinputlisting{examples/showa.lp}
Only atoms over $a/0$ and $q/1$ appear in the output here.
\eexample
\end{example}

\begin{example}
This example depicts how to show terms:
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/showt.lp}{showt.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/showt.lp}{showt.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
%
\lstinputlisting{examples/showt.lp}
%
When running this example,
the same output as in the previous example is produced.
This feature is especially handy when applying meta-programming techniques (c.f. Section~\ref{section-yet-to-come})\comment{RK: todo add ref}
where the signatures of the reified atoms are unknown and the \code{holds($\cdot$)} atoms would just clutter the output.
\eexample
\end{example}

\begin{note}
The second form of \code{\#show} statements to show terms may contain variables.
Regarding safety, it behaves similarly to a rule,
where the term $t_0$ takes the role of the head
and the condition after the colon the role of the body.
\index{Logic Programs!Safety}
\end{note}

\paragraph{Const Statements.}
\index{Meta-Statements!Const Statements, \code{\#const}}%
Constants appearing in a logic program may actually be placeholders for
concrete values to be provided by a user.
An example of this is given in Section~\ref{subsec:ex:color}.
Via the \code{\#const} declarative,
one may define a default value to be inserted for a constant.
Such a default value can still be overridden via command line option
\code{--const} (cf.\ Section~\ref{subsec:opt:gringo}).
Syntactically, \code{\#const} must be followed by an assignment having
a (symbolic) constant on the left-hand side and a term without variables, pools, intervals on the right-hand side.

\begin{example}
This example is about using the grounder as a simple calculator:
%
\lstinputlisting{examples/const.lp}
%
Try running this example using the following calls:
\begin{lstlisting}[numbers=none,escapeinside={\$}{\$}]
 gringo --text $\attach{examples/const.lp}{const.lp}$
 gringo --text $\attach{examples/const.lp}{const.lp}$ -c x=6   -c h=6
 gringo --text $\attach{examples/const.lp}{const.lp}$ -c x=6+6 -c y=6
 gringo --text $\attach{examples/const.lp}{const.lp}$ -c x="6+6*6"
\end{lstlisting}
Note that to prevent the shell from expanding the \code{*} in the last call 
or from interpreting parentheses in functions,
quotes have to be added.
\eexample
\end{example}

\paragraph{External Statements.}
\index{Meta-Statements!External Statements, \code{\#external}}%
External statements are used to mark atoms as external.
This means that those atoms are not subject to certain simplifications.
Namely, 
atoms marked external are not removed from the bodies of rules, conditions, etc. 
even if they do not appear in the head of any rule.
Although this does not affect the semantics of a logic program,
we will see an effect in the text output of the example in the following.
Their main use case is to implement extensions to plain ASP solving,
like incremental solving detailed in Section~\ref{subsec:lang:clingo}.
An external statement has the following form:
%
\par
\medskip
\begin{tabular}{l}
$\code{\#external}~A_0~\code{:}~L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\end{tabular}
\par
\medskip
\noindent
%
Here~$A_0$ is an atom over some predicate and
the part beginning with the~\code{:} is a condition.
The condition is instantiated to obtain a set of external atoms.
Note that the condition is discarded after grounding,
hence, it is a good idea to only use domain predicates or built-ins after the colon.%
\footnote{Non-domain predicates are supported too
because in some situations it might be very inconvenient to specify domain predicates.}

\begin{example}
Consider the following example:
%
\marginlabel{%
To inspect the instantiation of externals, invoke:\\
\code{%
\mbox{~}gringo --text \attach{examples/ext.lp}{ext.lp}}\\
or:\\
\code{%
\mbox{~}clingo --text \attach{examples/ext.lp}{ext.lp}}
}
%
\lstinputlisting{examples/ext.lp}
%
The external statement in Line~2 gives rise to three external atoms,
which appear accordingly in the text output.
With these three atoms, 
the rule in Line~4 yields three ground instantiations,
where atoms~\code{q(2)} and~\code{q(3)} appear in the body.
Because we have the fact \code{q(1)} in Line~3,
the atom \code{q(1)} is still subject to simplification
and removed from the body of the respective instantiation of the rule in Line~4.
The idea here is that no matter how \code{q(1)} is supplied externally,
there can never be an answer set that does not contain \code{q(1)}.
\eexample
\end{example}

\begin{note}
External statements that contain variables
have very similar requirements regarding safety as rules.
The atom $A_0$ takes the role of the head
and the condition after the colon the role of the body.
\index{Logic Programs!Safety}
\end{note}

\subsubsection{External Functions}\label{subsec:lang:extfun}
\index{Terms!External Functions}%
\index{External Functions}%
\index{Lua}%
\index{Python}%
\comment{T: Move or grounding only? R: grounding-only fits nicely here!}
Utilizing the scripting languages Lua or Python\footnote{\url{http://lua.org} and \url{http://python.org}},
\gringo's input language can be enriched by arbitrary functions.
We focus on functions that are evaluated during during grounding here.
In Section~\ref{yet-to-come}\comment{TODO},
we show how to take complete control of the grounding and solving process using the scripting API.
We do not give an introduction to Lua or Python here (there are numerous tutorials on the web), 
but give some examples showing the capabilities of this integration.
In the following, we show code snippets for both scripting languages.
Note that our precompiled binaries ship with Lua support and can be used to run the Lua examples.
To enable Python support, \gringo\ and \clingo\ have to be compiled from source (cf. Section~\ref{sec:install}).
\begin{example}\label{ex:gcd}
The first example shows how to add a simple arithmetic function:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.51\textwidth}
\lstinputlisting[language=GringoLua]{examples/gcd-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.51\textwidth}
\lstinputlisting[language=GringoPython]{examples/gcd-py.lp}
\end{minipage}\\
In Line~3 we add a function that calculates the greatest common divisor of two numbers.
Integers from a logic program are directly mapped to their Lua and Python equivalents
and can be returned from the function.
The \code{gcd} function can then be used in a logic program:
\lstinputlisting{examples/gcd.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/gcd-lua.lp}{gcd-lua.lp} \attach{examples/gcd.lp}{gcd.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/gcd-lua.lp}{gcd-py.lp} \attach{examples/gcd.lp}{gcd.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{gcd}/$3$.
Note that external function calls look like function symbols but are preceded by ``\code{@}''. 
\index{External Functions!Calling}%
Regarding binding of variables, the same restrictions as with arithmetic in Section \ref{subsec:gringo:arith} apply.
\end{example}

\begin{example}
This example shows how to return multiple values from a function:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.53\textwidth}
\lstinputlisting[language=GringoLua]{examples/rng-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.49\textwidth}
\lstinputlisting[language=GringoPython]{examples/rng-py.lp}
\end{minipage}\\
In Line~3 we add a function that emulates an interval.
Instead of just returning one number,
this functions returns a table of numbers in Lua and a list of numbers in Python, respectively.
The \code{rng} function can then be used in a logic program:
\lstinputlisting{examples/rng.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/rng-lua.lp}{rng-lua.lp} \attach{examples/rng.lp}{rng.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/rng-lua.lp}{rng-py.lp} \attach{examples/rng.lp}{rng.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{rng}/$3$.
The values in the table or list returned from a call to \code{\@rng(X,Y)} are then successively inserted.
In fact, this function behaves exactly like the interval~\code{X..Y}.
\index{External Functions!Term Insertion}

An interesting use case for returning multiple values is to pull whole 
instances from external sources, like for example a database or some text file not in fact format.
\eexample
\end{example}

As we have seen in the previous example,
numbers are mapped to their Lua and Python equivalents.
The same holds for quoted strings.
To capture constants and functions,
there are the \code{Id} and \code{Fun} classes, respectively, in both Python and Lua.%
\footnote{Strictly speaking there are no classes in Lua, the Userdata data type together with a metatable is used to emulate classes.}
Both objects have a \code{name()} method to access the string representation of the constant and the name of the function, respectively.
A \code{Fun} object has an additional function \code{args()} returning the table of arguments and list of arguments in Lua and Python, respectively.
In Python, tuples are mapped to Python's tuple data structure.
And because there are no dedicated tuples in Lua, tuple terms are mapped to \code{Fun} objects
that have an empty name in Lua.
Finally, the terms \code{\#sup} and \code{\#inf} are mapped to the constants \code{Sup} and \code{Inf}.

To construct terms from within the scripting language,
the \code{Id} and \code{Fun} classes have a constructor to create objects (in Lua it is a global function).
To create an object representing a constant, 
there is the \code{Id(name)} constructor,
which  simply takes the string representation of the constant as argument.
Similarly, for functions
there is the \code{Fun(name,args)} constructor,
taking a string representation of the name of the function
together with a sequence or table of terms representing the arguments of the function
as arguments.
Furthermore, there is the global function \code{Tuple(args)} in Lua,
which is a shortcut for \code{Fun("",args)},
to create an object representing a tuple.
The remaining terms,
which have equivalents in the scripting languages,
use the standard constructors or literals available in Lua and Python.

\begin{example}
This example shows how to inspect and create terms:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.57\textwidth}
\lstinputlisting[language=GringoLua]{examples/term-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\lstinputlisting[language=GringoPython]{examples/term-py.lp}
\end{minipage}\\
In Line~5 we add function~\code{g},
which takes a constant and a tuple as arguments,
and returns a function with the name of the constant and the tuple as arguments.
Note the different handling of tuples in Lua and Python.
Whereas in Lua tuples are represented using \code{Fun} objects,
in Python the tuple can directly be passed to the \code{Fun} constructor.
\lstinputlisting{examples/term.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/term-lua.lp}{term-lua.lp} \attach{examples/term.lp}{term.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/term-lua.lp}{term-py.lp} \attach{examples/term.lp}{term.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{g}/$3$.
Using this scheme, 
new terms can be created during grounding
that cannot be constructed by means of plain ASP.
Another interesting application might be string concatenation.
\eexample
\end{example}

The last function of interest here is the \code{cmp(a,b)} function,
which compares two terms \code{a} and \code{b} 
as \gringo's built-in comparison predicates (cf. Section \ref{subsec:gringo:comp}) would do.
It returns a negative integer if \code{a < b}, zero if \code{a = b}, and a positive integer if \code{a > b}.
A complete reference for the Python scripting API is available at: \url{http://potassco.sourceforge.net/gringo.html}

\begin{example}
This example shows how to implement the \code{max} function:
\\[-8pt] % is there a better way to do this?
\begin{minipage}[t]{0.57\textwidth}
\lstinputlisting[language=GringoLua]{examples/cmp-lua.lp}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\lstinputlisting[language=GringoPython]{examples/cmp-py.lp}
\end{minipage}\\
In Line~5 we add function~\code{max},
which takes two terms as arguments
and returns the maximum of both.
We are using the \code{cmp} here to compare terms. 
We cannot use the \code{>} relation here
because it cannot compare objects of different types,
e.g., integers and strings.
\lstinputlisting{examples/cmp.lp}
%
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/cmp-lua.lp}{cmp-lua.lp} \attach{examples/cmp.lp}{cmp.lp}}\\
or:\\
\code{%
\mbox{~}gringo --text \textbackslash\newline\mbox{~}\attach{examples/cmp-lua.lp}{cmp-py.lp} \attach{examples/cmp.lp}{cmp.lp}}
}
%
The function is called in Line~3 and the result stored in predicate \code{max}/$3$.
Note that the maximum of constant \code{a} and integer \code{3} is \code{a}.
\eexample
\end{example}

\begin{note}~
\begin{enumerate}
\item The grounder assumes that all external functions are deterministic.
That is, if a functions is called during grounding multiple times with the same arguments,
then it should always return the same values.
Adding non-deterministic functions can lead to undesired results.
\item If an error occurs during the evaluation of an external function,
then a warning is printed and the current substitution is thrown away.
For example, when calling the~\code{gcd} function in Example~\ref{ex:gcd} with non-integer arguments.
\end{enumerate}
\end{note}

\subsection{Input Language of \clingo}\label{subsec:lang:clingo}
\index{Incremental Grounding}%
\tbf
\subsection{Input Language of \clasp}\label{subsec:lang:clasp}

Solver \clasp~\cite{gekanesc07b} works on logic programs in \smodels\ format~\cite{lparseManual}.
This numerical format, which is not supposed to be human-readable,
is output by \gringo\ and can be piped into \clasp.
Such an invocation of \clasp\ looks as follows:
%
\begin{lstlisting}[numbers=none]
gringo [ options | files ] | clasp [ number | options ]
\end{lstlisting}
%
Note that \code{number} may be provided to specify a maximum number of answer sets
to be computed, where~\code{0} makes \clasp\ compute all answer sets.
This maximum number can also be set via
option \code{--number} or its abbreviation \code{-n}
(cf.\ Section~\ref{subsec:opt:clasp}).
By default, \clasp\ computes one answer set (if it exists).
If a logic program in \smodels\ format has been stored in a \code{file},
it can be redirected into \clasp\ as follows:%
\footnote{%
  The same is achieved by using option \code{--file} or its short form \code{-f}
  (cf.\ Section~\ref{subsec:opt:clasp}).}
%
\begin{lstlisting}[numbers=none]
clasp [ number | options ] < file
\end{lstlisting}
%
Via option \code{--dimacs},
\clasp\ can also be instructed to compute models of a propositional formula
in DIMACS/CNF format~\cite{dimacs}.
If such a formula is contained in \code{file},
then \clasp\ can be invoked in the following way:
%
\begin{lstlisting}[numbers=none]
clasp [ number | options ] --dimacs < file
\end{lstlisting}
%
Finally, \clasp\ may be used as a library, as done within \clingo.
 
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
