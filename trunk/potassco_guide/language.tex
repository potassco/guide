\section{Input Languages}\label{sec:language}

This section provides an overview of the input languages of
grounder \gringo, combined grounder and solver \clingo, 
and of solver \clasp.
The joint input language of \gringo\ and \clingo\ is detailed in
Section~\ref{subsec:lang:gringo}.
It is extended by \clingo\ with a few directives for multi-shot solving in Section~\ref{subsec:lang:clingo}.
Finally, Section~\ref{subsec:lang:clasp} is dedicated to the inputs handled by \clasp.

\subsection{Input Language of \gringo\ and \clingo}\label{subsec:lang:gringo}

The tool \gringo~\cite{gescth07a} is a grounder capable of translating
user-defined logic programs (usually, containing variables) into 
equivalent ground (that is, variable-free) programs.
The output of \gringo\ can be piped into solver \clasp~\cite{gekanesc07a,gekasc09c},
which then computes answer sets.
System \clingo\ internally couples \gringo\ and \clasp, thus,
it takes care of both grounding and solving.
In contrast to \gringo\ outputting ground programs, 
\clingo\ returns answer sets.

Usually, logic programs are specified in one or more (text) files whose names are
% passed via the command line
provided as arguments
in an invocation of either \gringo\ or \clingo.
% We below provide a description of 
In what follows, we describe the 
constructs belonging to the input language of \gringo\ and \clingo.

\subsubsection{Normal Programs and Integrity Constraints}\label{subsec:gringo:normal}
\index{Terms}
\index{Terms!Constants}
\index{Terms!Strings}
\index{Terms!Variables}
\index{Terms!Variables!Anonymous}
\index{Terms!Functions}
\index{Terms!\code{\#supremum}}
\index{Terms!\code{\#infimum}}

\begin{figure}
\vspace*{-19mm}
\railnontermfont{\rmfamily\itshape}%
\railalias{rusc}{\tt\char95}\railterm{rusc}
\railalias{rlsc}{[A-Za-z0-9\tt\char95]}\railterm{rlsc}
\begin{rail}
	term        : simpleterm | function;
	simpleterm  : (integer | constant | string | variable | rusc | '\#supremum' | '\#infimum');
	constant    : (rusc*) '[a-z]' (rlsc*);
	variable    : (rusc*) '[A-Z]' (rlsc*);
	function    : constant '(' term (',' term*) ')';
\end{rail}
\caption{Grammar for Terms.\label{fig:terms}}
\end{figure}

\comment{T: Roland please check and rewrite!}
\comment{T2R: $X'$}
Every (non-propositional) logic program includes \emph{terms},
mainly to specify the arguments of atoms (see below).
The grammar for \gringo's (and \clingo's) terms is shown in Figure~\ref{fig:terms}.
The basic building blocks are simple terms:
\emph{integers}, \emph{constants}, \emph{strings}, and \emph{variables}
as well as the tokens ``\var{\char`\_},'' \const{\#supremum}, and \const{\#infimum}.
An integer is represented by means of an arithmetic expression,
further explained in Section~\ref{subsec:gringo:arith}.
Constants and variables are distinguished by their first letters, 
which are \emph{lowercase} or \emph{uppercase}, respectively,
where leading occurrences of ``\code{\char`\_}'' are allowed
(may be useful to circumvent name clashes).
Furthermore, a string is an arbitrary sequence of characters
enclosed in inverted comma (\code{"$\cdot$"}),
where any occurrences of ``\code{\textbackslash},'' newline, and inverted comma
must be masked via ``\code{\textbackslash\textbackslash},'' ``\code{\textbackslash n},''
and ``\code{\textbackslash"}.''
While a constant or string represents itself,
a variable is a placeholder for \emph{all} variable-free terms
in the language of a logic program.%
\footnote{The set of all terms constructible from the available
          constants and function symbols is called \emph{Herbrand universe}.}
Unlike with a variable name whose recurrences within a rule refer to the same variable,
the token ``\var{\char`\_}'' (not followed by any letter)
stands for an \emph{anonymous variable} that does not recur anywhere. 
(One can view this as if a new variable name is invented on each
 occurrence of ``\var{\char`\_}.'')
In addition, there are the special constants \const{\#supremum} and \const{\#infimum}
representing $+\infty$ and $-\infty$, respectively;
we illustrate their use in Section~\ref{subsec:gringo:aggregate}.
% the largest and the smallest possible values, respectively,
% which behave essentially like constants.
Finally, (uninterpreted) \emph{functions} are complex terms composed of a name (like a constant)
and one or more terms as arguments. % ,
% surrounded by parentheses and separated by comma.
For instance, 
\code{\const{at}(\const{peter},\const{time}(12),X)}
is a function with three arguments:
constant \const{peter}, another function \code{\const{time}(12)}
with an integer argument, and variable~\var{X}.
% symbols which are composed of other terms.
% A term that does not contain any (anonymous) variables is called a ground term.
% More complex terms involving arithmetics and other constructs
% are introduced later on.

Rules of the following forms are admitted in a 
\emph{normal logic program} (with integrity constraints):
\par
\medskip
\begin{tabular}{rl@{}l}\label{eq:normal:rule}
\textbf{Rule:} & $A_0$&~\code{:-}~$L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Fact:} & $A_0$&\code{.}
\\
\textbf{Integrity Constraint:} & &~\code{:-}~$L_1\code{,}\dots\code{,}L_n$\code{.}
\end{tabular}
\index{Logic Programs}
\index{Logic Programs!Rules}%
\index{Logic Programs!Facts}%
\index{Logic Programs!Integrity Constraints}%
\par
\medskip
\noindent
The \emph{head}~$A_0$ of a rule or a fact is an \emph{atom} of the same 
syntactic form as a constant or function.
\index{Logic Programs!Atoms}%
In the \emph{body} of a rule or an integrity constraint,
every $L_j$ for $1\leq j\leq n$ is a \emph{literal} of the form $A$ or $\code{not}~A$,
where $A$ is an atom and
the connective \code{not} denotes default negation.
%\index{Literals}%
\index{Logic Programs!Literals}%
\index{Logic Programs!Literals!Default Negation}%
% The set of literals $\{L_1,\dots,L_n\}$ is called the body of the rule.
% Facts have an empty body.
We say that a literal~$L$ is \emph{positive} if it is an atom,
and \emph{negative} otherwise.
While the head atom~$A_0$ of a fact must unconditionally be true,
the intuitive reading of a rule corresponds to an implication:
if all positive literals in the rule's body are true and all negative
literals are satisfied, then~$A_0$ must be true.
On the other hand, an integrity constraint is a rule of denial,
meaning that the literals in its body must not jointly be satisfied.

In ASP, the intended models of a logic program, i.e.,
sets of variable-free atoms such that all rules
(including facts and integrity constraints)
of the program are satisfied when the atoms in the set are true, 
are such that every true atom has an (acyclic) derivation from the program.
Such models are called \emph{answer sets}.
To get the idea, let us consider some small examples.

\begin{example}\label{ex:as:one}
Consider the following logic program:
%
\begin{lstlisting}[numbers=none]
a :- b.
b :- a.
\end{lstlisting}
%
When \pred{a} and \pred{b} are false, the bodies of both rules are false as well,
so that the rules are satisfied.
Furthermore, there is no (true) atom to be derived,
which shows that the empty set is an answer set. 
On the other hand, if only either \pred{a} or~\pred{b} is true,
the second or the first rule, respectively, is unsatisfied:
the body holds, but not the head.
Hence, an answer set cannot contain \pred{a} or~\pred{b} only.
It remains to investigate the set including both \pred{a} and~\pred{b}.
Although both rules are satisfied, % it is also clear that
\pred{a} and~\pred{b} cannot be derived acyclicly:
\pred{a} relies on~\pred{b}, and vice versa.
That is, the set including both \pred{a} and~\pred{b} is not an answer set. % either.
Hence, the empty set is the only answer set of the logic program.
\eexample
\end{example}

\begin{example}\label{ex:as:two}
For a second example, consider the following logic program:
%
\begin{lstlisting}[numbers=none]
a :- not b.
b :- not a.
\end{lstlisting}
%
Here, the empty set is not a model because both rules are unsatisfied.
However, the sets containing only either~\pred{a} or~\pred{b} are models.
To see that each of them is an answer set,
note that~\pred{a} is derived by the rule \code{\pred{a}\,:-\:not\:\pred{b}.}
if \pred{b} is false;
similarly,
\pred{b} is derived by \code{\pred{b}\,:-\:not\:\pred{a}.}
if \pred{a} is false.
Note that the set including both~\pred{a} and~\pred{b} is not an answer set
because neither atom can be derived if both are assumed to be true:
the bodies of the rules
\code{\pred{a}\,:-\:not\:\pred{b}.} and
\code{\pred{b}\,:-\:not\:\pred{a}.} are false.
Hence, we have that
either~\pred{a} or~\pred{b} belongs to
an answer set of the logic program.
\eexample
\end{example}

\begin{example}\label{ex:as:three}
To illustrate the use of facts and integrity constraints,
let us augment the logic program in Example~\ref{ex:as:two}:
\begin{lstlisting}[numbers=none]
a :- not b.
b :- not a.
c.
:- c, not b.
\end{lstlisting}
Since \code{\pred{c}.} is a fact,
atom \pred{c} must unconditionally be true, i.e.,
it belongs to every model.
In view of this,
the integrity constraint 
\code{:-\:c,\:not\:\pred{b}.}
tells us that \pred{b} must be true as well
in order to prevent its body from being satisfied.
However, this kind of reasoning does not provide us with
a derivation of \pred{b}.
Rather, we still need to make sure that the body
of the rule \code{\pred{b}\,:-\:not\:\pred{a}.} is satisfied,
so that atom~\pred{a} must be false.
Hence, the set containing \pred{b} and~\pred{c}
is the only answer set of the logic program
in Example~\ref{ex:as:three}.
\eexample
\end{example}

In the above examples, 
we used propositional logic programs to exemplify the idea
of an answer set: a model of a logic program such that all its true atoms are 
(acyclicly) derivable.
In practice, logic programs are typically non-propositional, i.e.,
they include schematic rules with variables.
The next example illustrates this.

\begin{example}\label{ex:flies}
Consider a child from south pole watching cartoons,
where it sees a yellow bird that is not a penguin.
The child knows that penguins can definitely not fly (due to small wingspread),
but it is unsure about whether the yellow bird flies.
This knowledge is generalized by
the following schematic rules:
%
\lstinputlisting{examples/fly.lp} %[firstnumber=3]
%
The first rule expresses that it is generally possible that a bird flies,
unless the contrary, subject of the second rule, is the case.
The definite knowledge that penguins cannot fly
is specified by the third rule.

Later on, the child learns that the yellow bird
is a chicken called ``tweety,''
while its favorite penguin is called ``tux.''
The knowledge about these two individuals is
represented by the following facts:
\lstinputlisting[firstnumber=4]{examples/bird.lp}

When we instantiate the variable~\var{X} in the three schematic rules
with \const{tweety} and \const{tux},
we obtain the following ground rules:
%
\lstinputlisting[numbers=none,xrightmargin=-15pt,nolol]{examples/gfly.lp}
%
Further taking into account that \const{tweety} and \const{tux} are known to
be birds, that \const{tux} is a penguin, while \const{tweety} is not, and that
penguins can definitely not fly,
we can simplify the previous ground rules to obtain the following ones:%
\marginlabel{The reader can reproduce these ground rules
             by invoking:\\
             \code{\mbox{~}clingo --text \textbackslash\\
                   \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/fly.lp}{fly.lp}}\\
             or alternatively:\\
             \code{\mbox{~}gringo --text \textbackslash\\
                   \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/fly.lp}{fly.lp}}}
%
\lstinputlisting[numbers=none,nolol]{examples/sfly.lp}
%
Now it becomes apparent that \const{tweety}
may fly or not, while \const{tux} surely does not fly.
Thus, there are two answer sets for the three schematic rules above,
instantiated with \const{tweety} and \const{tux}.%
\marginlabel{To compute both answer sets, 
             invoke:\\
             \code{\mbox{~}clingo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
                   \mbox{~}\attach{examples/fly.lp}{fly.lp} 0}\\
             or alternatively:\\
             \code{\mbox{~}gringo \attach{examples/bird.lp}{bird.lp} \textbackslash\\
                   \mbox{~}\attach{examples/fly.lp}{fly.lp} | clasp 0}}
\eexample
\end{example}

The above example illustrated how variables are used to represent all instances of
rules w.r.t.\ the language of a logic program.
In fact, grounder \gringo\ (or the grounding component of \clingo)
takes care of instantiating variables
such that an equivalent propositional logic program is obtained.
To this end,
rules are required to be \emph{safe}, 
\label{pg:safe}%
\index{Logic Programs!Safeness}%
i.e.,
all variables in a rule must occur in some positive literal
(a literal not preceded by \code{not}) in the body of the rule.%
\footnote{%
The only exception to this are \emph{local} variables, % bound by conditions,
detailed in Section~\ref{subsec:gringo:condition} and~\ref{subsec:gringo:aggregate}.} 
For instance, the first two schematic rules in Example~\ref{ex:flies} 
are safe because they include \code{\pred{bird}(\var{X})} in their positive bodies.
This tells \gringo\ (or the grounding component of \clingo)
that the values to be substituted for~\var{X} are limited to birds.

%If a variable appears positively in some predicate, then we say that this predicate binds the variable.

Up to now, we have introduced terms, facts, (normal) rules, and integrity constraints.
Before we proceed to describe handy extensions to this simple core language,
keep in mind that the role of a rule (or fact) is that an atom in the
head can be derived to be true if the body is satisfied.
Unlike this, an integrity constraint implements a test,
but it cannot be used to derive any atom.
This universal meaning still applies when more sophisticated language constructs,
as described in the following, are used.

% Throughout this section we further extend the predicates that can be used 
% in a rule including comparison predicates (Section \ref{subsec:gringo:comp}) and aggregates (Section \ref{subsec:gringo:aggregate}).
% Furthermore, \gringo{} expects rules to be safe, i.e., \index{Safe Program}
% all variables that appear in a rule have to appear in some positive literal (a literal not preceded by \code{not}) in the body.
% If a variable appears positively in some predicate, then we say that this predicate binds the variable.
%
% Intuitively, the head of a rule has to be true whenever all its body literals are true.
% In ASP every atom needs some derivation, i.e., 
% an atom cannot be true if there is no rule deriving it.
% This implies that only atoms appearing in some head can appear in answer sets.
% Furthermore, derivations%
% \footnote{There are extensions like disjunctions 
% that go beyond simple derivability and also require minimality w.r.t. a reduct. 
% We do not cover the semantics of such constraints in this guide.}%
% have to be acyclic,
% a feature that is important to model reachability.
% As a simple example, consider the program \code{a :- b. b :- a.}
% The only answer set to this program is the empty set.
% Adding either \code{a.} or \code{b.} to the program results in the answer set $\{a,b\}$.
% Finally, note that default negation is ignored when checking for acyclic derivations 
% (we do not need a reason for an atom being false).
% Default negation can be used to express choices, e.g., the program \code{a :- not b. b :- not a.} 
% has the two answer sets $\{a\}$ and $\{b\}$.
% But in practice it is never needed to express choices this way.
% For example in the introductory example in Section~\ref{sec:quickstart} we used a cardinality 
% constraint, which provides a much more readable way to introduce choices.
% %\com{This paragraph contains a lot of information. Could someone help me making it more readable?}
%
% A fact has an empty body and thus its associated head predicate is always true 
% and appears in all answer sets.
% On the other hand, integrity constraints eliminate answer set candidates.
% They are merely tests that discard unwanted answer sets.
% That is, there are no answer sets that satisfy all literals in an integrity constraint.
% Elaborate examples on the usage of facts, rules, and integrity constraints
% are provided in Section~\ref{sec:examples}.

\subsubsection{Classical Negation}\label{subsec:gringo:negation}
\index{Logic Programs!Atoms!Classical Negation}

% In logic programs, 
The connective \code{not} expresses default negation,
i.e., a literal $\code{not}~A$ is assumed to hold unless atom~$A$ is derived to be true.
In contrast, the classical (or strong) negation of an atom~\cite{gellif91a} % proposition
holds only if % the complement of the proposition 
it can be derived.
Classical negation, indicated by symbol ``\code{-},'' is permitted in front of atoms.
That is, if $A$ is an atom, then $\code{-}A$ is 
an atom representing the complement of~$A$.
% Semantically, $\code{-}A$ is simply a new atom,
The semantic relationship between $A$ and~$\code{-}A$
is simply that they 
% with the additional condition that~$A$ and~$\code{-}A$
must not jointly hold.
Hence,
classical negation can be understood as a syntactic feature
allowing us to impose an integrity \code{:-\;$A$,\:-$A$.}
without explicitly writing it in a logic program.
Depending on the logic program at hand,
it may be possible that neither~$A$ nor~$\code{-}A$ is contained in an answer set,
thus representing a state where the truth and the falsity of~$A$ are both unknown.
% Observe that 
% that can be
% implemented via integrity constraints whose effect is to eliminate
% any answer set candidate containing complementary atoms.

\begin{example}\label{ex:flies:neg}
Using classical negation,
we can rewrite the schematic rules in Example~\ref{ex:flies}
in the following way:
% Consider a logic program comprising the following facts:
%
% \lstinputlisting[nolol]{examples/bird.lp}
\lstinputlisting{examples/flycn.lp} % [firstnumber=3]
%
Given the individuals \const{tweety} and \const{tux},
classical negation is reflected by 
the following (implicit) integrity constraints:%
\marginlabel{By invoking:\\
  \code{\mbox{~}clingo --text \textbackslash\\
        \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/flycn.lp}{flycn.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \textbackslash\\
        \mbox{~}\attach{examples/bird.lp}{bird.lp} \attach{examples/flycn.lp}{flycn.lp}}\\
the reader can observe that % \gringo\ indeed produces 
the integrity constraint in Line~4 is indeed part of the grounding.
The second one in Line 5 is not printed;
it becomes obsolete by a static analysis exhibiting that
\const{tux} does surely not fly.}
%
\begin{lstlisting}[firstnumber=4]
:- flies(tweety), -flies(tweety).
:- flies(tux),    -flies(tux).
\end{lstlisting}
There are still two answer sets,
containing \code{-\pred{flies}(\const{tux})} and 
either \code{\pred{flies}(\const{tweety})} or \code{-\pred{flies}(\const{tweety})}.

Now assume that we add the following fact to the program:
\begin{lstlisting}[numbers=none]
flies(tux).
\end{lstlisting}
Then,
\code{\pred{flies}(\const{tux})} must unconditionally be true,
and \code{-\pred{flies}(\const{tux})} is still derived by 
an instance of the third schematic rule.
% There no longer is any answer set for our new program using classical negation.
% In fact, answer set candidates that contain both
Since every answer set candidate containing
both \code{\pred{flies}(\const{tux})} and \code{-\pred{flies}(\const{tux})}
triggers
% \code{\pred{flies}(\const{tux})} and
% \code{\pred{-flies}(\const{tux})} violate 
the (implicit) integrity constraint in Line~5,
there no longer is any answer set.
\eexample
\end{example}

\subsubsection{Disjunction}\label{subsec:gringo:disjunction}
\index{Logic Programs!Disjunction}
\comment{T2R: check!}
\comment{T: meta?}
\tbrc{Expand\dots?}
Disjunctive logic programs permit connective~``\code{;}'' (or ``\code{|}'') between atoms in rule heads.%
\footnote{Note that disjunction in rule heads was not supported by \clasp\ versions before series~4.}
\par
\medskip
\begin{tabular}{rl@{}l}\label{eq:normal:rule}
\textbf{Rule:} & $A_0\text{\code{;}}\dots\text{\code{;}}A_m$&~\code{:-}~$L_1\text{\code{,}}\dots\text{\code{,}}L_n$\code{.}
\\
\textbf{Fact:} & $A_0\text{\code{;}}\dots\text{\code{;}}A_m$&\code{.}
\end{tabular}
\index{Logic Programs}
\index{Logic Programs!Rules!Disjunctive}%
\index{Logic Programs!Facts!Disjunctive}%
\par
\medskip
\noindent
A disjunctive head holds if at least one of its atoms is true.
Answer sets of a disjunctive logic program satisfy a minimality criterion
that we do not detail here
(see~\cite{eitpol06a,gekasc11b} for an implementation methodology in disjunctive ASP).
We only mention that the simple disjunctive program \code{\pred{a}\:|\:\pred{b}.} has two answer sets,
one containing~\pred{a} and another one containing~\pred{b},
while both atoms do not jointly belong to an answer set.
After adding the rules of Example~\ref{ex:as:one}, a single answer set containing both~\pred{a} and~\pred{b} is obtained.
This illustrates that disjunction in ASP in neither strictly exclusive or inclusive but subject to minimization.

In general, the use of disjunction may increase
computational complexity~\cite{eitgot95a}.
% This is why \clingo%
% \footnote{Run as a monolithic system performing both grounding and \emph{solving}.}
% and solvers like 
% \assat~\cite{linzha04a},
% \clasp~\cite{gekanesc07a,gekasc09c},
% \nomorepp~\cite{angelinesc05c},
% \smodels~\cite{siniso02a}, and
% \smodelscc~\cite{warsch04a}
% do not % work on 
% handle disjunctive programs.
% Rather,
% \claspD~\cite{drgegrkakoossc08a},
% \cmodels~\cite{gilima06a,lierler05a}, or
% \gnt~\cite{janisesiyo06a}
% is needed % to be used 
% for solving a disjunctive program.%
% \footnote{% System 
%   \dlv~\cite{dlv03a} also deals with disjunctive programs,
%   but it uses a different syntax than presented here.}
We thus suggest to use ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
instead of disjunction, unless the latter is required for complexity reasons.

\subsubsection{Double Default Negation}\label{subsec:gringo:double}
\index{Logic Programs!Atoms!Default Negation}
\index{Logic Programs!Atoms!Default Negation!Double}

\tbfc{T: How to approach it\dots?}

 $\code{not}~\code{not}~A$

\subsubsection{Built-In Arithmetic Functions}\label{subsec:gringo:arith}
\index{Terms!Integers}
\index{Terms!Arithmetic Functions}
\index{Arithmetic Functions}
\index{Arithmetic Functions!Integers}
\index{Arithmetic Functions!Addition, \code{+}}
\index{Arithmetic Functions!Subtraction, \code{-}}
\index{Arithmetic Functions!Unary Minus, \code{-}}
\index{Arithmetic Functions!Multiplication, \code{*}}
\index{Arithmetic Functions!Division, \code{/}, \code{\#div}}
\index{Arithmetic Functions!Modulo, \code{\textbackslash}, \code{\#mod}}
\index{Arithmetic Functions!Exponentiation, \code{**}, \code{\#pow}}
\index{Arithmetic Functions!Absolute Value, \mbox{\textbar$\cdot$\textbar}, \code{\#abs}}
\index{Arithmetic Functions!Bitwise AND, \code{\&}}
\index{Arithmetic Functions!Bitwise OR, \code{?}}
\index{Arithmetic Functions!Bitwise XOR, \code{\^}}
\index{Arithmetic Functions!Bitwise Complement, \code{\textasciitilde}}

\com{Roland}
Besides integers (constant arithmetic functions),
written as sequences of the digits \code{0}\dots\code{9}
possibly preceded by ``\code{-},''
\gringo\ and \clingo\ support a variety of arithmetic functions that
are evaluated during grounding.
The following symbols are used for these functions:
\code{+} (addition),
\code{-} (subtraction, unary minus),
\code{*} (multiplication),
\code{/} or \code{\#div} (integer division),
\code{\textbackslash} or \code{\#mod} (modulo),
\code{**} or \code{\#pow} (exponentiation),
\code{|$\cdot$|} or \code{\#abs} (absolute value),
\code{\&} (bitwise AND),
\code{?} (bitwise OR),
\code{\^} (bitwise exclusive OR), and
\code{\textasciitilde} (bitwise complement).

\begin{example}\label{ex:arith:fun}
The usage of arithmetic functions is illustrated by the program:%
\marginlabel{%
  The unique answer set of the program,
  obtained after evaluating all arithmetic functions,
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/arithf.lp}{arithf.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/arithf.lp}{arithf.lp}}}
%
\lstinputlisting{examples/arithf.lp}
%
Note that the variables~\var{L} and~\var{R} are instantiated to~\const{7} and~\const{2},
respectively, before arithmetic evaluations.
Consecutive and non-separative (e.g., before ``\code{(}'')
spaces can optionally be dropped,
while spaces after the tokens \code{\#div} and \code{\#mod} are mandatory
if written in infix notation.
In prefix notation, the arguments of \code{\#abs}, \code{\#div}, and \code{\#mod}
must be enclosed in parentheses.
The four bitwise functions apply to signed integers,
using two's complement arithmetic. % of a negative integer.
\eexample
\end{example}

\begin{Note}
An occurrence of a variable in the scope of an arithmetic function
does not count as a positive occurrence in the sense of safeness (cf.\ Page~\pageref{pg:safe}).
E.g., the rule \code{\pred{p}(\var{X})\,:-\:\pred{p}(\var{X}+\const{1}).}
is not considered as safe, but \code{\pred{p}(\var{X}-\const{1})\,:-\:\pred{p}(\var{X}).} is.
(Note that this rule still leads to an infinite grounding
 if there is a fact like \code{\pred{p}(\const{42}).})
% Although, the latter might produce an infinite grounding 
% and \gringo{} not necessarily halts when given such an input.
Indeed, inferring matching values for~\var{X} when given a value for \var{X}+\const{1}
would require equation solving, which is however not performed by
\gringo\ (nor the grounding component of \clingo).
\index{Logic Programs!Safeness}%
\end{Note}

\subsubsection{Built-In Comparison Predicates}\label{subsec:gringo:comp}
\index{Comparison Predicates}
\index{Comparison Predicates!Equality, \code{==}}
\index{Comparison Predicates!Inequality, \code{"!=}}
\index{Comparison Predicates!Less, \code{<}}
\index{Comparison Predicates!Less or Equal, \code{<=}}
\index{Comparison Predicates!Greater, \code{>}}
\index{Comparison Predicates!Greater or Equal, \code{>=}}

\com{Roland}
Grounder \gringo\ and the grounding component of \clingo\ 
feature a total order among variable-free terms.
The following built-in predicates, which are evaluated during grounding, 
enable term comparisons in the bodies of rules and on the right-hand sides of conditions
(detailed in Section~\ref{subsec:gringo:condition}):
\code{==} (equal),
\code{!=} (not equal),
\code{<} (less than),
\code{<=} (less than or equal),
\code{>} (greater than),
\code{>=} (greater than or equal).

\begin{example}\label{ex:arith:pred}
The application of comparison predicates to integers
is illustrated by the following program:%
\marginlabel{%
  The simplified ground program obtained by evaluating built-ins
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/arithc.lp}{arithc.lp}}
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/arithc.lp}{arithc.lp}}}
%
\lstinputlisting{examples/arithc.lp}
%
The last two lines hint at the fact that arithmetic functions are evaluated
before comparison predicates, so that the latter actually compare the
results of arithmetic evaluations.
\eexample
\end{example}

\begin{example}\label{ex:symb:pred}
Comparison predicates can also be applied to constants and functions,
as illustrated by the following program:%
\marginlabel{%
  As above, by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/symbc.lp}{symbc.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/symbc.lp}{symbc.lp}}\\
  one can inspect the simplified ground program
  obtained by evaluating built-ins.}
%
\lstinputlisting{examples/symbc.lp}
%
Integers are compared in the usual way, constants are ordered lexicographically,
and functions both structurally and lexicographically.
% Function symbols are compared first using their arity.
% If the arity differs, then the name of the function symbol is compared lexicographically.
% If again the name differs, then arguments are compared component wise.
Furthermore, all integers are smaller than constants,
which in turn are smaller than functions.
\eexample
%\comment{add \#sup and \#inf?}
\end{example}

\begin{Note}
As with arithmetic functions,
an occurrence of a variable in the scope of a built-in comparison predicate
does not count as a positive occurrence in the sense of safeness (cf.\ Page~\pageref{pg:safe}),
i.e.,
% variables in  a built-in comparison predicate cannot bind variables, i.e.,
% when checking whether a rule is safe, 
comparison predicates are not considered to be positive.
Also note that comparison predicates must not be preceded by \code{not}:
rather than default negation,
the complementary comparison predicate ought to be used
(e.g., \code{<} and \code{>=} complement one another).
\index{Logic Programs!Safeness}%
\end{Note}

\subsubsection{Assignments}\label{subsec:gringo:assign}
\index{Terms!Variables!Assignments}
\index{Assignments}
\index{Assignments!Variable Assignment, \code{=}}
\index{Assignments!Variable Unification, \code{:=}}

\com{Roland}
Sometimes, it is desirable to define the value of a variable relative
to a term, and to then reuse the variable as a shorthand.
The built-in predicates~\code{=} and~\code{:=} admit unifying
variables on their left-hand sides with terms on their right-hand sides
in the bodies of rules and on the right-hand sides of conditions
(detailed in Section~\ref{subsec:gringo:condition}).

\begin{example}\label{ex:assign}
The usage of variable assignments is illustrated by the following program:%
\marginlabel{%
  The simplified ground program obtained from assignments
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/assign.lp}{assign.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/assign.lp}{assign.lp}}}
%
\lstinputlisting[lastline=2,belowskip=0pt]{examples/assign.lp}%
\lstinputlisting[firstline=3,aboveskip=0pt,numbers=none,nolol]{examples/assign.lp}
%
The body of the rule in Line~2 contains four variable assignments,
where the right-hand sides directly or indirectly
depend on~\var{X} and~\var{Y}.
The values of~\var{X} and~\var{Y} are obtained via atoms of the predicate \pred{num}/$1$.
Also observe the different usage and role of built-in comparison predicate~\code{==}.
\eexample
\end{example}

\begin{example}\label{ex:unify}
The usage of \code{:=},
which allows for terms on its left-hand side,
is illustrated by the following program:
\marginlabel{%
  The simplified ground program obtained from unifications
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/unify.lp}{unify.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/unify.lp}{unify.lp}}}
%
\lstinputlisting{examples/unify.lp}
%
Here, \code{\const{f}(\const{a},\var{X},\var{X}+\const{1})} or
\code{(\const{a},\var{X},\var{X}+\const{1})}, respectively,
is unified with instances of the predicate \code{sym}/$1$.
To this end,
arguments of \code{sym}/$1$ with matching arity
are used to instantiate the variable~\var{X} occurring
as the second argument in terms on the left-hand sides of~\code{:=}.
With a value for~\var{X} at hand,
we can further check whether the arithmetic evaluation of~\code{\var{X}+\const{1}},
occurring as the third argument, coincides with the 
corresponding value given on the right-hand side of~\code{:=}.
%
% Note the usage of \code{X+1} in the term.
% \gringo{} does not try to unify any term containing arithmetic 
% but in this example \code{X} occurs also directly as second argument of the argument
% and can thus be unified with.
% The term $X+1$ is merely a test that is deferred and checked later.
% For example, the fourth line is equivalent to:
% \begin{lstlisting}[firstnumber=6]
% unifyf(X) :- f(a,X,Y) := F, sym(F), Y == X + 1.
% \end{lstlisting}%
\eexample
\end{example}

\begin{Note}
A variable assignment (\code{=}) or unification (\code{:=})
must not be preceded by \code{not}.
Unlike with built-in comparison predicates,
it is considered as
a positive (body) literal in the sense of safeness (cf.\ Page~\pageref{pg:safe}),
so that variables occurring on the left-hand side can be instantiated.
However, this only works if assignments or unifications
can be made acyclicly, i.e.,
it must be possible to instantiate the right-hand side
without knowing the values of variables on
the left-hand side.
E.g., the rule \code{\pred{p}(\var{X})\,:-\:\var{X}\:=\:\var{Y},\:\var{Y}\:=\:\var{X}.}
is not accepted by \gringo\ (or the grounding component of \clingo)
because values for~\var{X} rely on values for~\var{Y}, and vice versa.
\index{Logic Programs!Safeness}%
%
% that assignments to some extent can bind variables.
% Of course cyclic assignments cannot bind variables.
% For example the rule  is rejected by \gringo{}.
% Either \code{X} or \code{Y} has to be provided by some positive predicate in this case.
% Additionally, unification is restricted to ground terms on the right hand side of the assignment, 
% that is, all variables on the right hand side have to be bound by some other predicate.
\end{Note}

\subsubsection{Intervals}\label{subsec:gringo:interval}
\index{Terms!Integers!Intervals}
\index{Arithmetic Functions!Integers!Intervals}

\com{Roland}
In Line~1 of Example~\ref{ex:assign},
there are five facts of the form~\code{\pred{num}($k$).}
over consecutive integers~$k$.
For a more compact representation,
\gringo\ and \clingo\ support integer intervals of the form $i$\code{..}$j$.
% , where~$i$ and~$j$ are integers.
Such an interval, representing each integer~$k$ such that $i\leq k\leq j$,
is expanded during grounding.

\begin{example}\label{ex:int}
The usage of integer intervals is illustrated by the following program:
%
\lstinputlisting{examples/int.lp}
%
The facts in Line~1 and~2 are expanded as follows:
%
\begin{lstlisting}[numbers=none]
num(1).    num(2).   num(3).   num(4).   num(5).
top5(5).  top5(6).  top5(7).  top5(8).  top5(9).
\end{lstlisting}
%
By instantiating~\var{X} to~\const{9},
the rule in Line~4 becomes:
%
\begin{lstlisting}[numbers=none]
top5num(1..5,5..9) :- num(5..9), top5(1..5), top(9).
\end{lstlisting}
%
It is expanded to the cross product
$(\code{\const{1}..\const{5}})\times
 (\code{\const{5}..\const{9}})\times
 (\code{\const{5}..\const{9}})\times
 (\code{\const{1}..\const{5}})$
of the four intervals in the rule:
%
\begin{lstlisting}[numbers=none,escapechar=@]
top5num(1,5) :- num(5), top5(1), top(9).
top5num(2,5) :- num(5), top5(1), top(9).
        @\rlap{\vdots}@
top5num(5,5) :- num(5), top5(1), top(9).
top5num(1,6) :- num(5), top5(1), top(9).
top5num(2,6) :- num(5), top5(1), top(9).
        @\rlap{\vdots}@  @\rlap{\vdots}@
top5num(5,9) :- num(5), top5(1), top(9).
top5num(1,5) :- num(6), top5(1), top(9).
top5num(2,5) :- num(6), top5(1), top(9).
        @\rlap{\vdots}@  @\rlap{\vdots}@          @\rlap{\vdots}@
top5num(5,9) :- num(9), top5(1), top(9).
top5num(1,5) :- num(5), top5(2), top(9).
top5num(2,5) :- num(5), top5(2), top(9).
        @\rlap{\vdots}@  @\rlap{\vdots}@          @\rlap{\vdots}@         @\rlap{\vdots}@
top5num(5,9) :- num(9), top5(4), top(9).
top5num(1,5) :- num(5), top5(5), top(9).
top5num(2,5) :- num(5), top5(5), top(9).
        @\rlap{\vdots}@  @\rlap{\vdots}@
top5num(5,9) :- num(5), top5(5), top(9).
top5num(1,5) :- num(6), top5(5), top(9).
top5num(2,5) :- num(6), top5(5), top(9).
        @\rlap{\vdots}@  @\rlap{\vdots}@          @\rlap{\vdots}@
top5num(5,9) :- num(9), top5(5), top(9).
\end{lstlisting}
%
Note that only the rules with
\code{\pred{num}(\const{5})} and
\code{\pred{top5}(\const{5})}%
\marginlabel{%
  The simplified ground program obtained from intervals
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/int.lp}{int.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/int.lp}{int.lp}}}
% \marginlabel{%
%   Again the unique answer set is obtained via call:\\
%   \code{\mbox{~}gringo --text \attach{examples/int.lp}{int.lp}}}
%
in the body actually contribute to the unique answer set
of the program by deriving all atoms 
of the form \code{\pred{top5num}($m$,$n$)}
for $\const{1}\leq m\leq\const{5}$ and $\const{5}\leq n\leq\const{9}$.
\eexample
\end{example}

\begin{Note}
An occurrence of a variable in the specification of the bounds
of an integer interval, like~\var{X} in Line~4 of Example~\ref{ex:int}, 
does not count as a positive occurrence
in the sense of safeness (cf.\ Page~\pageref{pg:safe}).
Hence, such a variable must also have another positive occurrence elsewhere.
\index{Logic Programs!Safeness}%
\end{Note}

\subsubsection{Conditions}\label{subsec:gringo:condition}
\index{Aggregates!Conditions}
\index{Terms!Conditions}

Conditions allow for instantiating variables to
collections of terms within a single rule.
This is particularly useful for encoding conjunctions (or disjunctions) over
arbitrarily many ground atoms as well as for the compact representation of aggregates
(detailed in Section~\ref{subsec:gringo:aggregate}).
The symbol~``\code{:}'' is used to formulate conditions.

\begin{example}\label{ex:cond}
The following program uses conditions in a rule body and in a rule head:
%
\lstinputlisting{examples/cond.lp}
%
We are particularly interested in the rules in Line~5 and~6,
instantiated as follows:%
\marginlabel{%
  The reader can reproduce these ground rules by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/cond.lp}{cond.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/cond.lp}{cond.lp}}}
% %[firstnumber=5]
\begin{lstlisting}[numbers=none]
meet :- available(jane), available(john).
on(mon) ; on(tue) ; on(wed) ; on(thu) ; on(fri) :- meet.
\end{lstlisting}
%
The conjunction in the body of the first ground rule is obtained by replacing~\var{X} in
\code{\pred{available}(\var{X})} with all ground terms~$t$ such that
\code{\pred{person}($t$)} holds, namely, $t=\const{jane}$ and $t=\const{john}$.
Furthermore, the condition in the head of the rule in Line~6 turns into
a disjunction over all ground instances of
\code{\pred{on}(\var{X})} such that~\var{X} is substituted by a term~$t$
for which
\code{\pred{day}($t$)} holds.
That is, conditions in the body and in the head of a rule
are expanded to different basic language constructs.\footnote{%
Recall our suggestion from Section~\ref{subsec:gringo:disjunction}
to use ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
instead of disjunction, unless the latter is required for complexity reasons.
This also means that conditions must 
not be used \emph{outside of aggregates} in rule heads
if disjunction is unintended.}

Composite conditions can also be constructed via~``\code{:},''
as in the additional rules:
%
\lstinputlisting[firstnumber=7]{examples/conds.lp}
%
In Line 10,
\code{\pred{day}(\var{X})} is used to qualify values~$t$ for variable~\var{X},
while the negative literal \code{not\:\pred{weekend}(\var{X})}
eliminates $t=\const{sun}$, and the built-in \code{\var{X}\,!=\:\const{sat}}
discards $t=\const{sat}$.
This leaves us with all workdays~$t$ satisfying the composite condition.
In fact, the literals on the right-hand side of a condition are connected conjunctively via ``\code{,}'', that is,
all of them must hold for ground instances of an atom in front
of the condition.
Thus, the instantiated rule in Line~10 looks as follows:%
\marginlabel{%
  The reader can observe the effect of conditions by invoking:\\
             \code{\mbox{~}clingo --text \textbackslash\\
                   \mbox{~}\attach{examples/cond.lp}{cond.lp} \attach{examples/conds.lp}{conds.lp}}\\
             or alternatively:\\
             \code{\mbox{~}gringo --text \textbackslash\\
                   \mbox{~}\attach{examples/cond.lp}{cond.lp} \attach{examples/conds.lp}{conds.lp}}}
%
\begin{lstlisting}[numbers=none]
workdays :- workday(mon), workday(tue), workday(wed),
            workday(thu), workday(fri).
\end{lstlisting}
%
The atoms in the body of this rule follow from facts, so that
the rule can be simplified to a fact \code{\pred{workdays}.}
(as it is done by \clingo\ and \gringo).
\eexample
\end{example}

\begin{Note}
There are \REW{three} important issues about the usage of conditions:
\begin{enumerate}
\item 
\DELc{All predicates of atoms on the right-hand side of a condition
must be either \emph{domain predicates}~\cite{lparseManual} %\comment{refer to appendix?}
\index{Aggregates!Conditions!Domain Predicates}%
\index{Terms!Conditions!Domain Predicates}%
\label{pg:domain}%
or built-ins (both used in Line~10 of Example~\ref{ex:cond}).
Such predicates are completely evaluated during grounding.
In a logic program, domain predicates can be recognized by observing
that they are neither subject to negative recursion (through \code{not})
nor to disjunction or ``choice constructs'' (detailed in Section~\ref{subsec:gringo:aggregate})
in the head of any rule.
The domain predicates defined in Example~\ref{ex:cond} are:
\pred{person}/$1$, \pred{day}/$1$, \pred{weekend}/$1$, \pred{workday}/$1$, 
and \pred{workdays}/$0$.}{T2R: Anything to replace?}
%
\item Any variable occurring within a condition is considered to be \emph{local},
i.e., 
an occurrence of the variable 
% on the left- or right-hand side of a condition
does not count as a positive occurrence outside the condition
in the sense of safeness (cf.\ Page~\pageref{pg:safe}).
In turn, variables occuring in atoms not subject to any
condition are \emph{global}. 
Each variable within an atom in front of a condition 
\emph{outside of aggregates or in a rule head} 
must be global or have a positive occurrence on the right-hand side of
the condition.
%
\item 
During grounding,
global variables take precedence over local ones, i.e.,
they are instantiated first.
As a consequence, a local variable that occurs also globally is substituted by a term
before a condition is evaluated further.
Hence, the names of local variables must be chosen with care,
making sure that they do not \emph{accidentally} match the names of global variables.
%
\item 
Formally,
an expression of the form
$L$\code{:}$L_1$\code{,\dots,}$L_n$
where $L,L_1,\dots,L_n$ are literals
is called a conditional literal.
\comment{T: More details?}
Logically, $L$ and $L_1,\dots,L_n$ act as head and body,
which gives the conditional literal the flavor of a nested implication
(see~\cite{haliya14a} for details).
\index{Logic Programs!Literals!Conditional}%
\end{enumerate}
\end{Note}

\tbfc{T: ``,'' versus ``;'' in bodies}

\subsubsection{Pooling}\label{subsec:gringo:pool}
\index{Terms!Pooling, \code{;}, \code{;;}}
\index{Logic Programs!Atoms!Pooling, \code{;}, \code{;;}}

\tbrwc{Roland}
The tokens ``\code{;}'' and ``\code{;;}'' admit pooling alternative terms
to be used as arguments of an atom. % for writing rules more compactly.
Atoms written in the form \code{\pred{p}($\dots$,X;Y,$\dots$)}
or \code{\pred{p}($\dots$,X;;Y,$\dots$)} abbreviate multiple options:
\code{\pred{p}($\dots$,X,$\dots$),\linebreak[1]\:\pred{p}($\dots$,Y,$\dots$)} and
\code{\pred{p}($\dots$,X),\linebreak[1]\:\pred{p}(Y,$\dots$)}, respectively.
In the body of a rule (or on the right-hand side of a condition),
pooled arguments are expanded to a conjunction
of the options within the same body (or within the same condition),
while they are expanded to multiple rules (or multiple literals connected via ``\code{,}'')
when occurring in the head of a rule (or in front of a condition).

\begin{example}\label{ex:pool}
The following program makes use of pooling via ``\code{;}'':
%
\lstinputlisting[xrightmargin=-5pt]{examples/pool.lp}
%
Let us consider the following ground instance of the rule in Line~3:
\begin{lstlisting}[numbers=none]
 mix(a;b,1;2) :- sym(a;b), num(1;2), not -mix(1;2,a;b).
\end{lstlisting}
The head atom \code{\pred{mix}(\const{a};\const{b},\const{1};\const{2})} 
represents four options, obtained combinatorially
by choosing either \const{a} or \const{b} as the first
and either \const{1} or \const{2} as the second argument
of an atom of the predicate \pred{mix}/$2$.
All four options are represented by four rules,
one for each of them.
Unlike this,
the pooled arguments in the body are expanded to a conjunction.
Hence, the following expanded rules share the same body but represent
all options for the head atom:%
%
% instantiations of the rule in Line~3 obtained with substitution 
% $\{\var{A}\mapsto\const{a},\linebreak[1]\var{B}\mapsto\const{b},
%    \var{M}\mapsto\const{1},\var{N}\mapsto\const{2}\}$.
% Note that \pred{mix}/$2$ and \pred{-mix}/$2$ each admit four options,
% corresponding to the cross product of $\{\const{a},\const{b}\}$ substituted
% for~\var{A} and~\var{B}, respectively, together with $\{\const{1},\const{2}\}$
% substituted for~\var{M} and~\var{N}.
% While the instances obtained for \pred{mix}/$2$ give rise to four rules,
% the instances for \pred{-mix}/$2$ jointly belong to the body.
% The (repeated) body also contains two instances each of \pred{sym}/$1$ and of \pred{num}/$1$.
% We thus get the rules:%
\marginlabel{%
  The reader can reproduce the (simplified) rules by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/pool.lp}{pool.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/pool.lp}{pool.lp}}}
%
\begin{lstlisting}[numbers=none]
mix(a,1) :- sym(a),sym(b), num(1),num(2), not -mix(1,a),
            not -mix(1,b), not -mix(2,a), not -mix(2,b).
mix(a,2) :- sym(a),sym(b), num(1),num(2), not -mix(1,a),
            not -mix(1,b), not -mix(2,a), not -mix(2,b).
mix(b,1) :- sym(a),sym(b), num(1),num(2), not -mix(1,a),
            not -mix(1,b), not -mix(2,a), not -mix(2,b).
mix(b,2) :- sym(a),sym(b), num(1),num(2), not -mix(1,a),
            not -mix(1,b), not -mix(2,a), not -mix(2,b).
\end{lstlisting}
\eexample
\end{example}

The pooling via ``\code{;}'' in the above example applied to individual 
arguments of an atom.
Alternatively,
multiple options for lists of arguments can be abbreviated
by using ``\code{;;}'' instead.
% This operator does not work on single terms but
% simply lists arguments of predicates.
% The rules for expanding the predicates are the same as for the \code{;} operator.

\begin{example}\label{ex:sep}
The difference between ``\code{;}'' and ``\code{;;}''
is illustrated by the program:%
\marginlabel{%
  The simplified ground program obtained by expanding poolings
  can be inspected by invoking:\\
  \code{\mbox{~}clingo --text \attach{examples/pools.lp}{pools.lp}}\\
  or alternatively:\\
  \code{\mbox{~}gringo --text \attach{examples/pools.lp}{pools.lp}}}
%
\lstinputlisting{examples/pools.lp}
%
The expansions of the rules in Line~2 and~3 are as follows: % into the following:
\begin{lstlisting}[numbers=none]
q(X,Z) :- p(X,Y), p(Y,Z). 
r(X,Z) :- p(X,Y,Z), p(X,Y,Z).
\end{lstlisting}
% \end{lstlisting}%
% and the third line into:
% \begin{lstlisting}[firstnumber=3]
% p(X,Z) :- p(X,Y,Z), p(X,Y,Z).
From the facts \code{\pred{p}(\const{1},\const{2}).} and \code{\pred{p}(\const{2},\const{3}).},
the atom \code{\pred{q}(\const{1},\const{3})} is derived.
On the other hand,
no atom of the predicate~\pred{r}/$2$ is derived because
of the ``wrong'' arity of \code{\pred{p}(\var{X},\var{Y},\var{Z})}.
% Clearly, the first variant is the desired expansion in this case 
% to calculate the transitive closure.
% Both operators have their usages in different scenarios 
% to keep the encoding more compact and readable.
\eexample
\end{example}

Note that pooling via ``\code{;}'' or ``\code{;;}'' is syntactic sugar
that can be used for writing encodings more compactly and thus easier to read.
But please keep the difference between ``\code{;}'' and ``\code{;;}'' in mind
to avoid nasty surprises.


\subsubsection{Aggregates}\label{subsec:gringo:aggregate}
\index{Logic Programs!Atoms!Aggregates}
\index{Aggregates}
\index{Aggregates!Weights}

An aggregate is a function on a set of weights. % ed literals that evaluates to some value. 
In combination with comparisons, we can extract a truth value from an aggregate's evaluation,
thus, obtaining an aggregate atom.
Aggregate atoms come in two variants depending whether they occur in a rule head or body.
Internally, however, all aggregate atoms occuring in rule heads are transformed away,
as detailed in~\cite{siniso02a,gekakasc12a}.

The form of an \emph{aggregate atom} occuring in a rule body is as follows:
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1\prec_1\alpha$?{?$\boldsymbol{t}_1$?:?$\boldsymbol{L}_1$?;?\,\dots\,?;?$\boldsymbol{t}_n$?:?$\boldsymbol{L}_n$?}?$\prec_2 s_2$?
\end{lstlisting}
%
Here, all $\boldsymbol{t}_i$ and $\boldsymbol{L}_i$ are non-empty tuples of terms and literals, respectively
(as introduced in Section~\ref{subsec:gringo:normal}). 
$\alpha$ is the name of some function that is to be applied to the first elements of term tuples associated with literals that hold.
Hence, this first element is usually specified by means of arithmetic functions (cf.\ Section~\ref{subsec:gringo:arith}).
%
Finally, 
the result of applying $\alpha$ is compared by means of the comparison predicates $\prec_1$ and $\prec_2$ 
to the terms $s_1$ and~$s_2$ (usually representing arithmetic functions), respectively.
Note that one of `$s_1\prec_1$' or `$\prec_2 s_2$' (or even both) can be omitted.
%
For instance, 
if both $\prec_1$ and $\prec_2$ are ``\code{<=}'' and each term tuple represents a single weight,
then an aggregate atom holds if the result of $\alpha$ applied to the weights of literals that hold
is in-between $s_1$ and~$s_2$ (see the available shortcuts below).

Whenever a rule head is a (single) aggregate atom, the actually derivable head atoms must be distinguished.
This is done by prepending such literals to the literal tuples:
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1\prec_1\alpha$?{?$\boldsymbol{t}_1$?:?$L_1$?:?$\boldsymbol{L_1}$?;?\,\dots\,?;?$\boldsymbol{t}_n$?:?$L_n$?:?$\boldsymbol{L_n}$?}?$\prec_2 s_2$?
\end{lstlisting}
%
Here, all $L_i$ are symbolic literals as introduced in Section~\ref{subsec:gringo:normal}, while all other entities are as described above.
The second colon in 
\lstinline[escapechar=?]{?$\boldsymbol{t}_i$?:?$L_i$?:?$\boldsymbol{L_i}$?}
is dropped whenever $\boldsymbol{L_i}$ is empty,
yielding 
\lstinline[escapechar=?]{?$\boldsymbol{t}_i$?:?$L_i$?}.

Simplifying shortcuts providing some backward compatibility with previsou versions of \gringo\ are given below.
Unlike with body aggregates, only singular head aggregates are supported.

Currently, \gringo\ and \clingo\ support the aggregates 
\code{\#count}
\index{Aggregates!Count, \code{\#count}}%
(the number of elements), 
\code{\#sum}
\index{Aggregates!Sum, \code{\#sum}}%
(the sum of weights), 
\code{\#sum+}
\index{Aggregates!Sum plus, \code{\#sum+}}%
(the sum of positive weights), 
\code{\#min}
\index{Aggregates!Minimum, \code{\#min}}%
(the minimum weight), and
\code{\#max}
\index{Aggregates!Maximum, \code{\#max}}%
(the maximum weight).
%
Aggregate atoms, as described above, are obtained by writing
either \code{\#count}, \code{\#sum}, , \code{\#sum+}, \code{\#min}, or \code{\#max} for $\alpha$.
%
The \code{\#count} aggregate is similar to \code{\#sum} with all literals' weights being~\const{1}.
Hence, for convenience, the prefixed term can be dropped in \code{\#count} aggregates.

As indicated by the curly brackets, the literals within aggregates are treated as members of a set.
Hence, duplicates are not accounted for twice.
%
For instance, the following aggregate atoms express the same:
\begin{lstlisting}[numbers=none,escapechar=@]
#count {42:a;      t:not b        } = 2@\textnormal{ and}@ 
#count {42:a;42:a; t:not b;t:not b} = 2@\textnormal{.}@  
\end{lstlisting}
That is, if \lstinline{a} holds but not \lstinline{b} both aggregate atoms evaluate to true.
%
Likewise, the literals of other aggregates are understood as sets.
%
As an example,
consider the next two summation aggregates:
\begin{lstlisting}[numbers=none,escapechar=@]
#sum { 3    :cost(1,2,3); 3    :cost(2,3,3) } = 3@\textnormal{ and}@ 
#sum { 3,1,2:cost(1,2,3); 3,2,3:cost(2,3,3) } = 6@\textnormal{.}@
\end{lstlisting}
As done in Section~\ref{subsec:tsp:instance},
an atom like \lstinline{cost(1,2,3)} can be used to represent an arc from node \lstinline{1} to \lstinline{2} with cost \lstinline{3}.
If both \lstinline{cost(1,2,3)} and \lstinline{cost(2,3,3)} hold,
the first sum evaluates to \lstinline{3} while the second yields \lstinline{6}.
The set property makes the first aggregate count edges with the same cost only once,
while the second one accounts for each edge no matter whether they have the same cost or not.
To see this, observe that after evaluating the conditions in each aggregate, the first one reduces to
\lstinline{#sum \{ 3 \}}, while the second results in \lstinline{#sum \{ 3,1,2; 3,2,3 \}}
In other words, associating each cost with its respective arc enforces a multi-set property;
in this way, the same cost can be accounted for several times.

There are some shorthands that can be used in the syntactic representation of aggregates.
%
The expression
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1$?{?$L_1$?:?$\boldsymbol{L_1}$?;?\,\dots\,?;?$L_n$?:?$\boldsymbol{L_n}$?}?$ s_2$?
\end{lstlisting}
%
where all entities are defined as above 
is a shortcut for
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1$? <= #count {1:?$L_1$?:?$\boldsymbol{L_1}$?;?\,\dots\,?;n:?$L_n$?:?$\boldsymbol{L_n}$?} <= ?$s_2$?
\end{lstlisting}
%
if it appears in the head of a rule, and
it is a shortcut for
%
\begin{lstlisting}[numbers=none,escapechar=?]
?$s_1$? <= #count {1:?$L_1$?,?$\boldsymbol{L_1}$?;?\,\dots\,?;n:?$L_n$?,?$\boldsymbol{L_n}$?} <= ?$s_2$?
\end{lstlisting}
%
if it appears in the body of a rule.
%
Note that one (or both) of $s_1$ and $s_2$ can be omitted .
%
As an example,
consider the rule
\begin{lstlisting}[numbers=none]
{ a ; b }.
\end{lstlisting}
In full detail, this is a shortcut for the rule
\begin{lstlisting}[numbers=none]
#count { 1:a ; 2:b }.
\end{lstlisting}
Unlike this,
the integrity constraint
\begin{lstlisting}[numbers=none]
:- { a ; b }.
\end{lstlisting}
stands for
\begin{lstlisting}[numbers=none]
:- #count { 1:a ; 2:b }.
\end{lstlisting}
By allowing the omission of \const{\#sum} and \const{\#count},
so-called 
``weight constraints'' and ``cardinality constraints''~\cite{siniso02a,lparseManual}
can almost be written in their traditional notations (without keyword, yet different separators).


\comc{Further shortcuts?}{T: Omit $\prec$\dots?}

\DEL{
With \code{\#sum}, \code{\#min}, \code{\#max}, and \code{\#avg},
weights of literals can be omitted, in which case \code{1} is used by default
($L_i$\,\code{=}\,\const{1} is equivalent to just $L_i$).
% weight~\const{1} is considered a default,
% so that $L_i\code{=}\const{1}$ can simply be written as $L_i$.
For instance, the following (multi)sets of (weighted) literals are synonyms
when combined with any (admissible) aggregate and bounds:}
\begin{lstlisting}[numbers=none,escapechar=@]
[a=1, not b=1, c=2] @\textnormal{and}@
[a,   not b,   c=2]@\textnormal{.}@
\end{lstlisting}
%
\DEL{Furthermore,
either or both of the bounds~$l$ and~$u$,
applicable to all aggregate atoms but parity,
can be omitted, in which case they are taken to be
(trivially) satisfied, regardless of an aggregate's evaluation.
Finally, the aggregates  \code{\#sum} and \code{\#count} are used by
default for multisets of (weighted) literals in square brackets
and sets of literals in curly brackets, respectively.
For instance, the following aggregate atoms,
one including the keyword \code{\#sum} and
the other omitting it, are synonyms:}
\begin{lstlisting}[numbers=none,escapechar=@]
2 #sum [a, not b, c=2] 3 @\textnormal{and}@
2      [a, not b, c=2] 3@\textnormal{.}@
\end{lstlisting}
\DEL{Likewise, we can optionally omit \code{\#count} in front of curly brackets:}
\begin{lstlisting}[numbers=none,escapechar=@]
1 #count {a, not b} 1 @\textnormal{and}@ 
1        {a, not b} 1@\textnormal{.}@  
\end{lstlisting}
\DEL{By allowing the omission of \const{\#sum} and \const{\#count},
so-called 
``weight constraints'' and ``cardinality constraints''~\cite{siniso02a,lparseManual}
can be written in their traditional notations (without keyword).}

% keyword \const{\#sum} may be omitted, which in a sense makes \const{\#sum} the default
% aggregate operation.
% In fact, the following aggregate atoms are synonyms:
%
% By omitting keyword \const{\#sum}, we obtain the same notation as the one of 
% so-called ``weight constraints''~\cite{siniso02a,lparseManual}, which are actually aggregate atoms
% whose operation is addition.
% \comment{MG: Illustrate \const{\#supremum} and \const{\#infimum}.
%              Also talk about assignments allowed with
%              \code{\#sum}, \code{\#count}, \code{\#min}, and \code{\#max}.}

\DEL{For the aggregates \code{\#sum}, \code{\#min}, \code{\#max}, and \code{\#avg},
all working on multisets of (weighted) literals in square brackets,
it should be taken into account that they behave differently in case of
multiple occurrences of the same literal (regardless of the associated weights).
For instance, the following aggregate atoms are synonyms:}
\begin{lstlisting}[numbers=none,escapechar=@]
2 #sum [a=2] 2 @\textnormal{and}@
2 #sum [a,a] 2@\textnormal{.}@
\end{lstlisting}
\DEL{In fact, we have that $2=1+1$,
i.e., multiple weights for the same literal sum up.
Unlike this, the following pairs of aggregate atoms are
different from one another:}
\begin{lstlisting}[numbers=none,escapechar=@]
2 #min [a=2] 2 @\textnormal{and}@
2 #min [a,a] 2@\textnormal{,}@
2 #max [a=2] 2 @\textnormal{and}@
2 #max [a,a] 2@\textnormal{,}@
2 #avg [a=2] 2 @\textnormal{and}@
2 #avg [a,a] 2@\textnormal{.}@
\end{lstlisting}
\DEL{While $\min\{2\}=\max\{2\}=\frac{2}{1}=2$,
we have that 
$\min\{1,1\}=\max\{1,1\}=\frac{1+1}{2}=1$.
Hence, if atom~\pred{a} holds,
the aggregate atoms where its weight is $2$ hold,
but not the ones where the (default) weight $1$ is taken twice.
That is, whether repetitions of a literal are cumulative or 
subject to annihilation depends on the aggregate being used.}

Having discussed aggregate atoms,
let us note that there is a second way to use aggregates:
the values obtained by evaluating them can be assigned to variables.
To this end, \gringo\ and \clingo\ allow for the aggregates
\code{\#sum}, \code{\#min}, \code{\#max}, and \code{\#count} to
occur on the right-hand sides of assignment predicates~\code{=} and~\code{:=}.
\index{Aggregates!Assignments}%
\index{Assignments!Aggregates}%
For instances, the following rules assign the obtained values to a variable:
\begin{lstlisting}[numbers=none]
sum(X) :- X = #sum   { 2:a; 3:a }.
min(X) :- X = #min   { 2:a; 3:a }.
max(X) :- X = #max   { 2:a; 3:a }.
cnt(X) :- X = #count { 2:a; 3:a }.
\end{lstlisting}
Under the assumption that atom~\pred{a} holds,
the atoms \code{\pred{sum}(\const{5})}, \code{\pred{min}(\const{2})},
\code{\pred{max}(\const{3})}, and \code{\pred{cnt}(\const{2})} are
derived by the above rules.
If~\pred{a} does not hold, we derive 
\comment{T2R: Or \const{\#inf} and \const{\#sup}\dots?}
\code{\pred{sum}(\const{0})}, \code{\pred{min}(\const{\#supremum})},
\code{\pred{max}(\const{\#infimum})}, and \code{\pred{cnt}(\const{0})}.
Here, the special constants \const{\#supremum} and \const{\#infimum}
(introduced in Section~\ref{subsec:gringo:normal}),
obtained by applying \code{\#min} and \code{\#max}, respectively,
to the empty set of weights,
indicate the neutral elements of the aggregates,
$+\infty$ and $-\infty$, respectively.
These constants can also be used as weights subject to 
\code{\#min} and \code{\#max} (in order to exceed any integer bound):
\comment{T2R: Exlpain shortcut\dots?}
\begin{lstlisting}[numbers=none]
bot :-      #min {  #infimum : a } -1000.
top :- 1000 #max { #supremum : a }.
\end{lstlisting}
Assuming that atom~\pred{a} holds,
the atoms~\pred{bot} and~\pred{top} are derived by the above rules
because $-\infty\leq-1000$ and $1000\leq+\infty$.

Although it seems convenient to use assignments of aggregates' values,
this feature should be used with care.
If the (weighted) literals of an aggregate belong to domain predicates
(see Page~\pageref{pg:domain}) or built-ins,
\gringo\ or \clingo\ evaluates the aggregate during grounding, so obtaining
a unique value to be assigned.
\index{Aggregates!Assignments!Domain Predicates}%
\index{Assignments!Aggregates!Domain Predicates}%
Otherwise, if the literals do not belong to domain predicates,
the value of an aggregate is not known during grounding,
in which case \gringo\ or \clingo\ unwraps all possible outcomes of the
aggregate's evaluation.
The latter can lead to a space blow-up, which should be taken into account
if space becomes a bottleneck.

% In particular, if there are multiple occurrences
% $L\code{=}w_1,\dots,L\code{=}w_k$
% of a literal~$L$, in combination with \const{\#min} and \const{\#max},
% it is not the same like having $L\code{=}w_1+\dots+w_k$.
% To see this, note that the program consisting of the facts:
% \begin{lstlisting}[numbers=none]
% 2 #max [a=2].  2 #min [a=2].
% \end{lstlisting}
% has $\{\code{a}\}$ as its unique answer set, while there is no answer set for:
% \begin{lstlisting}[numbers=none]
% 2 #max [a,a].  2 #min [a,a].
% \end{lstlisting}

% If literals ought not to be repeated,
% we can use \const{\#count} instead of \const{\#sum}.
% Syntactically, \const{\#count} requires curly instead of square
% brackets, and there must not be any weights within a \const{\#count} aggregate.
% Regarding semantics,
% % \begin{equation*}%\label{eq:aggregate:atom}
% $(
%   l\,
%   \const{\#count} 
%   \,
%   \code{\char`\{}
%   \,
%   L_1\code{,}
%   \dots\code{,}
%   L_n
%   \,
%   \code{\char`\}}
%   \,
%   u
% )$ 
% %\end{equation*}
% reduces to
% $(
%   l\,
%   \const{sum}
%   \,
%   \code{[}
%   \,
%   L_1\code{=}\const{1}\code{,}
%   \dots\code{,}
%   L_m\code{=}\const{1}
%   \,
%   \code{]}
%   \,
%   u
% )$,
% where $\{L_1,\dots,L_m\}=\{L_i \mid 1\leq i\leq n\}$ is obtained by dropping
% repeated literals.
% Of course, the use of~$l$ and~$u$ is optional also with \const{\#count}.
% As an example, note that the next aggregate atoms express the same:
% \begin{lstlisting}[numbers=none,escapechar=@]
% 1 #sum   [a=1, not b=1]     1  @\textnormal{and}@ 
% 1 #count {a,a, not b,not b} 1@\textnormal{.}@  
% \end{lstlisting}
% Keyword \const{\#count} can be omitted (like \const{\#sum}),
% so that the following are synonyms:
% \begin{lstlisting}[numbers=none,escapechar=@]
% 1 #count {a, not b} 1  @\textnormal{and}@ 
% 1        {a, not b} 1@\textnormal{.}@  
% \end{lstlisting}
% The last notation is similar to the one of so-called
% ``cardinality constraints''~\cite{siniso02a,lparseManual},
% which are aggregate atoms using counting as their operation.

\REW{After considering the syntax and semantics of ground aggregate atoms,
we now turn our attention to non-ground aggregates.
Regarding contained variables, an atom occurring in an aggregate behaves
similar to an atom on the left-hand side of a condition
(cf.\ Section~\ref{subsec:gringo:condition}).
That is, any variable occurring within an aggregate is a priori local,
and it must be bound via a variable of the same name that is global
or that occurs on the right-hand side of a condition
(with the atom containing the variable in front).
As with local variables of conditions, global variables take priority
during grounding, so that the names of local variables must be chosen
with care to avoid accidental clashes.
Beyond conditions (which are more or less the natural construct to use
for instantiating variables within an aggregate),
classical negation (cf.\ Section~\ref{subsec:gringo:negation}),
built-in arithmetic functions (cf.\ Section~\ref{subsec:gringo:arith}),
intervals (cf.\ Section~\ref{subsec:gringo:interval}), and 
pooling (cf.\ Section~\ref{subsec:gringo:pool})
can be incorporated as usual within aggregates,
where intervals and pooling are expanded locally.%
\footnote{%
  Assignments (cf.\ Section~\ref{subsec:gringo:assign}) 
  are permitted on the right-hand sides of conditions only.}
That is, an interval gives rise to multiple literals connected via~``\code{,}''
within the same aggregate.
The same applies to pooling in front of a condition,
while it turns into a composite condition chained by~``\code{:}'' on the right-hand side.
Finally, note that aggregates 
\code{\#sum}, \code{\#count}, \code{\#min}, and \code{\#max}
without bounds are also permitted on the
right-hand sides of assignments, but using this feature is only recommended
for aggregates whose atoms belong to domain predicates because space blow-up
can become a bottleneck otherwise.
The following example, making exhaustive use of aggregates,
nonetheless demonstrates this and other features.}

\begin{example}\label{ex:aggr}
Consider a situation where an informatics student
wants to enroll for a number of courses at the beginning of a new term.
In the university calendar, eight courses are found eligible,
and they are represented by the following facts:
%
\lstinputlisting[xrightmargin=-20pt,lastline=8]{examples/aggr.lp}
%
In an instance of \const{course}/$3$,
the first argument is a number identifying one of the eight courses,
and the third argument provides the course's contact hours per week.
The second argument stands for a subject area:
\const{1} corresponding to ``theoretical informatics,''
\const{2}               to ``practical informatics,''
\const{3}               to ``technical informatics,''
and~\const{4}               to ``applied informatics.''
For instance, atom \code{\const{course}(\const{1},\const{2},\const{5})}
expresses that course~\const{1} accounts for~\const{5} contact hours per week
that may be credited to subject area~\const{2} (``practical informatics'').
Observe that a single course is usually eligible for multiple
subject areas.

After specifying the above facts,
the student starts to provide personal constraints on the courses to enroll.
The first condition is that~\const{3} to~\const{6} courses should be enrolled:
%
\lstinputlisting[nolol,firstline=11,lastline=11,firstnumber=9]{examples/aggr.lp}
%
Instantiating the above \const{\#count} aggregate
yields the following ground rule:%
\marginlabel{%
  The full ground program is obtained by invoking:\\
  \code{\mbox{~}gringo --text \attach{examples/aggr.lp}{aggr.lp}}}
%
\begin{lstlisting}[firstnumber=9,stepnumber=9]
3 <= #count { 1 : enroll(1); 2 : enroll(2);
              3 : enroll(3); 4 : enroll(4); 
              5 : enroll(5); 6 : enroll(6);
              7 : enroll(7); 8 : enroll(8) } <= 6.
\end{lstlisting}
%
Observe that an instance of atom~\code{\const{enroll}(\var{C})} is included for each
instantiation of~\var{C} such that \code{\const{course}(\var{C},\var{S},\var{H})}
holds for some values of~\var{S} and~\var{H}.
Duplicates resulting from distinct values for~\var{S} are removed, thus,
obtaining the above set of ground atoms.
\footnote{Also, note the difference to \lstinline{3 \{  enroll(C) : course(C,_,_) \} 6.} being always false.}

The next constraints of the student regard the subject areas of enrolled courses:
%
\lstinputlisting[nolol,firstline=13,lastline=15,firstnumber=10]{examples/aggr.lp}
%
Each of the three integrity constraints above contains a cardinality constraint.
Recall that aggregates operate on sets and thus duplicates are removed;
hence we use terms tuples to establish a multiset.
Thus, the integrity constraint in Line~10 is instantiated as follows:
%
% \begin{lstlisting}[firstnumber=10,stepnumber=10]
% :- [ enroll(1) = 1, enroll(1) = 1, 
%      enroll(2) = 1, enroll(2) = 1,
%      enroll(3) = 1, enroll(3) = 1,
%      enroll(4) = 1, enroll(4) = 1, enroll(4) = 1,
%      enroll(5) = 1, enroll(5) = 1,
%      enroll(6) = 1, enroll(6) = 1,
%      enroll(7) = 1, enroll(7) = 1, enroll(7) = 1,
%      enroll(8) = 1, enroll(8) = 1 ] 10.
% \end{lstlisting}
\begin{lstlisting}[firstnumber=10,stepnumber=10]
:- 10 >= #count {1,1,5:enroll(1); 1,2,5:enroll(1); 
                 2,1,4:enroll(2); 2,2,4:enroll(2); 
                 3,1,6:enroll(3); 3,3,6:enroll(3); 
                 4,1,3:enroll(4); 4,3,3:enroll(4); 4,4,3:enroll(4); 
                 5,1,4:enroll(5); 5,4,4:enroll(5); 
                 6,2,2:enroll(6); 6,3,2:enroll(6); 
                 7,2,4:enroll(7); 7,3,4:enroll(7); 7,4,4:enroll(7); 
                 8,3,5:enroll(8); 8,4,5:enroll(8) }. 
\end{lstlisting}
%
Note that courses~\const{4} and~\const{7} count three times because
they are eligible for three subject areas, viz., there are three
distinct instantiations for~\var{S} in
\code{\const{course}(\var{4},\var{S},\const{3})} and
\code{\const{course}(\var{7},\var{S},\const{4})}, respectively.
Comparing the above ground instance,
the meaning of the integrity constraint in Line~10 is that the 
number of eligible subject areas over all enrolled courses
must be more than~\const{10}.
Similarly, the integrity constraint in Line~11 expresses the requirement
that at most one course of subject area~\const{2} (``practical informatics'')
is not enrolled,
while Line~12 stipulates that the enrolled courses
amount to less than six nominations of
subject area~\const{3} (``technical informatics'') 
or~\const{4} (``applied informatics'').
\DEL{Also note that, given the facts in Line~1--8,
we could equivalently have used \const{count} rather than \const{sum} in Line~11,
but not in Line~10 and~12.}

The remaining constraints of the student deal with contact hours.
To express them, we first introduce an auxiliary rule and a fact:
%
\lstinputlisting[nolol,firstline=17,lastline=18,firstnumber=13]{examples/aggr.lp}
%
The rule in Line~13 projects instances of \pred{course}/$3$ to
\pred{hours}/$2$, thereby, dropping courses' subject areas.
This is used to not consider the same course multiple times within the following
integrity constraints:
\footnote{Alternatively, we could also use \lstinline{course(C,_,H).}}
%
\lstinputlisting[nolol,firstline=20,lastline=22,firstnumber=15]{examples/aggr.lp}
%
As Line~15 shows,
we may use default negation via ``\code{not}'' in front of aggregate atoms,
and bounds may be specified in terms of variables.
In fact, by instantiating~\var{M} to~\const{20},
we obtain the following ground instance of the integrity constraint in Line~15:
%
\begin{lstlisting}[firstnumber=15,stepnumber=15]
:- not 18 <= #sum { 5,1 : enroll(1); 4,2 : enroll(2);
                    6,3 : enroll(3); 3,4 : enroll(4);
                    4,5 : enroll(5); 2,6 : enroll(6);
                    4,7 : enroll(7); 5,8 : enroll(8) } <= 20.
\end{lstlisting}
%
The above integrity constraint states that the \const{\#sum} of contact hours per week
must lie in-between~\const{18} and~\const{20}.
Note that the \const{\#min} and \const{\#max} aggregates in Line~16 and~17, respectively,
work on the same (multi)set of weighted literals as in Line~15.
While the integrity constraint in Line~16 stipulates that any course to enroll
must include more than~\const{2} contact hours,
the one in Line~17 prohibits enrolling for courses of~\const{6} or more contact hours.
Of course, the last two requirements could also be formulated as follows:
%
\begin{lstlisting}[firstnumber=16]
:- enroll(C), hours(C,H), H <= 2.
:- enroll(C), hours(C,H), H >= 6.
\end{lstlisting}

Finally, the following rules illustrate the use of aggregates within assignments:
%
\lstinputlisting[nolol,firstline=24,lastline=25,firstnumber=18]{examples/aggr.lp}
%
Note that similar aggregates have already been used in Line~9 and~15, respectively.
In Line~9 the keyword \const{\#count} has been omitted for convenience.
Moreover, Line~9 distinguishes eight terms, while Line~18 discerns only five.
More importantly, the usage of aggregates in the last two lines is different from before,
as they now serve to assign an integer to a variable~\var{N}.
In this context, bounds are not permitted, and so none are provided in Line~18 and~19.
The effect of these two lines is that the student can read off the number of
courses to enroll and the amount of contact hours per week from instances of
\pred{courses}/$1$ and \pred{hours}/$1$ belonging to an answer set.%
\marginlabel{%
  To compute the unique answer set of the program, invoke:\\
  \code{\mbox{~}gringo \attach{examples/aggr.lp}{aggr.lp} | \textbackslash\\
        \mbox{~}clasp -n 0}\\
  or alternatively:\\
  \code{\mbox{~}clingo -n 0 \attach{examples/aggr.lp}{aggr.lp}}}
%
In fact, running \clasp\ shows the student that a unique
collection of~\const{5} courses to enroll satisfies all requirements:
the courses~\const{1}, \const{2}, \const{4}, \const{5}, and~\const{7},
amounting to~\const{20} contact hours per week.

As mentioned in Section~\ref{subsec:gringo:condition},
multiple literals may be connected via ``\code{,}'' in order to construct
composite conditions within an aggregate.
In \gringo\ and \clingo~4,
the predicates of such literals must not be domain or built-in anymore.
Furthermore, the usage of non-domain predicates within an aggregate
on the right-hand side of an assignment (like \pred{enroll}/$1$ in Line~18 and~19 above)
is not recommended in general because the space blow-up may be significant.
\eexample
\end{example}

%\com{Should we mention stratifed aggregates that do not necessarily need conditions?}

\subsubsection{Optimization}\label{subsec:gringo:optimize}
\index{Statements!Optimize Statements}

Optimization statements extend the basic question of
whether a set of atoms is an answer set to
whether it is an optimal answer set.
To support this reasoning mode, \gringo\ and \clingo\ adopt the
optimization statements of \lparse~\cite{lparseManual},
indicated via keywords \const{\#maximize} and \const{\#minimize}.
As an optimization statement does not admit a body, any (local) variable
in it must also occur in an atom \REW{(over a domain or built-in predicate)}
on the right-hand side of a condition (cf.\ Section~\ref{subsec:gringo:condition})
within the optimization statement.
As with aggregates, duplicate terms are removed;
additionally, priorities can be associated with each weighted literal.
A (ground) optimize statement has the form: 
\index{Statements!Optimize Statements!\#minimize}%
\index{Statements!Optimize Statements!\#maximize}%
\[
\mathsf{\mu}\,\code{\{}\,\boldsymbol{t}_1:\boldsymbol{L}_1,\dots,\boldsymbol{t}_n:\boldsymbol{L}_n\,\code{\}}
\] 
where $\mathsf{\mu}$ is either \code{\#maximize} or \code{\#minimize}, 
$\boldsymbol{t}_i$ and $\boldsymbol{L}_i$ are non-empty tuples of terms and literals, respectively
(as introduced in Section~\ref{subsec:gringo:normal}).
The first element of each tuple $\boldsymbol{t}_i$ is supposed to be an (integer) weight $w_i$
that may optionally be furnished with an (integer) priority $p_i$ by means of term $w_i@p_i$.

The semantics of an optimization statement is intuitive:
an answer set is \emph{optimal} if the sum of weights
% (using~\const{1} for unsupplied weights)
of literals that hold is maximal or minimal, as required by the statement,
among all answer sets of the given program.
This definition is sufficient if a single optimization statement is specified
along with a logic program.
If different priorities occur in the program, 
then, depending on the type of optimize statement,
answer sets whose sum of weights assigned to higher priorities
is maximized or minimized, respectively.

Note that for compatibility with \lparse, if multiple optimize statements are used, 
default priorities are assigned.
The $n$-th statement gets priority $n$, thus, the later statements have higher priorities.
We suggest that if you want to use more than one optimization statement,
to always specify priorities to make the program more readable and order independent.

\begin{example}\label{ex:opt}
To illustrate optimization, we consider a hotel booking situation
where we want to choose one among five available hotels.
The hotels are identified via numbers assigned in descending order of stars.
Of course, the more stars a hotel has, the more it costs per night.
As an ancillary information, we know that hotel~\const{4} is located
on a main street, which is why we expect its rooms to be noisy.
This knowledge is specified in Line~1--5 of the following program:
%
\lstinputlisting[xrightmargin=-26pt]{examples/opt.lp}
%
Line~6--8 contribute optimization statements in inverse order of significance,
according to which we want to choose the best hotel to book.
The most significant optimization statement in Line~8 states that
avoiding noise is our main priority.
The secondary optimization criterion in Line~7 consists of
minimizing the cost per star.
Finally, the third optimization statement in Line~6 specifies that we want
to maximize the number of stars among hotels that are otherwise indistinguishable.
The optimization statements in Line~6--8 are instantiated as follows:%
\marginlabel{%
  The full ground program is obtained by invoking:\\
  \code{\mbox{~}gringo --text \attach{examples/opt.lp}{opt.lp}}}
%
\begin{lstlisting}[firstnumber=6,breakindent=0pt,escapechar=&]
#maximize { 5@1,1:hotel(1), 4@1,2:hotel(2),&\\&            3@1,3:hotel(3), 3@1,4:hotel(4), 2@1,5:hotel(5) }.
#minimize { 34@2,1:hotel(1), 35@2,2:hotel(2),&\\&            30@2,3:hotel(3), 25@2,4:hotel(4), 30@2,5:hotel(5) }.
#minimize { 1@3:noisy }.
\end{lstlisting}
If we now use \clasp\ or \clingo\ to compute an optimal answer set,%
\marginlabel{%
  To compute the unique optimal answer set, invoke:\\
  \code{\mbox{~}gringo \attach{examples/opt.lp}{opt.lp} | \textbackslash\\
        \mbox{~}clasp -n 0}\\
  or alternatively:\\
  \code{\mbox{~}clingo -n 0 \attach{examples/opt.lp}{opt.lp}}}
we find that hotel~\const{4} is not eligible because it implies \pred{noisy}.
Thus, hotel~\const{3} and~\const{5} remain as optimal w.r.t.\ the second most
significant optimization statement in Line~7.
This tie is broken via the least significant optimization statement in Line~6
because hotel~\const{3} has one star more than hotel~\const{5}.
We thus decide to book hotel~\const{3} offering~\const{3} stars
to cost~\const{90} per night.
\eexample
\end{example}


\subsubsection{Meta-Statements}\label{subsec:gringo:meta}
\index{Meta-Statements}

After considering the language of logic programs,
we now introduce features going beyond the contents of a program.

\paragraph{Comments.}
\index{Meta-Statements!Comments}
To keep records of the contents of a logic program,
a logic program file may include comments.
A comment until the end of a line is initiated by symbol ``\code{\%},''
and a comment within one or over multiple lines is enclosed
in ``\code{\%*}'' and ``\code{*\%}.''
As an abstract example, consider:
%
\begin{lstlisting}[numbers=none,escapechar=@]
@\textit{logic program}@  %* enclosed comment *%  @\textit{logic program}@
@\textit{logic program}@  % comment till end of line
@\textit{logic program}@
%*
comment over multiple lines
*%
@\textit{logic program}@
\end{lstlisting}

\paragraph{Hiding Predicates.}
\index{Meta-Statements!Hiding Predicates, \code{\#show}, \code{\#hide}}%
Sometimes, one may be interested only in a subset of the atoms belonging
to an answer set.
In order to suppress the atoms of ``irrelevant'' predicates from the output,
the \code{\#hide} declarative can be used.
The meanings of the following statements are indicated via accompanying comments:
%
\begin{lstlisting}[numbers=none]
#hide.     % Suppress all atoms in output
#hide p/3. % Suppress all atoms of predicate p/3 in output
#hide p(X,Y) : q(X). % Supress p/3 if the condition holds
\end{lstlisting}
Note that for the conditionals on the right-hand side, 
the same conditions as described in Section \ref{subsec:gringo:condition} apply.

In order to selectively include the atoms of a certain predicate in the output,
one may use the \code{\#show} declarative.
Here are some examples:
%
\begin{lstlisting}[numbers=none]
#show p/3. % Include all atoms of predicate p/3 in output
#show(X,Y) : q(X). % Include p/3 if the condition holds
\end{lstlisting}
%
A typical usage of \code{\#hide} and \code{\#show} is to hide all predicates
via ``\code{\#hide.}'' and to selectively re-add atoms of certain predicates
\code{p/$n$} to the output via ``\code{\#show p/$n$.}''

\paragraph{Constant Replacement.}
\index{Meta-Statements!Constant Replacement, \code{\#const}}%
Constants appearing in a logic program may actually be placeholders for
concrete values to be provided by a user.
An example of this is given in Section~\ref{subsec:ex:color}.
Via the \code{\#const} declarative,
one may define a default value to be inserted for a constant.
Such a default value can still be overridden via command line option
\code{--const} (cf.\ Section~\ref{subsec:opt:gringo}).
Syntactically, \code{\#const} must be followed by an assignment having
a (symbolic) constant on the left-hand side and a term on the right-hand side.
Some exemplary constant declarations are:
%
\begin{lstlisting}[numbers=none]
#const x = 42.
#const y = f(x,h).
\end{lstlisting}

\begin{Note}
that (for efficiency reasons) constant declarations are order dependent.
In the example above \code{x} would be replaced by \code{42}
but when reversing the directives this would no longer be the case.
\end{Note}

\paragraph{Domain Declarations.}
\index{Meta-Statements!Domain Declarations, \code{\#domain}}%
Usually, variable names are local to a rule,
where they must be bound via appropriate atoms.
This locality can be undermined by using
\code{\#domain} declarations 
that globally associate variable names to atoms.
An associated atom is then simply added to the body of a rule in which
such a predefined variable name occurs in.
The following is a made-up example:
%
\begin{lstlisting}[numbers=none]
p(1,1). p(1,2).
#domain p(X,Y).
#domain p(Y,Z).
q(Z,X) :- not p(Z,X).
\end{lstlisting}
%
The above program is a priori not safe because
variables~\var{X} and~\var{Z} are unbound in the last rule.
However, as they belong to \code{\#domain} declarations,
\gringo\ and \clingo\ expand the last rule to:
%
\begin{lstlisting}[numbers=none]
q(Z,X) :- p(X,Y), p(Y,Z), not p(Z,X).
\end{lstlisting}
%
Observe that the resulting program is safe.

\begin{Note}
that we suggest not to use domain statements because 
in ASP it is common to use very short variable names and
using domain statements likely results in name clashes
and undesired behavior.
\end{Note}

\paragraph{Compute Statements.}
\index{Meta-Statements!Compute Statements, \code{\#compute}}%
These statements are artifacts supported for backward compatibility.
Although we strongly recommend to avoid compute statements,
we now describe their syntax.
A compute statement is of the form
``$\const{\#compute}~n \code{\char`\{}\dots\code{\char`\}}\code{.}$''
(the non-negative integer $n$ is optional),
where the ``$\code{\char`\{}\dots\code{\char`\}}$'' part
is similar to a \const{\#count} aggregate.
The meaning is that all literals contained in
``$\code{\char`\{}\dots\code{\char`\}}$'' must hold w.r.t.\ answer sets
that are to be computed,
while~$n$ specifies a number of answer sets to compute.
As \clasp\ and \clingo\ provide command line option
\code{--number} (cf.\ Section~\ref{subsec:opt:clasp})
to specify how many answer sets are to be computed,
they simply ignore~$n$.
Furthermore,
the ``$\code{\char`\{}\dots\code{\char`\}}$'' part can equivalently
be expressed in terms of integrity constraints,
as indicated in the comments provided along with the following example:
%
\begin{lstlisting}[xrightmargin=-20pt,numbers=none]
q(1;2).
{ p(1..5) }.
#compute 0 { p(X) : q(X) }.       % :- 1 { not p(X) : q(X) }.
#compute   { not p(X) : X=4..5 }. % :- 1 { p(X) : X=4..5 }.
\end{lstlisting}

\begin{Note}
that compute statement are not needed in general.
The same behavior can be achieved by using integrity constraints.
In fact, compute statements exist mainly for compatibility reasons with \lparse.
We suggest to not use them.
\end{Note}

\paragraph{External Statements.}
\index{Meta-Statements!External Statements, \code{\#external}}%
External statements are used to mark certain atoms as external. This means 
that those atoms are not subject of simplification and consequently are not removed 
from the logic program. There are two kinds of external directives, 
global and local external statements.

Global external statements have the form \code{\#external predicate/arity.} where 
\code{predicate} refers to the name of a predicate and \code{arity} to the arity of the predicate.
They mark complete predicates irrespective of any arguments as external.
This means that nothing is known about the predicate and hence it cannot be used 
for instantiation.
\begin{example}
Consider the following example:
\begin{lstlisting}[numbers=none]
#external q/1.
p(1). p(2).
r(X) :- q(X), p(X).
\end{lstlisting}
Here, the external predicate \code{q}/$1$ is not used for simplification
of the problem and hence two ground rules (excluding facts) are printed.
\eexample
\end{example}

Local external statements have the form \code{\#external predicate (: conditional)*.} where
\code{predicate} is some non-ground predicate and \code{conditional} some conditional.
In contrast to global external directives, local external statements precisely specify 
which atoms are external and hence can be used for instantiation.
\begin{example}
Again, consider a similar example:
\begin{lstlisting}[numbers=none]
#external q(X) : p(X).
p(1). p(2).
r(X) :- q(X).
\end{lstlisting}
Here, the external predicate \code{q}/$1$ is used to bind variable \code{X}, 
yielding the same rules as in the example above.
\eexample
\end{example}

Furthermore, the \lparse\ output\cite{lparseManual} has been modified to include an additional table 
that stores a list  of all external atoms. For compatibility, this table is only inserted if the 
program actually contains external directives. It contains the respective atom indices terminated
by a zero and is inserted directly after \lparse' compute statement.
\begin{example}
The following listing shows schematic example output of \gringo\ when external statements are used:
\begin{lstlisting}[numbers=none]
  ...
  0
  ...
  0
  B+
  ...
  0
  B-
  ...
  0
  E
  2
  3
  4
  ...
  0
  1
\end{lstlisting}
\eexample
\end{example}

\subsubsection{Integrated Scripting Language}\label{subsec:lang:lua}
\index{Lua}%
\comment{T: Move or grounding only?}
Utilizing the scripting language Lua\footnote{\url{http://www.lua.org}}, 
\gringo's input language can be enriched by arbitrary arithmetical functions and implicit domains,
answer sets can be intercepted and for example inserted into a database, or
interactions between grounding and solving are possible when incrementally solving with \clingo.
We do not give an introduction to Lua here (there are numerous tutorials on the web), 
but give some examples showing the capabilities of this integration.

\begin{example}
The first example shows basic Lua usage:
\lstinputlisting{examples/luaf.lp}
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \attach{examples/luaf.lp}{luaf.lp}}
}%
In Line 3 we add a function that calculates the greatest common divisor of two numbers.
This function is called in Line 20 and the result stored in predicate \code{gcd}/$3$.
Note that Lua function calls look like function symbols but are preceded by ``\code{@}''. 
\index{Terms!Lua Function Call}%
\index{Lua!Function Call}%
Regarding binding of variables, the same restrictions as with arithmetic in Section \ref{subsec:gringo:arith} apply.

In Line 9 we add a function that emulates a range term.
It returns a table containing all numbers in the interval $[\code{a},\code{b}]$.
\index{Lua!Term Insertion}%
The values in this table are then successively inserted for the call \code{\@rng(X,Y)}.
In fact, this function exactly behaves like a range term.
\eexample
\end{example}

\begin{table}[ht]
\centering
\index{Lua!Val Metatable}%
\begin{tabular}{||l|l||}
 \hline 
 \code{Val.NUM}    & Type identifier for \gringo\ numbers.\\
 \hline 
 \code{Val.ID}     & Type identifier for \gringo\ constants.\\
 \hline 
 \code{Val.FUNC}   & Type identifier for function symbols.\\
 \hline 
 \code{Val.STRING} & Type identifier for \gringo\ strings.\\
 \hline 
 \code{Val.SUP}    & Type identifier for \gringo's \code{\#supremum}.\\
 \hline 
 \code{Val.INF}    & Type identifier for \gringo's \code{\#infimum}.\\
 \hline 
 \code{Val.new(type[,value][,args])}  & Creates new ground terms (see Example \ref{ex:lua:values}).\\
 \hline 
 \code{Val.cmp(a,b)}  & Compares two ground \gringo\ terms. \\
 \hline 
 \code{Val.type(a)} & Returns the type of a term. \\
 \hline 
 \code{Val.name(x)} & Returns the name of function symbol or constant \code{x} . \\
 \hline 
 \code{Val.args(f)} & Returns the arguments of function symbol \code{f} \\
 \hline
\end{tabular}
\caption{The Val meta-table.\label{tab:val}}
\end{table}


\begin{example}\label{ex:lua:values}
The second example shows how to create ground terms from within Lua:
\lstinputlisting{examples/luav.lp}
\marginlabel{%
To compute the unique answer set, invoke:\\
\code{%
\mbox{~}gringo --text \attach{examples/luav.lp}{luav.lp}}
}%
Function \code{f} in Line 2 returns a tuple 
whose first member is a string indicating the type of the argument 
and the second reconstructs the value passed to function \code{f}.
Note that in Line 4, 6, 9, 11 and 13 the function \code{Val.new} is called.
Its first argument indicates that a function symbol is to be created and 
the second argument passes the arguments of the function symbol.
We do not give a name for the function symbol,
thus a tuple is created (this is equivalent to passing the empty string as name).
Similarly, \gringo's other in-built ground terms are created.
Finally, note that \gringo\ integers and strings are directly mapped 
to the respective Lua types.
\eexample
\end{example}

\begin{table}[ht]
\index{Lua!Assignment Metatable}%
\centering
\begin{tabular}{||l|p{6cm}||}
 \hline 
 \code{Assignment.begin(n,a)} & Starts iteration over an atom with name~\code{n} with arity~\code{a}. \\
 \hline 
 \code{Assignment.next()}     & Advances to the next atom in the assignment and returns false if there is none. \\
 \hline 
 \code{Assignment.args()}     & The arguments of the current atom. \\
 \hline 
 \code{Assignment.isTrue()}   & The current atom is true. \\
 \hline 
 \code{Assignment.isFalse()}  & The current atom is false. \\
 \hline 
 \code{Assignment.isUndef()}  & The current atom is undefined. \\
 \hline 
 \code{Assignment.level()}    & The decision level on which the current atom has been assigned. \\
 \hline
\end{tabular}
\caption{The Assignment meta-table.\label{tab:assignment}}
\end{table}

\begin{example}
The next example show some advanced usage also accessing \clasp's truth assignment:
\lstinputlisting{examples/sql.lp}
This example creates a database connection using SQLite\footnote{\url{http://www.sqlite.org/}}.
The database connection is created Lines 3-4 using LuaSQL\footnote{\url{http://www.keplerproject.org/luasql/}}.
Initially, a new table \code{test} is created if it does not already exists (Lines 5-7).
There are two functions to access this table.
The first function \code{query} in Line 9 selects everything from the table and 
returns it in form of a Lua table, which is then used in the logic program
to provide new instantiations of~\code{p}/$2$ in Line 42.
The second function \code{insert} is a helper function that expects a predicate name
and then inspects \clingo's possibly partial assignment and
inserts all true atoms into the database.
It makes use of the \code{Assignment} meta-table.
Next, note the three functions
\code{onBeginStep},
\code{onModel}, and
\code{onEndStep} 
in Line 35-37.
The first function is called directly before solving but after preprocessing.
At this point grounded facts are accessible via the \code{Assignment} meta-table (Table \ref{tab:assignment}),
we call \code{insert} to insert all ground instantiation of \code{p}/$2$ into the \code{test} table.
The same is done in the \code{onModel} function whenever a model is found.
At this point \clingo's assignment is total and 
we insert all instantiation of \code{q}/2 into the database that are contained in the answer set.
Finally, in function \code{onEndStep} we print the number of tuples inserted during grounding and after solving.

\marginlabel{%
Try to invoke this program multiple times using:\\
\code{%
\mbox{~}clingo \attach{examples/sql.lp}{sql.lp}}
}
Note that the values from the answer set are inserted into the database.
In fact the output of the program changes when it is consecutively called.
Even more non-determinism can be added by using the option \code{--rand-freq=1.0}
to induce 100 percent random decisions.
%\com{Admittedly, this example is somewhat spacy. Better ideas?}
\eexample
\end{example}

\begin{Note}
	that the binary packages provided via \url{http://potassco.sourceforge.net} ship with built-in Lua and SQLite3 support.
	To enable further databases interfaces,	\gringo\ has to be compiled from source. 
	It can then be configured to use the Lua scripting language provided by the system. 
	Many distributions ship with Lua packages providing access to MySQL, SQLite, PosgreSQL or Oracle databases.
	If you need help, contact us using our mailing list \url{mailto://potassco-announce@lists.sourceforge.net}.
\end{Note}



\subsection{Input Language of \clingo}\label{subsec:lang:clingo}
\index{Incremental Grounding}%
\tbrw
% System \iclingo~\cite{gekakaosscth08a} extends \clingo\ by an
% \emph{incremental} computation mode that incorporates both grounding and solving.
% Hence, its input language includes all constructs described
% in Section~\ref{subsec:lang:gringo}.
% In addition, \iclingo\ deals with statements of the following form:
% %
% \begin{lstlisting}[numbers=none,escapechar=@]
% #base.
% #cumulative @\textit{constant}@.
% #volatile   @\textit{constant}@.
% \end{lstlisting}
% %
% \index{Incremental Grounding!Base Part, \code{\#base}}%
% \index{Meta-Statements!Base Part, \code{\#base}}%
% Via ``\code{\const{\#base}.},''
% the subsequent part of a logic program is declared as static, that is,
% it is processed only once at the beginning of an incremental computation.
% In contrast, ``\code{\const{\#cumulative} \textit{constant}.}''
% and ``\code{\const{\#volatile} \textit{constant}.}'' are used to declare
% a (symbolic) \code{\textit{constant}} as a placeholder for incremental step numbers.
% In the parts of a logic program below a \const{\#cumulative} statement,
% \code{\textit{constant}} is in each step replaced with the current step number,
% and the resulting rules, facts, and integrity constraints are accumulated
% over a whole incremental computation.
% While the replacement of \code{\textit{constant}} is similar,
% a logic program part below a \const{\#volatile} statement is local to steps,
% that is, all rules, facts, and integrity constraints computed in one step
% are dismissed before the next incremental step.
% Note that the type of a logic program part (static, cumulative, or volatile)
% is determined by the last
% \index{Incremental Grounding!Cumulative Part, \code{\#cumulative}}%
% \index{Meta-Statements!Cumulative Part, \code{\#cumulative}}%
% \index{Incremental Grounding!Volatile Part, \code{\#volatile}}%
% \index{Meta-Statements!Volatile Part, \code{\#volatile}}%
% \const{\#base}, \const{\#cumulative}, or \const{\#volatile} statement
% preceding it.

% During an incremental computation, all static program parts are grounded first,
% while cumulative and volatile parts are grounded step-wise,
% replacing \code{\textit{constant}}s with successive step numbers starting from~\const{1}.
% Note that due to \gringo's grounding algorithm,
% rules are not grounded twice using the same substitution of global variables
% (the incremental constant is treated like a global constant here).
% After a grounding step, \clasp\ is usually invoked via an internal interface
% (like with \clingo), and the incremental computation stops after a step
% in which at least one answer set has been found by \clasp.
% This default behavior can be readapted via command line 
% options (cf.\ Section~\ref{subsec:opt:clingo}).
% For obtaining a well-defined incremental computation result,
% it is important that (ground) head atoms within static, cumulative, and volatile program parts
% are distinct from each other, and they must also be different from step to step
% (see~\cite{gekakaosscth08a} for details).
% In Section~\ref{subsec:ex:block},
% we provide a typical example in which these conditions naturally hold.

% \begin{example}
% For now, consider this simple Schur number example:
% \lstinputlisting{examples/inc.lp}
% \marginlabel{%
%   To calculate the Schur number, invoke:\\
%   \code{\mbox{~}iclingo \attach{examples/inc.lp}{inc.lp} \textbackslash\\
%   --istop=UNSAT
%   }\\
%   The solving stops when the largest number has been found.
% }%
% The Schur number~$n$ w.r.t. to a given number~$c$ is the largest integer 
% such that the interval~$[1..n]$ can be partitioned into $c$ sum-free sets.
% A set $S=\{c_1 ,\dots, c_k\}$ is sum-free if for each~$x_i$ and~$x_j$, 
% it holds that~$x_i + x_j \not \in S$.

% In the base part in Line 2 we specify the number of partitions.
% Then, in the cumulative part in Line 4 each fresh integer $k$
% is assigned to exactly one partition.
% In Line 5 we check whether the guessed partition is sum-free.
% Note that we put this check in the cumulative part and incrementally extend it.
% The idea here is to keep as much constraints in the cumulative part
% because \clasp\ applies nogood learning and only information learnt from 
% the cumulative part can be kept among further solving steps;
% all information learnt from the volatile part has to be forgotten.
% Additionally, we use the comparison  \code{X <= Y}, 
% which helps to avoid grounding some redundant rules.
% Furthermore, note that there appears no incremental constant in this rule,
% \gringo's grounding algorithm makes sure that no ground instantiation of this rule 
% is grounded twice just the new slice for the next step is instantiated.
% Finally, we break symmetries in Line 6, i.e.,
% number one is always assigned to partition one, number two to partition two 
% if it is not in partition one, and so on. 

% We use option \code{--istop=UNSAT} to solve as long as 
% \iclingo\ is able to find a solution, i.e., there is a 
% valid partitioning. Once this is no longer possible, the grounding/solving 
% process stops.\eexample
% \end{example}

\subsection{Input Language of \clasp}\label{subsec:lang:clasp}

Solver \clasp~\cite{gekanesc07b} works on logic programs in \lparse's
output format~\cite{lparseManual}.
This numerical format, which is not supposed to be human-readable,
is output by \gringo\ and can be piped into \clasp.
Such an invocation of \clasp\ looks as follows:
%
\begin{lstlisting}[numbers=none]
gringo [ options | filenames ] | clasp [ number | options ]
\end{lstlisting}
%
Note that \code{number} may be provided to specify a maximum number of answer sets
to be computed, where~\code{0} makes \clasp\ compute all answer sets.
This maximum number can also be set via
option \code{--number} or its abbreviation \code{-n}
(cf.\ Section~\ref{subsec:opt:clasp}).
By default, \clasp\ computes one answer set (if it exists).
If a logic program in \lparse's output format has been stored in a \code{file},
it can be redirected into \clasp\ as follows:%
\footnote{%
  The same is achieved by using option \code{--file} or its short form \code{-f}
  (cf.\ Section~\ref{subsec:opt:clasp}).}
%
\begin{lstlisting}[numbers=none]
clasp [ number | options ] < file
\end{lstlisting}
%
Via option \code{--dimacs},
\clasp\ can also be instructed to compute models of a propositional formula
in DIMACS/CNF format~\cite{dimacs}.
If such a formula is contained in \code{file},
then \clasp\ can be invoked in the following way:
%
\begin{lstlisting}[numbers=none]
clasp [ number | options ] --dimacs < file
\end{lstlisting}
%
Finally, \clasp\ may be used as a library, as done within \clingo\ and \iclingo.

Solver \clasp~\cite{gekanesc07b} works on logic programs in \lparse's
output format~\cite{lparseManual}.
This numerical format, which is not supposed to be human-readable,
is output by \gringo\ and can be piped into \clasp.
Such an invocation of \clasp\ looks as follows:
%
\begin{lstlisting}[numbers=none]
gringo [ options | filenames ] | clasp [ number | options ]
\end{lstlisting}
%
Note that \code{number} may be provided to specify a maximum number of answer sets
to be computed, where~\code{0} makes \clasp\ compute all answer sets.
This maximum number can also be set via
option \code{--number} or its abbreviation \code{-n}
(cf.\ Section~\ref{subsec:opt:clasp}).
By default, \clasp\ computes one answer set (if it exists).
If a logic program in \lparse's output format has been stored in a \code{file},
it can be redirected into \clasp\ as follows:%
\footnote{%
  The same is achieved by using option \code{--file} or its short form \code{-f}
  (cf.\ Section~\ref{subsec:opt:clasp}).}
%
\begin{lstlisting}[numbers=none]
clasp [ number | options ] < file
\end{lstlisting}
%
Via option \code{--dimacs},
\clasp\ can also be instructed to compute models of a propositional formula
in DIMACS/CNF format~\cite{dimacs}.
If such a formula is contained in \code{file},
then \clasp\ can be invoked in the following way:
%
\begin{lstlisting}[numbers=none]
clasp [ number | options ] --dimacs < file
\end{lstlisting}
%
Finally, \clasp\ may be used as a library, as done within \clingo\ and \iclingo.
 
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
