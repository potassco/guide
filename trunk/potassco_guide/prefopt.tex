
\section{Optimization and Preference Handling}
\label{sec:prefopt}

\subsection{Multi-objective Optimization}
\label{sec:oprimization}

This section is not yet ready for publishing
and will be included in one of the forthcoming editions of this guide.

Some information on multi-objective optimization
can be obtained at the following references.

\begin{itemize}
\item Optimization \cite{gekakasc11b,gekakasc11c,gekasc11b,ankamasc12a}
\item Video series on \clasp's optimization capacities \url{http://potassco.sourceforge.net/videos.html}
\end{itemize}

\subsection{Preference Handling with \asprin}\label{sec:asprin}
\comment{T2J: Add index statements. \par JR: yes, I will do it when I'm done with the rest :)}
\index{Optimization!Preference Statements}%
\index{Optimization!Optimization Directives}%
\asprin\ provides a general framework for optimizing qualitative and quantitative preferences in ASP.
It allows for computing optimal answer sets of logic programs with preferences.
While \asprin\ comes with a library of predefined preference types 
(\code{subset}, \code{pareto}, etc.),
it is readily extensible by new customized preference types.
For a formal description of \asprin, please consult~\cite{brderosc15a}. 

% \asprin\ source code and precompiled binaries for Linux, Mac and Windows are available  
% at \url{http://cs.uni-potsdam.de/asprin}.

\paragraph{A simple example.} 
\begin{example}
\label{asprin:example1}
Consider the following base program.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/base.lp}{base.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/base.lp}{base.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
% \attach{examples/base.lp}{\code{base.lp}}
%
\lstinputlisting[numbers=none]{examples/base.lp}
%
% The output of the solver looks as follows:
% \begin{lstlisting}[numbers=none]
% ...
% Answer: 1
% m(2) a(1) a(2) b(1) 
% Answer: 2
% m(3) a(5) b(2) b(3) b(4) b(5) 
% Answer: 3
% m(1) a(1) b(1) b(2) b(3) b(4) b(5)
% ...
% \end{lstlisting}
We obtain three answer sets, one with \code{m(1)}, \code{m(2)}, and \code{m(3)}, respectively,
and refer to them as $M_1$, $M_2$, and $M_3$.

We can use \asprin\ to compute the answer sets of the base program that are subset minimal with respect to atoms of predicate $a/1$. 
This can be done with the following preference specification 
(available in \attach{examples/preference1.lp}{\code{preference1.lp}}): 
%
\lstinputlisting{examples/preference1.lp}
%
Line~1 contains a preference statement of name \code{p1} and type \code{subset} that contains a single preference element.
%The body of the preference element has to be formed by domain predicates, here \code{dom(X)}.
Intuitively, the preference statement \code{p1} defines a preference of type \code{subset} over atoms of predicate \code{a/1}. 
Line~2 contains an optimize statement that instructs \asprin\ to compute answer sets that are optimal with respect to \code{p1}. 

\begin{note}
Unlike \gringo's native optimization statements and weak constraints (cf.\ Section~\ref{subsec:gringo:optimize}),
\asprin\ separates the declaration of preferences from the actual optimization directive.
\end{note}

To compute an answer set of the base program that is optimal with respect to \code{p1}, 
an implementation of the preference type \code{subset} must be provided.
This is comprised in \asprin's preference library,
contained in file \code{asprin.lib}.
With it, the computation can be performed by the following command:
%
\marginlabel{\clingo, \asprin\ and the related files \code{asprin.parser}, \code{asprin.py} and \code{asprin.lib}
             ought to be located in some directory
             in the system path.}%
\comment{JR: I will pretty print all these margin boxes if we decide they stay}
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib
\end{lstlisting}
%
This command produces the following output:
%
\begin{lstlisting}[numbers=none]
asprin version 1.0
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND

Models       : 1
  Enumerated : 2

\end{lstlisting}
%
At first, \asprin\ finds the answer set $M_2$ of the base program. 
Then, it looks for an answer set that is preferred to $M_2$ and it finds $M_1$. 
In the last step, \asprin\ looks for an answer set that is preferred to $M_1$,  
and given that none is found the optimality of $M_1$ is established. 
In total, two answer sets were enumerated in the computation of an optimal solution.

We can minimize the extension of predicates \code{a/1} and \code{b/1} with the following preference specification.
%\attach{examples/preference2.lp}{\code{preference2.lp}}: 
%
\lstinputlisting[numbers=none]{examples/preference2.lp}
%
Now, we obtain that $M_2$ is already an optimal answer set: 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference2.lp}{preference2.lp} \ 
  asprin.lib}}
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
OPTIMUM FOUND
\end{lstlisting}
\end{example}

\paragraph{Computing many optimal answer sets.}

In analogy to \clasp\ and \clingo, 
\asprin\ allows for computing $n$ optimal models by adding the number $n$ to the command line;
as well, $0$ is used to compute all optimal models. 

For instance, the command
%
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib 0
\end{lstlisting}
%
results in the output:
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
\end{lstlisting}
%
The computation of the first optimal answer set, $M_1$, is the same as above.
Then, \asprin\ searches for an answer set of the base program that is not worse than $M_1$, 
finds $M_3$, and proves that it is optimal. 
In the last step, \asprin\ looks for some answer set that is not worse than $M_1$ and $M_3$,  
and given that there is none, it terminates. 

Adding the following choice rule 
(via file \attach{examples/c1.lp}{\code{c1.lp}})
%
\lstinputlisting[numbers=none]{examples/c1.lp}
%
to the above optimization process
yields two additional optimal answer sets, both containing \code{c(1)}: 
%
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib}}
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(1) a(1) b(4) b(3) b(5) b(2) b(1) c(1)
OPTIMUM FOUND *
Answer: 4
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
Answer: 5
m(3) a(5) b(4) b(3) b(5) b(2) c(1)
OPTIMUM FOUND *
\end{lstlisting}
%
When \asprin\ looks for an answer set that is not worse than $M_1$,  
it first looks for models that interpret atoms appearing in the preference statements
in the same way as $M_1$. 
In this way,
it finds the second optimal model, that contains $c(1)$, 
and prints it followed by the line `\lstinline{OPTIMUM FOUND *}'.  
Then, it continues searching, finds $M_3$ and the process continues. 

Finally,
we can project optimal models on the atoms in preference statements 
by option \lstinline{--projection}.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib \
  0 --projection}\\
}
This yields only the three optimal answer sets not containing \code{c(1)}.
% \attach{examples/c1.lp}{\code{c1.lp}}:
%
% \begin{lstlisting}[numbers=none]
% Answer: 1
% m(2) a(2) a(1) b(1)
% Answer: 2
% m(1) a(1) b(4) b(3) b(5) b(2) b(1)
% OPTIMUM FOUND
% Answer: 3
% m(3) a(5) b(4) b(3) b(5) b(2)
% OPTIMUM FOUND
% \end{lstlisting}

\paragraph{Syntax.}

\asprin's input language extends the one described in Section~\ref{sec:language} by constructs for expressing qualitative and quantitative preferences.

A \emph{weighted formula} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{t}$?::?$F$?
\end{lstlisting}
where $\boldsymbol{t}$ is a term tuple\comment{T2J: Aren't number constants, too?\par JR: I wanted to refer to Figure \ref{fig:terms}, I rephrase :) and add also constraint on pooling and intervals\ldots}\footnote{%
Term tuples in the current \asprin\ implementation are defined following Figure \ref{fig:terms}, 
except that \emph{terms} cannot contain \emph{functions}, 
and \emph{simpleterms} cannot contain \emph{constants}. 
Moreover, neither intervals (Section \ref{subsec:gringo:interval}) nor pools  (Section \ref{subsec:gringo:pool})
are allowed in weighted formulas. 
These limitations will be removed in future releases. 
By now, as a workaround, these elements can be represented as follows:
in the weighted formula, write a variable (e.g., \code{V}) instead of the prohibited element (e.g., \code{a(X)}),  
and in the body (see below) assign the variable to the element (e.g., \code{V = a(X)}).
}
and $F$ is a either a Boolean formula or a naming atom.
We may drop \code{::} and simply write $F$ whenever $\boldsymbol{t}$ is empty.
Boolean formulas are formed from atoms, possibly preceded by classical negation (`\code{-}'),\comment{T2J: Having both \code{-} and \code{\~} is strange\dots What does this mean\dots?\par JR: Agree it is strange, and I don't like it, but I found no better way. My idea was that giving a different meaning to \code{-} inside the preference statements would
be confusing to the user, so we should use a different symbol for that (and I chose the one used by Theorem Provers). I am happy if you have a better idea :) }
using the logical connectives \code{\~} (negation), \code{\&} (conjunction) and \code{|} (disjunction).
Parentheses can be written as usual,
and when omitted, negation has precedence over conjunction, and conjunction over disjunction.
%
%Otherwise, a 
Naming atoms of form \code{name(s)}
refer to the preference associated with preference statement \code{s} (see below).
%
Examples of weighted formulas are 
`\code{a(X)}', 
`\code{C::edge(X,Y,C)}', 
`\code{W,(X,Y)::\~{}a(W,X) \& b(Y)}', and 
`\code{X::name(p(X))}'. 

If $F_1$, \ldots, $F_n$ are weighted formulas, then
\begin{lstlisting}[numbers=none,escapechar=?]
{?$F_1$?;?$\dots$?;?$F_m$?}
\end{lstlisting}
is a \emph{set of weighted formulas}.  
We may drop the curly braces if $m=1$.

A \emph{preference element} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{F}_1\;$?>?\,\dots\,?>?$\;\boldsymbol{F}_m$? || ?$F$? : ?$B$?
\end{lstlisting}
where each $\boldsymbol{F}_r$ is a set of weighted formulas, 
$F$ is a non-weighted Boolean formula
and $B$ is a rule body where all literals belong to domain predicates
(see Page~\pageref{pg:domain}) or built-ins.
%
We may drop `\code{>}' if $m=1$, 
and `\code{||$\,F$}' and `\code{:$\,B$}' whenever $F$ and/or $B$ are empty, respectively.
%
Intuitively, $r$ gives the rank of the respective set of weighted formulas.
This can be made subject to condition $F$ by using the conditional `\code{||}'.
Preference elements provide a (possible) structure to a set of weighted formulas
by giving a means of conditionalization and a symbolic way of defining pre-orders (in addition to using weights).
%
%Hence
%\code{\{a(X);b(X) \& c(X))\}>d(X)} stands for 
%\code{\{a;neg(b)\}>\{c\} || and(d,neg(d))}. 
%
Examples of preference elements are 
`\code{a(X)}',  
`\code{1::name(p);2::name(q)}', 
`\code{\{a(X);b(X)\} > \{c(X);d(X)\}}',  and
`\code{a(X) > b(X) || c(X) : dom(X)}'.

\begin{note}
Here and below, 
the rule body $B$ is intended \emph{exclusively} to provide instantiations for the variables appearing in the expressions to its left.  
Accordingly, the literals of $B$ must be built-ins or belong to domain predicates of the accompanying logic program.
This ensures that $B$ can be fully evaluated during grounding.
\end{note}

A \emph{preference statement} is of the form
%
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?;?$\dots$?;?${e}_n$?} : ?$B$?.
\end{lstlisting}
%
where \code{s} is a term giving the preference name, 
\code{t} is a ground term providing the preference type, 
and each $e_j$ is a preference element.
The rule body $B$ has the same form and purpose as above.
%
%\begin{note}
That is, the body $B$ of a preference statement is used to instantiate the variables of $s$, $t$ and each $e_i$.

\begin{example}
\label{asprin:example2}
Given the logic program 
\begin{lstlisting}[numbers=none]
dom(1..2).
{ a(X,Y) : dom(X), dom(Y)}.
\end{lstlisting}
the preference statement 
\begin{lstlisting}[numbers=none]
#preference(p(X),subset){ a(X,Y) : dom(Y) } : dom(X).
\end{lstlisting}
stands for the following two ground preference statements:
\begin{lstlisting}[numbers=none]
#preference(p(1),subset){ a(1,1) ; a(1,2) }.
#preference(p(2),subset){ a(2,1) ; a(2,2) }.
\end{lstlisting}
\end{example}
%\end{note}

Preference statements are accompanied by 
\emph{optimization directives} such as
\begin{lstlisting}[numbers=none,escapechar=?]
#optimize(s) : ?$B$?.
\end{lstlisting}
where $B$ is as above, 
telling \asprin\ to restrict its reasoning mode to the preference relation declared by \code{s}.
% 

A \emph{preference specification} is a set of preference statements along with an optimization directive.
\comment{JR: In \asprin\ we allow many optimization directives, 
             but only one ground optimization directive (but we could change this ;)}
% A preference specification 
It is valid, if after grounding the naming dependencies are acyclic and closed
and there is a single optimization directive
(see \cite{brderosc15a} for details).
% A non ground preference specification is valid
% if after grounding it (using the accompanying logic program)
% the resulting ground specification is valid.
Whenever these conditions do not hold, \asprin\ reports an error and stops.

The purpose of such a specification is to define the optimal answer sets of an accompanying logic program,
also called the \emph{base program}.

\begin{example}
Here is %an example of 
a {preference specification} about leisure activities (without base program).
\begin{lstlisting}[escapechar=?]
#preference(costs,less(weight)){ 40::sauna; 70::dive }.
#preference(fun,superset){ sauna; dive; hike; ~bunji }.
#preference(temps,aso){dive>sauna||hot; sauna>dive||~hot}.
#preference(all,pareto){name(costs); name(fun); name(temps)}.

#optimize(all).
\end{lstlisting}
The preference statement in Line~1 represents the preference relation \code{costs} of type \code{less(weight)}.
Intuitively, this relation optimizes the sum of weights of its preference elements, 
viz.\ \code{40::sauna} and \code{70::dive}.
This preference type is very similar to the one used by native minimization directives (cf.\ Section~\ref{subsec:gringo:optimize}).
The preference type \code{superset} provides a set inclusion based relation and the one refereed to as \code{aso}
amounts to answer set optimization as put forward in~\cite{brnitr03a}.
These three basic preference relations are combined according to the \code{pareto} principle in Line~4.
And this combined preference relation is declared subject to optimization in Line~6.
\end{example}
%
%All four preference types are predefined in \asprin's preference library and take different syntactic restrictions of preference elements as arguments.

\paragraph{Preference relations and preference types.}
A ground preference statement declares a 
strict partial order over answer sets\footnote{A strict partial order is a transitive and irreflexive relation.}.
This order is called a \emph{preference relation}.
\begin{example}
The preference statement of Example \ref{asprin:example1} stands for the following ground preference statement:
\begin{lstlisting}[numbers=none]
#preference(p1,subset){ a(1); a(2); a(3) }.
\end{lstlisting}
declaring the preference relation:
\begin{center}
\begin{tabular}{ccl}
$X \succ_{\code{p1}} Y$ & iff & $\{e\in \{\code{a(1)},\code{a(2)},\code{a(3)}\} \mid X\models e\}\subset$ \\ 
                       &      & $\{e\in \{\code{a(1)},\code{a(2)},\code{a(3)}\} \mid Y\models e\}$
\end{tabular}
\end{center}
In Example \ref{asprin:example1}, 
$M_1\succ_{\code{p1}}M_2$ because \code{\{a(1)\}$\subset$\{a(1),a(2),a(3)\}}, 
and $M_3\succ_{\code{p1}}M_1$ given that \code{\{a(2),a(3)\}$\subset$\{a(1),a(2),a(3)\}}, 
but  $M_1\not\succ_{\code{p1}}M_3$ as \code{\{a(1)\}$\not\subset$\{a(2),a(3)\}}. 
\end{example}
We say that an answer set $X$ of a base program $P$ is \emph{optimal} with respect to a preference relation $\succ$
if there is no other answer set $Y$ of $P$ such that $Y \succ X$.
In Example \ref{asprin:example1}, 
%with preference statement \code{p1},
$M_1$ and $M_3$ are optimal,
whereas $M_2$ is not because $M_1 \succ_{\code{p1}} M_2$ and $M_3 \succ_{\code{p1}} M_2$. 
%Given a valid preference specification where all preference statements are admissible, 
\asprin\ computes answer sets of the base program
that are optimal with respect to the preference relation 
defined by the preference statement selected for optimization.
Hence, in the example it produces $M_1$ and $M_3$.

But, how does a preference statement declare a preference relation?
This is achieved by the \emph{preference type}, 
that maps a set $E$ of ground preference elements into a preference relation $\succ_E$.
For example, \code{subset} maps $E=\{e_1\code{;}\ldots\code{;}e_n\}$ into:
\begin{center}
\(
X \succ_E Y \text{ iff } \{e_i\in E\mid X\models e_i\}\subset\{e_i\in E\mid Y\models e_i\}
\)
\end{center}
and when applied to the preference statement \code{p1} in Example \ref{asprin:example1} we obtain $\succ_{\code{p1}}$.
\comment{JR: Fix subindexes of $E$.}

The full generality of preference elements is not always needed.
For example, for \code{subset} we are only interested in preference elements that are Boolean formulas.
For this reason, we specify for each preference type its \emph{domain}, 
i.e., the ground preference elements for which the preference type is well defined.
Hence, the domain of \code{subset} consists of Boolean formulas.
Furthermore, we say that a ground preference statement
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?;?$\dots$?;?${e}_n$?}.
\end{lstlisting}
is \emph{admissible} if every ${e}_i$ belongs to the domain of \code{t}.
If a ground preference statement is not admissible, \asprin\ reports an error and stops. 
\begin{example}
In Example \ref{asprin:example1}, the preference statement \code{p1}  
is admissible because \code{a(1)}, \code{a(2)} and \code{a(3)} are Boolean formulas
and thus belong to the domain of \code{subset}. 
If we added the preference elements \code{1::a(1)} or \code{name(p2)}, 
it would not be admissible any more.
\end{example}

\paragraph{Implementing preference types.}
In \asprin, preference statements are translated into rules.
Let's see first some simple examples.
\begin{example}
Recall the preference statement \code{p1} of Example \ref{asprin:example1}:
%\begin{lstlisting}[numbers=none]
\lstinputlisting[numbers=none,firstline=1,lastline=1]{examples/preference1.lp}
%#preference(p1,subset){ a(X) : dom(X) }.
%\end{lstlisting}
This is translated into: %the rules $F_\code{p1}$:
\begin{lstlisting}
preference(p1,subset).
preference(p1,(1,(X)),1,for(a(X)),()) :- dom(X).
\end{lstlisting}
Line~1 states the name and the type of the preference statement.
Line~2 can be read as follows:
in the preference statement \code{p1}, the first element has variables $\{\code{X}\}$,  
and in the first position of the element there is a Boolean formula \code{a(X)} that has an empty list of weights associated.
%The reification $F_\code{p2}$ of 
The translation of 
\lstinputlisting[numbers=none,firstline=1,lastline=1]{examples/preference2.lp}
replaces \code{p1} with \code{p2} in the previous translation, and adds the rule:
\begin{lstlisting}[numbers=none]
preference(p2,(2,(X)),1,for(b(X)),()) :- dom(X).
\end{lstlisting}
where number \code{2} in \code{(2,(X))} represents that this is the second preference element. 
\end{example}

\begin{example}
The preference statement of Example \ref{asprin:example2}: 
\begin{lstlisting}[numbers=none]
#preference(p(X),subset){ a(X,Y) : dom(Y) } : dom(X).
\end{lstlisting}
is translated into the rules:
\begin{lstlisting}[numbers=none]
preference(p(X),subset) :- dom(X).
preference(p(X),(1,(X,Y)),1,for(a(X,Y)),()) :- dom(Y), dom(X).
\end{lstlisting}
Observe how \code{dom(X)} is appended to both rules. 
\end{example}

In general, a weighted formula \code{$\boldsymbol{t}$::$F$}
occurring in some set
\code{$\boldsymbol{F}_i=$\{$F_1$;$\dots$;$F_m$\}}
of a preference element $e_j$ of the form 
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{F}_1\;$?>?$\,\dots\,$?>?$\;\boldsymbol{F}_n$? || ?$F_0$? : ?$B_j$?
\end{lstlisting}
that belongs to a preference statement \code{s} of the form
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?;?$\dots$?;?${e}_n$?} : ?$B$?.
\end{lstlisting}
is translated into a rule of the form
\begin{lstlisting}[numbers=none,escapechar=?]
preference(s,(?$j$?,?$\boldsymbol{v}$?),?$i$?,for(?$\boldsymbol{t}_F$?),?$\boldsymbol{t}$?) :- ?$B_j$?, ?$B$?.
\end{lstlisting}
where $i$ and $j$ are the indexes of $\boldsymbol{F}_i$ and $e_j$, respectively, 
$\boldsymbol{v}$ is a term tuple containing all the variables appearing in the rule, 
and $\boldsymbol{t}_F$ is a term representing the Boolean formula $F$ 
by using function symbols $\code{\_neg/1}$, $\code{\_and/2}$, and $\code{\_or/2}$ in prefix notation.
For example, 
the formula \code{(\~ a(X) | b(X)) \& c(X)} is translated into \code{\_and(c(X),\_or(\_neg(a(X)),b(X)))}. 
\comment{JR: Change tilde!}
%
For representing the condition $F_0$, $i$ is set to $\code{0}$.
%
A naming atom \code{name(s)} is represented analogously,
except that \code{for($\boldsymbol{r}_F$)} is replaced by \code{name(s)}.
%
The translation of a preference statement of the form mentioned above 
comprises the translation of all the weighted formulas appearing in it
and, in addition, the rule:
\begin{lstlisting}[numbers=none,escapechar=?]
preference(s,t) :- ?$B$?.
\end{lstlisting}

\begin{note}
All the bodies $B_j$ and $B$ consist of domain predicates or built-ins. 
%that can always be fully evaluated by the grounder, 
Hence, after grounding, all the rules generated in the translation become facts.
\end{note}

\begin{example}
...
\end{example}

%Given a preference statement \code{s} and two answer sets $X$ and $Y$,   
%a preference type determines if $X$ is better than $Y$.
%To implement this ``better'' relation using a logic program, 
%we have to allow it to refer to both the preference statement \code{s} and the answer sets $X$ and $Y$.
%This is achieved via a translation to rules that, after grounding, become facts. 


The answer set $X$ is reified with predicate \code{holds/1} into $H_X$.
For example, \code{$X=$\{a(1)\}} becomes \code{$H_X=$\{holds(a(1))\}}, 
and \code{$Z$\{a(2),a(3)\}} becomes \code{\{holds(a(2)),holds(a(3))\}}. 
Similarly, $Y$ is reified with predicate \code{holds'/1}, 
and \code{\{a(1),a(2),a(3)\}} becomes \code{\{holds'(a(1)),holds'(a(2)),holds'(a(3))\}}. 


We use above a preference statement of type \code{subset}, 
but its meaning is a priori unknown to \asprin.
This is given by a preference program, that is, a logic program representing the semantics of the given preference type. 
Preference programs start with a directive
\begin{lstlisting}[numbers=none]
#program preference(type).
\end{lstlisting}
and end at the end of a file, or with the directive
\lstinline{#program base.}
signaling the start of a base program (cf.~Section~\ref{sec:multi}). 

For example, the preference type \code{subset} can be implemented as follows
(\attach{examples/subset.lp}{\code{subset.lp}}).
%
\lstinputlisting[basicstyle=\small\ttfamily,numbers=none]{examples/subset.lp}
%
Consider that we want to compare two answer sets $H$ and $H'$. 
The true atoms in $H$ are represented by facts of predicate \code{holds/1},  and the true atoms in $H'$ are represented by facts of predicate \code{holds'/1}. 
Intuitively, \code{better(P)} is true if $H$ is preferred to $H'$ with respect to a preference statement \code{P} of type \code{subset}. 
More formally, 
\code{better(P)} is true if there is one atom \code{X} of the preference statement that is false in $H$ and true in $H'$, 
and all atoms \code{Y} of the preference statement that are false in $H'$ are also false in $H$.  
\comment{T2J: This is not self-contained! Must \texttt{holds} be implemented? What is required? On what can one rely? etc
\par I am not suggesting to give \texttt{holds} etc here, just fix teh interface ;)}

In addition, 
there is a general integrity constraint enforcing optimization with respect to a given optimization statement
(\attach{examples/basic.lp}{\code{basic.lp}}):
%
\lstinputlisting[numbers=none]{examples/basic.lp}
%
We see that \code{better(P)} must hold whenever \code{P} is optimized. 
Instead of using \asprin's library, \code{asprin.lib}, 
we can now use the preference program, we have just defined:
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% %\attach{examples/subset.lp}{subset.lp}% %\attach{examples/basic.lp}{basic.lp}% 0
\end{lstlisting}
As before, we obtain $M_1$ and $M_3$ as optimal answer sets.
Other new preference types can be easily defined in this way.  
A look at \code{asprin.lib} may give a good starting point. 

\paragraph{\asprin\ library.}
\asprin's preference library implements the following basic preference types:
\begin{itemize}
	\item  \code{subset} and \code{superset}   
	\item  \code{less(cardinality)} and \code{more(cardinality)}   
	\item  \code{less(weight)} and \code{more(weight)}   
	\item  \code{aso}   (Answer Set Optimization, \cite{brnitr03a})   
	\item  \code{poset} (Qualitative Preferences, \cite{rogima10a})  
\end{itemize}

We have already provided the definition of \code{subset}. 
For \code{superset}, \code{less(cardinality)} and \code{more(cardinality)}, their domains are the same as for \code{subset}.
To define their mappings, consider the set of ground preference elements \code{$E=$\{$e_1$;$\ldots$;$e_n$\}}:
\begin{itemize}
\item
\code{superset} maps $E$ to the preference relation
\[
X \succ Y \text{ iff } \{e_i\in E\mid X\models e_i\}\supset\{e_i\in E\mid Y\models e_i\}
\]
\item
\code{less(cardinality)} maps $E$ to the preference relation
\[
X \succ Y \text{ iff } \{e_i\in E\mid X\models e_i\}<\{e_i\in E\mid Y\models e_i\}
\]
\item
\code{more(cardinality)} maps $E$ to the preference relation
\[
X \succ Y \text{ iff } \{e_i\in E\mid X\models e_i\}>\{e_i\in E\mid Y\models e_i\}
\]
\end{itemize}
\comment{JR: Add Example}

Preference types \code{less(weight)} and \code{more(weight)}
are similar to \code{\#minimize} and \code{\#maximize} statements,
but they do not allow priorities and 
instead of applying to literals, they do apply to  Boolean formulas.
Their domain consists of the sets of ground preference elements 
%of the form:
\code{$E=$\{$e_1$;$\ldots$;$e_n$\}} such that every $e_i$ has the form:
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{w}$?,?$\boldsymbol{t}$?::?$F$?
\end{lstlisting}
where $\boldsymbol{w}$ and $\boldsymbol{t}$ are term tuples and $F$ is a Boolean formula. 
To informally describe their mappings, let us
associate every set of ground preference elements $E$ with an aggregate \code{\#sum$E$}, 
%extends the aggregates of Section \ref{subsec:gringo:aggregate} allowing 
handling Boolean formulas in the natural way and 
using the symbol `\code{::}' instead of `\code{:}'.
Then, \code{less(weight)} maps $E$ to the preference relation where $X \succ Y$ holds 
iff the value of \code{\#sum$E$} in $X$ is less than the value of \code{\#sum$E$} in $Y$.
Similarly, \code{more(weight)} maps $E$ to the preference relation such that $X \succ Y$ holds iff
the value of \code{\#sum$E$} in $X$ is greater than the value of \code{\#sum$E$} in $Y$.
\comment{JR: Not quite sure about whether explaining it this way is a good idea\ldots}
\comment{JR: Add Example}


For answer set optimization (\code{aso};~\cite{brnitr03a})
the domain consists of the sets of ground preference elements 
\code{$E=$\{$e_1$;$\ldots$;$e_n$\}} such that every $e_i$ has the form:
\begin{lstlisting}[numbers=none,escapechar=?]
?$F_1\,$?>?$\,\dots\,$?>?$\,F_m$? || ?$B$?.
\end{lstlisting}
where each $F_i$ and $B$ are Boolean formulas.
Preference elements with this form are called \code{aso} rules.  
The semantics of \code{aso} is based on satisfaction degrees for \code{aso} rules. % as in \eqref{eq:aso:rule}.
The satisfaction degree of such a rule $r$ in an answer set $X$, 
written $v_X(r)$, is 
$1$ if $X$ does not satisfy the body $B$, %$X \not\models b$ for some $b\in B$, %\cap\mathcal{A}$ 
%or  if $X \models b$ for some $\naf{b}\in B$, 
or  if $X$ does not satisfy any $F_i$, 
and it is $\min\{k \mid X \text{ satisfies } F_k, 1\leq k\leq n\}$ otherwise.
Then, a set of \code{aso} rules $E$ is mapped to the preference relation defined as follows:
$X \succeq Y$ if for all rules $r \in E$, $v_X(r) \leq v_Y(r)$, 
and $X \succ Y$ if $X \succeq Y$ but $Y \not\succeq X$. 
\comment{JR: Add Example}

In \cite{giumar12a}, qualitative preferences are modeled as a strict partially ordered set
\(
(S,<)
\)
of literals.
The literals in $S$ represent propositions that are preferably satisfied
and the strict partial order $<$ on $S$ gives their relative importance.
%
In \asprin\ this is implemented by preference type \code{poset}, 
that extends the original approach allowing preferences over Boolean formulas.
The domain of \code{poset} consists of the sets $E$ of ground preference elements of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$F$?.
\end{lstlisting}
or 
\begin{lstlisting}[numbers=none,escapechar=?]
?$F > F'$?.
\end{lstlisting}
where $F$ and $F'$ are Boolean formulas.
Given a set of ground preference statements $E$, 
the set $S_E$ is constructed from all Boolean formulas appearing in $E$, 
and the partial order $>_E$ is defined as the transitive closure of the order 
specified by the preference elements of the second type. 
Then, $E$ is mapped to the preference relation where 
$X \succ Y$ holds if 
there exists a formula $F \in S_E$ such that $X \models F$ and $Y \not\models F$, 
and for every formula $F \in S$ such that $Y \models F$ and $X \not\models F$, 
there is a formula
$F'\in S$ such that $F'<F$ and $X \models F'$ but $Y \not\models F'$.
\comment{JR: Add Example}

%As another example,
%we can use the type \code{less(cardinality)} to minimize the cardinality of the atoms of predicate \code{b/1}: 
%%
%\lstinputlisting[numbers=none]{examples/preference3.lp}
%\marginlabel{%
%  To inspect the output, invoke:\\
%  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
%  \attach{examples/preference3.lp}{preference3.lp} \ 
%  asprin.lib}}
%This yields the unique optimal answer set $M_2$.

The library of \asprin\ implements furthermore the following composite preference types~\cite{sonpon06a}: 
\comment{T2J: Fix admissible input (preference elements)}
\begin{itemize}
\item \code{neg}
\item \code{and}
\item \code{pareto}
\item \code{lexico}
\end{itemize}
The domains of \code{and} and \code{pareto} are the sets of ground naming atoms
\begin{lstlisting}[numbers=none,escapechar=?]
name(s)
\end{lstlisting}
whereas for \code{neg} the sets must be singleton, 
and for \code{lexico} every naming atom is attached with a weight $\textbf{w}$: 
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{w}$?::name(s)
\end{lstlisting}
Given a naming atom \code{name(s)}, 
let $\succeq_{\code{s}}$, $\succ_{\code{s}}$, $=_{\code{s}}$, $\prec_{\code{s}}$, $\preceq_{\code{s}}$ be the 
non-strict, strict, equal, and inverse preference relations associated with preference statement $\code{s}$.
Then the mappings for each of the composite preference types are defined as follows:
%Consider the set of ground preference elements \code{$E=$\{$e_1$;$\ldots$;$e_n$\}}:
\begin{itemize}
\item
\code{neg} maps $E=\code{\{name(s)\}}$ to the preference relation
\[
X \succ Y \text{ iff } Y \prec_s X
\]
\item 
\code{and} maps \code{$E=$\{name($s_1$);$\ldots$;name($s_n$)\}} to the preference relation 
\[
X \succ Y \text{ iff } \bigwedge_{\code{name(s)}\in E}(X\succ_\code{s} Y)
\]
\item 
\code{pareto} maps \code{$E=$\{name($s_1$);$\ldots$;name($s_n$)\}} to the preference relation 
\[
X \succ Y \text{ iff } \bigwedge_{\code{name(s)}\in E} (X\succeq_\code{s} Y)\wedge\bigvee_{\code{name(s)}\in E} (X\succ_\code{s} Y)
\]
\item
\code{lexico} maps \code{$E=$\{$w_1$::name($s_1$);$\ldots$;$w_n$::name($s_n$)\}} to the preference relation 
\[
X \succ Y \text{ iff } \bigvee_{\code{w::name(s)}\in E}\!((X\!\succ_\code{s} \!Y)\!\wedge\!\bigwedge_{\code{v::name(s')}\in E,\code{v}<\code{w}}(X =_{\code{s'}} Y)\!)
\] 
\end{itemize} 
\comment{JR: Stopped here}

For example, the following preference specification aggregates the basic preferences \code{p1} and \code{p3}
via a \code{pareto} preference, viz.~\code{p4}: 
%
\lstinputlisting[numbers=none]{examples/preference4.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference4.lp}{preference4.lp} \ 
  asprin.lib}}
%
This results in the optimal answer sets $M_1$, $M_2$ and $M_3$.

Alternatively,
we can aggregate \code{p1} over \code{p3}
via a lexicographic order, \code{p5}:
\lstinputlisting[numbers=none]{examples/preference5.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference5.lp}{preference5.lp} \ 
  asprin.lib}}
In this case, $M_1$ and $M_3$ are the optimal answer sets.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
