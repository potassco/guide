
\section{Optimization and Preference handling}
\label{sec:prefopt}

\subsection{Multi-objective optimization}
\label{sec:oprimization}

This section is not yet ready for publishing
and will be included in one of the forthcoming editions of this guide.

Some information on multi-objective optimization
can be obtained at the following references.

\begin{itemize}
\item Optimization \cite{gekakasc11b,gekakasc11c,gekasc11b,ankamasc12a}
\item Video series on \clasp's optimization capacities \url{http://potassco.sourceforge.net/videos.html}
\end{itemize}

\subsection{Preference Handling with \asprin}\label{sec:asprin}
\comment{T2J: Add index statements. \par JR: yes, I will do it when I'm done with the rest :)}
\index{Optimization!Preference Statements}%
\index{Optimization!Optimization Directives}%
\asprin\ provides a general framework for optimizing qualitative and quantitative preferences in ASP.
It allows for computing optimal answer sets of logic programs with preferences.
While \asprin\ comes with a library of predefined preference types 
(\code{subset}, \code{pareto}, etc.),
it is readily extensible by new customized preference types.
For a formal description of \asprin, please consult~\cite{brderosc15a}. 

% \asprin\ source code and precompiled binaries for Linux, Mac and Windows are available  
% at \url{http://cs.uni-potsdam.de/asprin}.

\paragraph{Syntax.}

\asprin's input language extends the one described in Section~\ref{sec:language} by constructs for expressing qualitative and quantitative preferences.

A \emph{weighted formula} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{t}$?::?$F$?
\end{lstlisting}
where $\boldsymbol{t}$ is a term tuple\comment{T2J: Aren't number constants, too?}\footnote{%
Term tuples in the current \asprin\ implementation cannot contain constants or functions
but this limitation will be removed in future releases. 
By now, as a workaround, constants or functions can be represented as follows:
in the weighted formula, write a variable (e.g., \code{V}) instead of the term tuple (e.g., \code{a(X)}),  
and in the body (see below) assign the variable to the term tuple (e.g., \code{V = a(X)}).
}
and $F$ is a either a Boolean formula or a naming atom.
We may drop \code{::} and simply write $F$ whenever $\boldsymbol{t}$ is empty.
Boolean formulas are formed from atoms, possibly preceded by classical negation (`\code{-}'),\comment{T2J: Having both \code{-} and \code{\~} is strange\dots What does this mean\dots?}
using the logical connectives \code{\~} (negation), \code{\&} (conjunction) and \code{|} (disjunction).
Parentheses can be written as usual,
and when omitted, negation has precedence over conjunction, and conjunction over disjunction.
%
%Otherwise, a 
Naming atoms of form \code{name(s)}
refer to the preference associated with preference statement \code{s} (see below).
%
Examples of weighted formulas are 
`\code{a(X)}', 
`\code{C::edge(X,Y,C)}', 
`\code{W,(X,Y)::\~{}a(W,X) \& b(Y)}', and 
`\code{X::name(p(X))}'. 

If $F_1$, \ldots, $F_n$ are weighted formulas, then
\begin{lstlisting}[numbers=none,escapechar=?]
{?$F_1$?;?$\dots$?;?$F_m$?}
\end{lstlisting}
is a \emph{set of weighted formulas}.  
We may drop the curly braces if $m=1$.

A \emph{preference element} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{F}_1\;$?>?\,\dots\,?>?$\;\boldsymbol{F}_m$? || ?$F$? : ?$B$?
\end{lstlisting}
where each $\boldsymbol{F}_r$ is a set of weighted formulas, 
$F$ is a non-weighted Boolean formula
and $B$ is a rule body where all literals belong to domain predicates
(see Page~\pageref{pg:domain}) or built-ins.
%
We may drop `\code{>}' if $m=1$, 
and `\code{||$\,F$}' and `\code{:$\,B$}' whenever $F$ and/or $B$ are empty, respectively.
%
Intuitively, $r$ gives the rank of the respective set of weighted formulas.
This can be made subject to condition $F$ by using the conditional `\code{||}'.
Preference elements provide a (possible) structure to a set of weighted formulas
by giving a means of conditionalization and a symbolic way of defining pre-orders (in addition to using weights).
%
%Hence
%\code{\{a(X);b(X) \& c(X))\}>d(X)} stands for 
%\code{\{a;neg(b)\}>\{c\} || and(d,neg(d))}. 
%
Examples of preference elements are 
`\code{a(X)}',  
`\code{1::name(p);2::name(q)}', 
`\code{\{a(X);b(X)\} > \{c(X);d(X)\}}',  and
`\code{a(X) > b(X) || c(X) : dom(X)}'.

\begin{note}
Here and below, 
the rule body $B$ is intended \emph{exclusively} to provide instantiations for the variables appearing in the expressions to its left.  
Accordingly, the literals of $B$ must be built-ins or belong to domain predicates of the accompanying logic program.
This ensures that $B$ can be fully evaluated during grounding.
\end{note}

A \emph{preference statement} is of the form
%
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?;?$\dots$?;?${e}_n$?} : ?$B$?.
\end{lstlisting}
%
where \code{s} is a term giving the preference name, 
\code{t} is a ground term providing the preference type, 
and each $e_j$ is a preference element.
The rule body $B$ has the same form and purpose as above.
%
%\begin{note}
That is, the body $B$ of a preference statement is used to instantiate the variables of $s$, $t$ and each $e_i$.

For example, given the logic program 
\begin{lstlisting}[numbers=none]
dom(1..2).
{ a(X,Y) : dom(X), dom(Y)}.
\end{lstlisting}
the preference statement 
\begin{lstlisting}[numbers=none]
#preference(p(X),subset){ a(X,Y) : dom(Y) } : dom(X).
\end{lstlisting}
stands for the following two ground preference statements.
\begin{lstlisting}[numbers=none]
#preference(p(1),subset){ a(1,1) ; a(1,2) }.
#preference(p(2),subset){ a(2,1) ; a(2,2) }.
\end{lstlisting}
%\end{note}

Preference statements are accompanied by 
\emph{optimization directives} such as
\begin{lstlisting}[numbers=none,escapechar=?]
#optimize(s) : ?$B$?.
\end{lstlisting}
where $B$ is as above, 
telling \asprin\ to restrict its reasoning mode to the preference relation declared by \code{s}.
% 

A \emph{preference specification} is a set of preference statements along with an optimization directive.
% A preference specification 
It is valid, if after grounding the naming dependencies are acyclic and closed
and there is a single optimization directive
(see \cite{brderosc15a} for details).
% A non ground preference specification is valid
% if after grounding it (using the accompanying logic program)
% the resulting ground specification is valid.

The purpose of such a specification is to define the optimal answer sets of an accompanying logic program,
also called the \emph{base program}.

Here is an example of a {preference specification} about leisure activities (without base program).
\begin{lstlisting}[escapechar=?]
#preference(costs,less(weight)){ 40::sauna; 70::dive }.
#preference(fun,superset){ sauna; dive; hike; ~bunji }.
#preference(temps,aso){dive>sauna||hot; sauna>dive||~hot}.
#preference(all,pareto){name(costs); name(fun); name(temps)}.

#optimize(all).
\end{lstlisting}
The preference statement in Line~1 represents the preference relation \code{costs} of type \code{less(weight)}.
Intuitively, this relation optimizes the sum of weights of its preference elements, 
viz.\ \code{40::sauna} and \code{70::dive}.
This preference type is very similar to the one used by native minimization directives (cf.\ Section~\ref{subsec:gringo:optimize}).
The preference type \code{superset} provides a set inclusion based relation and the one refereed to as \code{aso}
amounts to answer set optimization as put forward in~\cite{brnitr03a}.
These three basic preference relations are combined according to the \code{pareto} principle in Line~4.
And this combined preference relation is declared subject to optimization in Line~6.
%
All four preference types are predefined in \asprin's preference library and take different syntactic restrictions of preference elements as arguments.
\paragraph{A simple example.} 
\comment{JR: Maybe add something here?\par T: Why is your detailed example (10.1) not enough ...?}
\begin{example}
Consider the following base program.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/base.lp}{base.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/base.lp}{base.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
% \attach{examples/base.lp}{\code{base.lp}}
%
\lstinputlisting[numbers=none]{examples/base.lp}
%
% The output of the solver looks as follows:
% \begin{lstlisting}[numbers=none]
% ...
% Answer: 1
% m(2) a(1) a(2) b(1) 
% Answer: 2
% m(3) a(5) b(2) b(3) b(4) b(5) 
% Answer: 3
% m(1) a(1) b(1) b(2) b(3) b(4) b(5)
% ...
% \end{lstlisting}
We obtain three answer sets, one with \code{m(1)}, \code{m(2)}, and \code{m(3)}, respectively,
and refer to them as $M_1$, $M_2$, and $M_3$.

We can use \asprin\ to compute the answer sets of the base program that are subset minimal with respect to atoms of predicate $a/1$. 
This can be done with the following preference specification 
(available in \attach{examples/preference1.lp}{\code{preference1.lp}}): 
%
\lstinputlisting{examples/preference1.lp}
%
Line~1 contains a preference statement of name \code{p1} and type \code{subset} that contains a single preference element.
%The body of the preference element has to be formed by domain predicates, here \code{dom(X)}.
Intuitively, the preference statement \code{p1} defines a preference of type \code{subset} over atoms of predicate \code{a/1}. 
Line~2 contains an optimize statement that instructs \asprin\ to compute answer sets that are optimal with respect to \code{p1}. 

\begin{note}
Unlike \gringo's native optimization statements and weak constraints (cf.\ Section~\ref{subsec:gringo:optimize}),
\asprin\ separates the declaration of preferences from the actual optimization directive.
\end{note}

To compute an answer set of the base program that is optimal with respect to \code{p1}, 
an implementation of the preference type \code{subset} must be provided.
This is comprised in \asprin's preference library,
contained in file \code{asprin.lib}.
With it, the computation can be performed by the following command:
%
\marginlabel{\clingo, \asprin\ and the related files \code{asprin.parser}, \code{asprin.py} and \code{asprin.lib}
             ought to be located in some directory
             in the system path.}%
\comment{JR: I will pretty print all these margin boxes if we decide they stay}
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib
\end{lstlisting}
%
This command produces the following output:
%
\begin{lstlisting}[numbers=none]
asprin version 1.0
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND

Models       : 1
  Enumerated : 2

\end{lstlisting}
%
At first, \asprin\ finds the answer set $M_2$ of the base program. 
Then, it looks for an answer set that is preferred to $M_2$ and it finds $M_1$. 
In the last step, \asprin\ looks for an answer set that is preferred to $M_1$,  
and given that none is found the optimality of $M_1$ is established. 
In total, two answer sets were enumerated in the computation of an optimal solution.

We can minimize the extension of predicates \code{a/1} and \code{b/1} with the following preference specification.
%\attach{examples/preference2.lp}{\code{preference2.lp}}: 
%
\lstinputlisting[numbers=none]{examples/preference2.lp}
%
Now, we obtain that $M_2$ is already an optimal answer set: 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference2.lp}{preference2.lp} \ 
  asprin.lib}}
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
OPTIMUM FOUND
\end{lstlisting}
\end{example}

\paragraph{Computing many optimal answer sets.}

In analogy to \clasp\ and \clingo, 
\asprin\ allows for computing $n$ optimal models by adding the number $n$ to the command line;
as well, $0$ is used to compute all optimal models. 

For instance, the command
%
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib 0
\end{lstlisting}
%
results in the output:
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
\end{lstlisting}
%
The computation of the first optimal answer set, $M_1$, is the same as above.
Then, \asprin\ searches for an answer set of the base program that is not worse than $M_1$, 
finds $M_3$, and proves that it is optimal. 
In the last step, \asprin\ looks for some answer set that is not worse than $M_1$ and $M_3$,  
and given that there is none, it terminates. 

Adding the following choice rule 
(via file \attach{examples/c1.lp}{\code{c1.lp}})
%
\lstinputlisting[numbers=none]{examples/c1.lp}
%
to the above optimization process
yields two additional optimal answer sets, both containing \code{c(1)}: 
%
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib}}
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(1) a(1) b(4) b(3) b(5) b(2) b(1) c(1)
OPTIMUM FOUND *
Answer: 4
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
Answer: 5
m(3) a(5) b(4) b(3) b(5) b(2) c(1)
OPTIMUM FOUND *
\end{lstlisting}
%
When \asprin\ looks for an answer set that is not worse than $M_1$,  
it first looks for models that interpret atoms appearing in the preference statements
in the same way as $M_1$. 
In this way,
it finds the second optimal model, that contains $c(1)$, 
and prints it followed by the line `\lstinline{OPTIMUM FOUND *}'.  
Then, it continues searching, finds $M_3$ and the process continues. 

Finally,
we can project optimal models on the atoms in preference statements 
by option \lstinline{--projection}.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib \
  0 --projection}\\
}
This yields only the three optimal answer sets not containing \code{c(1)}.
% \attach{examples/c1.lp}{\code{c1.lp}}:
%
% \begin{lstlisting}[numbers=none]
% Answer: 1
% m(2) a(2) a(1) b(1)
% Answer: 2
% m(1) a(1) b(4) b(3) b(5) b(2) b(1)
% OPTIMUM FOUND
% Answer: 3
% m(3) a(5) b(4) b(3) b(5) b(2)
% OPTIMUM FOUND
% \end{lstlisting}

\comment{J: Stopped here\par T: Me too :) --- THANKS!!}
\paragraph{More preference types.}

\asprin's preference library, \code{asprin.lib}, implements the following basic preference types:
\comment{T2J: Fix admissible input (preference elements)}
\begin{itemize}
	\item  \code{subset} and \code{superset}   
	\item  \code{less(cardinality)} and \code{more(cardinality)}   
	\item  \code{less(weight)} and \code{more(weight)}   
	\item  \code{aso}   (Answer Set Optimization, \cite{brnitr03a})   
	\item  \code{poset} (Qualitative Preferences, \cite{rogima10a})  
\end{itemize}
% [1] Gerhard Brewka, Ilkka Niemela, Miroslaw Truszczynski: Answer Set Optimization. IJCAI 2003: 867-872. 
% [2] Emanuele Di Rosa, Enrico Giunchiglia, Marco Maratea: Solving satisfiability problems with preferences. Constraints 15(4): 485-515 (2010). 
As another example, 
we can use the type \code{less(cardinality)} to minimize the cardinality of the atoms of predicate \code{b/1}: 
%
\lstinputlisting[numbers=none]{examples/preference3.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference3.lp}{preference3.lp} \ 
  asprin.lib}}
This yields the unique optimal answer set $M_2$.

The library of \asprin\ implements furthermore the following composite preference types~\cite{sonpon06a}: 
\comment{T2J: Fix admissible input (preference elements)}
\begin{itemize}
\item \code{and}
\item \code{not}
\item \code{lexico}
\item \code{pareto}
\end{itemize}

For example, 
the following preference specification 
aggregates the basic preferences \code{p1} and \code{p3}
via a \code{pareto} preference, viz.~\code{p4}: 
%
\lstinputlisting[numbers=none]{examples/preference4.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference4.lp}{preference4.lp} \ 
  asprin.lib}}
%
This results in the optimal answer sets $M_1$, $M_2$ and $M_3$.

Alternatively,
we can aggregate \code{p1} over \code{p3}
via a lexicographic order, \code{p5}:
\lstinputlisting[numbers=none]{examples/preference5.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference5.lp}{preference5.lp} \ 
  asprin.lib}}
In this case, $M_1$ and $M_3$ are the optimal answer sets.

\paragraph{Implementing new preference types.}

The parser of \asprin\ translates preference and optimize statements into regular logic programs.  
For example, 
\attach{examples/preference1.lp}{\code{preference1.lp}} 
is translated into the following rules:
\begin{lstlisting}
preference(p1,subset).
preference(p1,(1,(X)),1,for(a(X)),()) :- dom(X).
optimize(p1).
\end{lstlisting}
Lines~1 and 3 are easy to understand. 
Line~2 can be read as follows.
In preference statement \code{p1}, the first element has variables $\{\code{X}\}$,  
and in the first position of the element there is a positive literal \code{a(X)}  that has an empty list of weights associated. 
\DELc{The format is detailed in \cite{brderosc15a}.}{T: Shouldn't this be here as well?}

We use above a preference statement of type \code{subset}, 
but its meaning is a priori unknown to \asprin.
This is given by a preference program, that is, a logic program representing the semantics of the given preference type. 
Preference programs start with a directive
\begin{lstlisting}[numbers=none]
#program preference(type).
\end{lstlisting}
and end at the end of a file, or with the directive
\lstinline{#program base.}
signaling the start of a base program (cf.~Section~\ref{sec:multi}). 

For example, the preference type \code{subset} can be implemented as follows
(\attach{examples/subset.lp}{\code{subset.lp}}).
%
\lstinputlisting[basicstyle=\small\ttfamily,numbers=none]{examples/subset.lp}
%
Consider that we want to compare two answer sets $H$ and $H'$. 
The true atoms in $H$ are represented by facts of predicate \code{holds/1},  and the true atoms in $H'$ are represented by facts of predicate \code{holds'/1}. 
Intuitively, \code{better(P)} is true if $H$ is preferred to $H'$ with respect to a preference statement \code{P} of type \code{subset}. 
More formally, 
\code{better(P)} is true if there is one atom \code{X} of the preference statement that is false in $H$ and true in $H'$, 
and all atoms \code{Y} of the preference statement that are false in $H'$ are also false in $H$.  
\comment{T2J: This is not self-contained! Must \texttt{holds} be implemented? What is required? On what can one rely? etc
\par I am not suggesting to give \texttt{holds} etc here, just fix teh interface ;)}

\begin{note}
Preference elements in \asprin\ are not restricted to atoms 
but also Boolean formulas, written with connectives 
\code{\~} for negation, 
\code{\&} for conjunction,
and 
\code{|} for disjunction.
\DELc{Please, have a look at \cite{brderosc15a} for more details.}{T: The syntax should be given in the section (see above comments)!\par Also, this
  should not be in the section how-to-implement --- integrate above :)}
\end{note}

\comment{T2J: Why is this important? See comment on interface :)}
In addition, 
there is a general integrity constraint enforcing optimization with respect to a given optimization statement
(\attach{examples/basic.lp}{\code{basic.lp}}):
%
\lstinputlisting[numbers=none]{examples/basic.lp}
%
We see that \code{better(P)} must hold whenever \code{P} is optimized. 
Instead of using \asprin's library, \code{asprin.lib}, 
we can now use the preference program, we have just defined:
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% %\attach{examples/subset.lp}{subset.lp}% %\attach{examples/basic.lp}{basic.lp}% 0
\end{lstlisting}
As before, we obtain $M_1$ and $M_3$ as optimal answer sets.
Other new preference types can be easily defined in this way.  
A look at \code{asprin.lib} may give a good starting point. 


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
