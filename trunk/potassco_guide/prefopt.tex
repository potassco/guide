
\section{Optimization and Preference handling}
\label{sec:prefopt}

\subsection{Multi-objective optimization}
\label{sec:oprimization}

This section is not yet ready for publishing
and will be included in one of the forthcoming editions of this guide.

Some information on multi-objective optimization
can be obtained at the following references.

\begin{itemize}
\item Optimization \cite{gekakasc11b,gekakasc11c,gekasc11b,ankamasc12a}
\item Video series on \clasp's optimization capacities \url{http://potassco.sourceforge.net/videos.html}
\end{itemize}

\subsection{Preference Handling with \asprin}\label{sec:asprin}
\comment{T2J: Add index statements}
\asprin\ provides a general framework for optimizing qualitative and quantitative preferences in ASP.
That is, it allows for computing optimal answer sets of logic programs with preferences.
While \asprin\ comes with a library of predefined preference types 
(\code{subset}, \code{pareto}, etc.),
it is readily extensible by new customized preference types.
For a formal description of \asprin, please consult~\cite{brderosc15a}. 

% \asprin\ source code and precompiled binaries for Linux, Mac and Windows are available  
% at \url{http://cs.uni-potsdam.de/asprin}.

\com{T2J: Where to give a syntax specification?}

\paragraph{Syntax.}
\asprin's input language is made up of the following elements: 
% \emph{weighted formulas},
% \emph{preference elements}, 
% \emph{preference statements}, and
% \emph{optimization statements}.

A \emph{weighted formula} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{t}$?::?$t$?
\end{lstlisting}
where each $\boldsymbol{t}$ is a term tuple and $t$ is a either a term representing a Boolean expression or a naming atom.
The term
$t$ is formed from reified atoms using function symbols $\mathtt{neg/2}$, $\mathtt{and/2}$, and $\mathtt{or/2}$.\comment{T: That's what we have at AAAI!}
We write $t$ whenever $\boldsymbol{t}$ is empty.
%
For expressing composite preferences,
we use a dedicated unary naming predicate \code{name} that allows us to refer to auxiliary preferences.
That is, a naming atom, \code{name(s)}, refers to relations associated with a preference statement \code{s} (see below).

% A \emph{preference element} is of the form%
% \footnote{Following~\cite{bilawi10a}.}
% \begin{equation}\label{eq:preference:element}
% {\Phi_1>\dots>\Phi_m}\;\|\;\phi
% \end{equation}
% where $\phi$ is a non-weighted formula giving the context, and each $\Phi_r$
% is a set of weighted formulas for $r=1,\dots,m$ and $m\geq 1$.
% %
% Intuitively, $r$ gives the rank of the respective set of weighted formulas.
% Preference elements provide a (possible) structure to a set of weighted formulas
% by giving a means of conditionalization and a symbolic way of defining pre-orders (in addition to using weights).
% %
% For convenience, we may drop the surrounding braces of such sets
% and omit ``$\|\,\phi$'' if $\phi$ is tautological.
% Also, we drop ``$>$'' if $m=1$.
% %
% Hence
% $\{a,\neg{b}\}>c$ stands for $\{a,\neg{b}\}>\{c\}\;\|\;\top$. Similarly, $40\!:\!\mathit{sauna}$ in (\ref{eq:costs}) stands for $\{40\!:\!\mathit{sauna}\}\;\|\;\top$.
% %$a,\neg{b},c$ stands for $\{a,\neg{b},c\}\|\top$, and $\{a,\neg{b}\}>c\;\|\;\neg{d}$ stands for $\{a,\neg{b}\}>\{c\}\;\|\;\neg{d}$.

% A \emph{preference statement} $p$ is of the form
% \begin{equation}\label{eq:preference:statement}
% \#\pf(s,t)\{e_1,\dots,e_n\}
% \end{equation}
% where $s$ and $t$ are ground terms giving the preference name and its type,
% respectively, and each $e_j$ is a preference element.
% %for $j=1,\dots,n$.
% In what follows,
% we use $id(p)$ to denote $p$'s identifier $s$ and refer to its type by $t_s$.
% %
% The preference type determines the set of admissible preference elements.
% For instance,
% $\mathit{less(weight)}$ in \eqref{eq:costs} is restricted to weighted literals.
% %while $\mathit{aso}$ in \eqref{eq:temps} takes general preference elements.
% %
% %Analogously,
% A preference type may or may not require naming atoms,
% depending on whether it is \emph{composite} or \textit{primitive}.
% %
% For instance, %the preference type $\mathit{less(weight)}$ in \eqref{eq:subset} is primitive,
%  $\mathit{pareto}$ in \eqref{eq:pareto} is composite.

% %As described in the next section, each preference statement $s$ is associated with a strict partial order $\succ_s$.
% %The relation $\succ_s$ is of the preference type denoted by $t_s$.
% %Other variations of $\succ_s$ are of no interest when optimizing $s$.
% %\comment{J: I think at this point the meaning of ``variations''  of $\succ_s$ is not clear to the reader}
% %
% %If $s$ is not subject to optimization, it may serve as an auxiliary element
% %in a composite preference statement.
% %To this end, some preference types may belong to a preference library, and
% %provide definitions of the non-strict, equal, and inverse variants of the type at hand.
% %In such a case, a naming atom $\name(s)$ provides the importing preference statement also with the non-strict, equal, and inverse counterparts of $\succ_s$, namely,
% %$\succeq_s$, $=_s$, and $\prec_s$, $\preceq_s$.
% %For instance,
% %in \eqref{eq:costs}-\eqref{eq:pareto},
% %the preference relation $\succ_{\mathit{all}}$ relies on the auxiliary relations $\succ_{\mathit{costs}}$ and $\succeq_{\mathit{costs}}$, among others.
% %On the implementation side, this is reflected by the distinction between a \emph{preference program} and a \emph{preference module}
% %(see Section~\ref{sec:approach}).
% %The former is importing preference implementations, while the latter is being imported.

% A set of preference statements is accompanied by a single
% \emph{optimization directive},
% \(
% \#\mathit{optimize}(s)
% \),
% telling a solver to restrict its reasoning mode to the preference relation declared by $s$.
% %
% The collection of preference statements in a program has to satisfy certain requirements to be useful. We say a set of preference statements $S$ is
% \begin{itemize}
% \item
% \emph{closed}, if $p\in S$ for some $p$ with $id(p) = s$ whenever $\name(s)$ occurs in $S$, and
% \item
% \emph{acyclic}, if the dependency relation induced among preference statements in $S$ by naming atoms is acyclic.
% \end{itemize}
% A \emph{preference specification} is a set of preference statements $S$
% along with a single directive $\#\mathit{optimize}(s)$ such that
% $S$ is acyclic and closed and, for some $p\in S$, $id(p) = s$.
% We call $p$ the \emph{primary} preference statement in $S$ and refer to
% statements in $S\setminus\{p\}$ as \emph{secondary}.


\begin{example}
Consider the program
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/base.lp}{base.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/base.lp}{base.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
\attach{examples/base.lp}{\code{base.lp}}, 
that we call the base program:
%
\lstinputlisting[numbers=none]{examples/base.lp}
%
% The output of the solver looks as follows:
% \begin{lstlisting}[numbers=none]
% ...
% Answer: 1
% m(2) a(1) a(2) b(1) 
% Answer: 2
% m(3) a(5) b(2) b(3) b(4) b(5) 
% Answer: 3
% m(1) a(1) b(1) b(2) b(3) b(4) b(5)
% ...
% \end{lstlisting}
We obtain three answer sets, one with \code{m(1)}, \code{m(2)}, and \code{m(3)}, respectively,
and refer to them as $M_1$, $M_2$, and $M_3$.

We can use \asprin\ to compute the answer sets of the base program that are subset minimal with respect to atoms of predicate $a/1$. 
This can be done with the following preference specification 
(available in \attach{examples/preference1.lp}{\code{preference1.lp}}): 
%
\lstinputlisting{examples/preference1.lp}
%
Line~1 contains a preference statement of name \code{p1} and type \code{subset} that contains a single preference element.
The body of the preference element has to be formed by domain predicates, here \code{dom(X)}.\comment{T2J: Only each variable must be bound by a domain predicate, or?}
Intuitively, the preference statement \code{p1} defines a preference of type \code{subset} over atoms of predicate \code{a/1}. 
Line~2 contains an optimize statement that instructs \asprin\ to compute answer sets that are optimal with respect to \code{p1}. 

\begin{note}
Unlike \gringo's native optimization statements and weak constraints (cf.\ Section~\ref{subsec:gringo:optimize}),
\asprin\ separates the declaration of preferences from the actual optimization directive.
\eexample
\end{note}

To compute an answer set of the base program that is optimal with respect to \code{p1}, 
an implementation of the preference type \code{subset} must be provided.
This is comprised in \asprin's preference library,
contained in file \code{asprin.lib}.
With it, the computation can be performed by the following command:
%
\marginlabel{\clingo, \asprin\ and the related files \code{asprin.parser}, \code{asprin.py} and \code{asprin.lib}
             ought to be located in some directory
             in the system path.}%
\comment{JR: I will pretty print all these margin boxes if we decide they stay}
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib
\end{lstlisting}
%
This command produces the following output:
%
\begin{lstlisting}[numbers=none]
asprin version 1.0
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND

Models       : 1
  Enumerated : 2

\end{lstlisting}
%
At first, \asprin\ finds the answer set $M_2$ of the base program. 
Then, it looks for an answer set that is preferred to $M_2$ and it finds $M_1$. 
In the last step, \asprin\ looks for an answer set that is preferred to $M_1$,  
and given that none is found the optimality of $M_1$ is established. 
In total, two answer sets were enumerated in the computation of an optimal solution.

We can minimize $a/1$ and $b/1$ with the following preference specification:
%\attach{examples/preference2.lp}{\code{preference2.lp}}: 
%
\lstinputlisting[numbers=none]{examples/preference2.lp}
%
Now, we obtain that $M_2$ is already an optimal answer set: 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference2.lp}{preference2.lp} \ 
  asprin.lib}}
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
OPTIMUM FOUND
\end{lstlisting}
\eexample
\end{example}

\paragraph{Computing many optimal answer sets.}

In analogy to \clasp\ and \clingo, 
\asprin\ allows for computing $n$ optimal models by adding the number $n$ to the command line;
as well, $0$ is used to compute all optimal models. 

For instance, the command
%
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib 0
\end{lstlisting}
%
results in the output:
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
\end{lstlisting}
%
The computation of the first optimal answer set, $M_1$, is the same as above.
Then, \asprin\ searches for an answer set of the base program that is not worse than $M_1$, 
finds $M_3$, and proves that it is optimal. 
In the last step, \asprin\ looks for some answer set that is not worse than $M_1$ and $M_3$,  
and given that there is none, it terminates. 

Adding file 
\attach{examples/c1.lp}{\code{c1.lp}}
to the above command
%
\lstinputlisting[numbers=none]{examples/c1.lp}
%
yields two additional optimal answer sets, both containing \code{c(1)}: 
%
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib}}
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(1) a(1) b(4) b(3) b(5) b(2) b(1) c(1)
OPTIMUM FOUND *
Answer: 4
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
Answer: 5
m(3) a(5) b(4) b(3) b(5) b(2) c(1)
OPTIMUM FOUND *
\end{lstlisting}
%
When \asprin\ looks for an answer set that is not worse than $M_1$,  
it first looks for models that interpret atoms appearing in the preference statements
in the same way as $M_1$. 
In this way,
it finds the second optimal model, that contains $c(1)$, 
and prints it followed by the line ``\lstinline{OPTIMUM FOUND *}''.  
Then, it continues searching, finds $M_3$ and the process continues. 

Finally,
we can project optimal models on the atoms in preference statements 
by option \lstinline{--projection}.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib \
  0 --projection}\\
}
This yields only the three optimal answer sets not containing \code{c(1)}.
% \attach{examples/c1.lp}{\code{c1.lp}}:
%
% \begin{lstlisting}[numbers=none]
% Answer: 1
% m(2) a(2) a(1) b(1)
% Answer: 2
% m(1) a(1) b(4) b(3) b(5) b(2) b(1)
% OPTIMUM FOUND
% Answer: 3
% m(3) a(5) b(4) b(3) b(5) b(2)
% OPTIMUM FOUND
% \end{lstlisting}

\paragraph{More preference types.}

\asprin's preference library, \code{asprin.lib}, implements the following basic preference types:  
\begin{itemize}
	\item  \code{subset} and \code{superset}   
	\item  \code{less(cardinality)} and \code{more(cardinality)}   
	\item  \code{less(weight)} and \code{more(weight)}   
	\item  \code{aso}   (Answer Set Optimization, \cite{brnitr03a})   
	\item  \code{poset} (Qualitative Preferences, \cite{rogima10a})  
\end{itemize}
% [1] Gerhard Brewka, Ilkka Niemela, Miroslaw Truszczynski: Answer Set Optimization. IJCAI 2003: 867-872. 
% [2] Emanuele Di Rosa, Enrico Giunchiglia, Marco Maratea: Solving satisfiability problems with preferences. Constraints 15(4): 485-515 (2010). 
As another example, 
we can use the type \code{less(cardinality)} to minimize the cardinality of the atoms of predicate \code{b/1}: 
%
\lstinputlisting[numbers=none]{examples/preference3.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference3.lp}{preference3.lp} \ 
  asprin.lib}}
This yields the unique optimal answer set $M_2$.

The library of \asprin\ implements furthermore the following composite preference types~\cite{sonpon06a}: 
\begin{itemize}
\item \code{and}, \code{not}, \code{lexico}, and \code{pareto}.
\end{itemize}

For example, 
the following preference specification 
aggregates the basic preferences \code{p1} and \code{p3}
via a \code{pareto} preference, viz.~\code{p4}: 
%
\lstinputlisting[numbers=none]{examples/preference4.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference4.lp}{preference4.lp} \ 
  asprin.lib}}
%
This results in the optimal answer sets are $M_1$, $M_2$ and $M_3$.

Alternatively,
We can aggregates \code{p1} over \code{p3}
via a lexicographic order, \code{p5}:
\lstinputlisting[numbers=none]{examples/preference5.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference5.lp}{preference5.lp} \ 
  asprin.lib}}
In this case, $M_1$ and $M_3$ are the optimal answer sets.

\paragraph{Implementing new preference types.}

The parser of \asprin\ translates preference and optimize statements into regular logic programs.  
For example, 
\attach{examples/preference1.lp}{\code{preference1.lp}} 
is translated into the following rules:
\begin{lstlisting}
preference(p1,subset).
preference(p1,(1,(X)),1,for(a(X)),()) :- dom(X).
optimize(p1).
\end{lstlisting}
Lines~1 and 3 are easy to understand. 
Line~2 can be read as follows.
In preference statement \code{p1}, the first element has variables $\{\code{X}\}$,  
and in the first position of the element there is a positive literal \code{a(X)}  that has an empty list of weights associated. 
\DELc{The format is detailed in \cite{brderosc15a}.}{T: Shouldn't this be here as well?}

We use above a preference statement of type \code{subset}, 
but its meaning is a priori unknown to \asprin.
This is given by a preference program, that is, a logic program representing the semantics of the given preference type. 
Preference programs start with a directive
\begin{lstlisting}[numbers=none]
#program preference(type).
\end{lstlisting}
and end at the end of a file, or with the directive
\lstinline{#program base.}
signaling the start of a base program (cf.~Section~\ref{sec:multi}). 

For example, the preference type \code{subset} can be implemented as follows
(\attach{examples/subset.lp}{\code{subset.lp}}).
%
\lstinputlisting[basicstyle=\small\ttfamily,numbers=none]{examples/subset.lp}
%
Consider that we want to compare two answer sets $H$ and $H'$. 
The true atoms in $H$ are represented by facts of predicate \code{holds/1},  and the true atoms in $H'$ are represented by facts of predicate \code{holds'/1}. 
Intuitively, \code{better(P)} is true if $H$ is preferred to $H'$ with respect to a preference statement \code{P} of type \code{subset}. 
More formally, 
\code{better(P)} is true if there is one atom \code{X} of the preference statement that is false in $H$ and true in $H'$, 
and all atoms \code{Y} of the preference statement that are false in $H'$ are also false in $H$.  

\begin{note}
Preference elements in \asprin\ are not restricted to atoms 
but also Boolean formulas, written with connectives 
\code{\~} for negation, 
\code{\&} for conjunction,
and 
\code{|} for disjunction.
\DELc{Please, have a look at \cite{brderosc15a} for more details.}{T: The syntax should be given in the section (see above comments)!\par Also, this
  should not be in the section how-to-implement}
\eexample
\end{note}

In addition, 
there is a general integrity constraint enforcing optimization with respect to a given optimization statement.
(\attach{examples/basic.lp}{\code{basic.lp}}):
%
\lstinputlisting[numbers=none]{examples/basic.lp}
%
We see that \code{better(P)} must hold whenever \code{P} is optimized. 
Instead of using \asprin's library, \code{asprin.lib}, 
we can now use the preference program, we have just defined:
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% %\attach{examples/subset.lp}{subset.lp}% %\attach{examples/basic.lp}{basic.lp}% 0
\end{lstlisting}
As before, we obtain $M_1$ and $M_3$ as optimal answer sets.
Other new preference types can be easily defined in this way.  
A look at \code{asprin.lib} may give a good starting point. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
