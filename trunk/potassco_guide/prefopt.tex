
\section{Optimization and Preference handling}
\label{sec:prefopt}

\subsection{Multi-objective optimization}
\label{sec:oprimization}

This section is not yet ready for publishing
and will be included in one of the forthcoming editions of this guide.

Some information on multi-objective optimization
can be obtained at the following references.

\begin{itemize}
\item Optimization \cite{gekakasc11b,gekakasc11c,gekasc11b,ankamasc12a}
\item Video series on \clasp's optimization capacities \url{http://potassco.sourceforge.net/videos.html}
\end{itemize}

\subsection{Preference Handling with \asprin}\label{sec:asprin}
\comment{T2J: Add index statements}
\asprin\ provides a general framework for optimizing qualitative and quantitative preferences in ASP.
It allows for computing optimal answer sets of logic programs with preferences.
While \asprin\ comes with a library of predefined preference types 
(\code{subset}, \code{pareto}, etc.),
it is readily extensible by new customized preference types.
For a formal description of \asprin, please consult~\cite{brderosc15a}. 

% \asprin\ source code and precompiled binaries for Linux, Mac and Windows are available  
% at \url{http://cs.uni-potsdam.de/asprin}.

\com{T2J: Where to give the syntax specification?\par Copied last paragraph from AAAI paper\par Please rework and add *real* syntax, eg variables, etc!}

\paragraph{Syntax.}

\asprin's input language extends the one described in Section~\ref{sec:language} by constructs for expressing qualitative and quantitative preferences.

A \emph{weighted formula} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{t}$?::?$F$?
\end{lstlisting}
where $\boldsymbol{t}$ is a term tuple and $F$ is a either a Boolean expression or a naming atom.
We drop \code{::} and simply write $F$ whenever $\boldsymbol{t}$ is empty.
The expression
$F$ is formed from atoms using function symbols $\mathtt{neg/2}$, $\mathtt{and/2}$, and $\mathtt{or/2}$.\comment{T: That's what we have at AAAI!}
%
Otherwise, a naming atom of form \code{name(s)}
refers to the preference associated with statement \code{s} (see below).
%
Examples of weighted formulas are 
``\code{a(X)}'', 
``\code{C::edge(X,Y,C)}'', 
``\code{(1,2)::and(a,b)}'', and 
``\code{42::name(e)}''. 

A \emph{preference element} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{F}_1\;$?>?\,\dots\,?>?$\;\boldsymbol{F}_m$? || ?$F$?
\end{lstlisting}
where $F$ is a non-weighted formula, and each $\boldsymbol{F}_r$
is a set of weighted formulas for $r=1,\dots,m$ and $m\geq 1$.
%
Intuitively, $r$ gives the rank of the respective set of weighted formulas.
This is conditioned by $F$; that is, \code{||} is meant to provide a conditional.
Preference elements provide a (possible) structure to a set of weighted formulas
by giving a means of conditionalization and a symbolic way of defining pre-orders (in addition to using weights).
%
For convenience, we may drop the surrounding braces of such sets
and omit ``\code{||$\,F$}'' if $F$ is tautological.
Also, we drop ``\code{>}'' if $m=1$.
%
Hence
\code{\{a,neg(b)\}>c} stands for 
\code{\{a,neg(b)\}>\{c\} || and(d,neg(d))}. 
%
Examples of preference elements are 
``\code{a(X)}'',  
``\code{2::name(p)}'', 
``\code{\{a, b\} > \{c, d\}}'',  and
``\code{a > b || c}''.

A \emph{preference statement} is of the form
%
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?,?$\dots$?,?${e}_n$?}.
\end{lstlisting}
%
where \code{s} and \code{t} are ground terms giving the preference name and its type,
respectively, and each $e_j$ is a preference element.
%
Preference statements are accompanied by a single
\emph{optimization directive},
\begin{lstlisting}[numbers=none,escapechar=?]
#optimize(s).
\end{lstlisting}
telling \asprin\ to restrict its reasoning mode to the preference relation declared by \code{s}.
% 
A valid {preference specification} is a set of preference statements
being acyclic and closed wrt naming dependencies
along with a single optimization directive
(see \cite{brderosc15a} for details).

Here is an example of a {preference specification} about leisure activities.
\begin{lstlisting}[escapechar=?]
#preference(costs,less(weight)){ 40::sauna, 70::dive }.
#preference(fun,superset){ sauna, dive, hike, neg(bunji) }.
#preference(temps,aso){dive>sauna||hot, sauna>dive||neg(hot)}.
#preference(all,pareto){name(costs), name(fun), name(temps)}.

#optimize(all).
\end{lstlisting}
The preference statement in Line~1 represents the preference relation \code{costs} of type \code{less(weight)}.
Intuitively, this relation optimizes the sum of weights of its preference elements, 
viz.\ \code{40::sauna} and \code{70::dive}.
This preference type is very similar to the one used by native minimization directives (cf.\ Section~\ref{subsec:gringo:optimize}).
The preference type \code{superset} provides a set inclusion based relation and the one refereed to as \code{aso}
amounts to answer set optimization as put forward in~\cite{brnitr03a}.
These three basic preference relations are combined according to the \code{pareto} principle in Line~4.
And this combined preference relation is declared subject to optimization in Line~6.
%
All four preference types are predefined in \asprin's preference library and take different syntactic restrictions of preference elements as arguments.

\begin{example}
Consider the program
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/base.lp}{base.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/base.lp}{base.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
\attach{examples/base.lp}{\code{base.lp}}, 
that we call the base program:
%
\lstinputlisting[numbers=none]{examples/base.lp}
%
% The output of the solver looks as follows:
% \begin{lstlisting}[numbers=none]
% ...
% Answer: 1
% m(2) a(1) a(2) b(1) 
% Answer: 2
% m(3) a(5) b(2) b(3) b(4) b(5) 
% Answer: 3
% m(1) a(1) b(1) b(2) b(3) b(4) b(5)
% ...
% \end{lstlisting}
We obtain three answer sets, one with \code{m(1)}, \code{m(2)}, and \code{m(3)}, respectively,
and refer to them as $M_1$, $M_2$, and $M_3$.

We can use \asprin\ to compute the answer sets of the base program that are subset minimal with respect to atoms of predicate $a/1$. 
This can be done with the following preference specification 
(available in \attach{examples/preference1.lp}{\code{preference1.lp}}): 
%
\lstinputlisting{examples/preference1.lp}
%
Line~1 contains a preference statement of name \code{p1} and type \code{subset} that contains a single preference element.
The body of the preference element has to be formed by domain predicates, here \code{dom(X)}.\comment{T2J: Only each variable must be bound by a domain predicate, or?}
Intuitively, the preference statement \code{p1} defines a preference of type \code{subset} over atoms of predicate \code{a/1}. 
Line~2 contains an optimize statement that instructs \asprin\ to compute answer sets that are optimal with respect to \code{p1}. 

\begin{note}
Unlike \gringo's native optimization statements and weak constraints (cf.\ Section~\ref{subsec:gringo:optimize}),
\asprin\ separates the declaration of preferences from the actual optimization directive.
\eexample
\end{note}

To compute an answer set of the base program that is optimal with respect to \code{p1}, 
an implementation of the preference type \code{subset} must be provided.
This is comprised in \asprin's preference library,
contained in file \code{asprin.lib}.
With it, the computation can be performed by the following command:
%
\marginlabel{\clingo, \asprin\ and the related files \code{asprin.parser}, \code{asprin.py} and \code{asprin.lib}
             ought to be located in some directory
             in the system path.}%
\comment{JR: I will pretty print all these margin boxes if we decide they stay}
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib
\end{lstlisting}
%
This command produces the following output:
%
\begin{lstlisting}[numbers=none]
asprin version 1.0
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND

Models       : 1
  Enumerated : 2

\end{lstlisting}
%
At first, \asprin\ finds the answer set $M_2$ of the base program. 
Then, it looks for an answer set that is preferred to $M_2$ and it finds $M_1$. 
In the last step, \asprin\ looks for an answer set that is preferred to $M_1$,  
and given that none is found the optimality of $M_1$ is established. 
In total, two answer sets were enumerated in the computation of an optimal solution.

We can minimize $a/1$ and $b/1$ with the following preference specification:
%\attach{examples/preference2.lp}{\code{preference2.lp}}: 
%
\lstinputlisting[numbers=none]{examples/preference2.lp}
%
Now, we obtain that $M_2$ is already an optimal answer set: 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference2.lp}{preference2.lp} \ 
  asprin.lib}}
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
OPTIMUM FOUND
\end{lstlisting}
\eexample
\end{example}

\paragraph{Computing many optimal answer sets.}

In analogy to \clasp\ and \clingo, 
\asprin\ allows for computing $n$ optimal models by adding the number $n$ to the command line;
as well, $0$ is used to compute all optimal models. 

For instance, the command
%
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib 0
\end{lstlisting}
%
results in the output:
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
\end{lstlisting}
%
The computation of the first optimal answer set, $M_1$, is the same as above.
Then, \asprin\ searches for an answer set of the base program that is not worse than $M_1$, 
finds $M_3$, and proves that it is optimal. 
In the last step, \asprin\ looks for some answer set that is not worse than $M_1$ and $M_3$,  
and given that there is none, it terminates. 

Adding file 
\attach{examples/c1.lp}{\code{c1.lp}}
to the above command
%
\lstinputlisting[numbers=none]{examples/c1.lp}
%
yields two additional optimal answer sets, both containing \code{c(1)}: 
%
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib}}
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(1) a(1) b(4) b(3) b(5) b(2) b(1) c(1)
OPTIMUM FOUND *
Answer: 4
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
Answer: 5
m(3) a(5) b(4) b(3) b(5) b(2) c(1)
OPTIMUM FOUND *
\end{lstlisting}
%
When \asprin\ looks for an answer set that is not worse than $M_1$,  
it first looks for models that interpret atoms appearing in the preference statements
in the same way as $M_1$. 
In this way,
it finds the second optimal model, that contains $c(1)$, 
and prints it followed by the line ``\lstinline{OPTIMUM FOUND *}''.  
Then, it continues searching, finds $M_3$ and the process continues. 

Finally,
we can project optimal models on the atoms in preference statements 
by option \lstinline{--projection}.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib \
  0 --projection}\\
}
This yields only the three optimal answer sets not containing \code{c(1)}.
% \attach{examples/c1.lp}{\code{c1.lp}}:
%
% \begin{lstlisting}[numbers=none]
% Answer: 1
% m(2) a(2) a(1) b(1)
% Answer: 2
% m(1) a(1) b(4) b(3) b(5) b(2) b(1)
% OPTIMUM FOUND
% Answer: 3
% m(3) a(5) b(4) b(3) b(5) b(2)
% OPTIMUM FOUND
% \end{lstlisting}

\paragraph{More preference types.}

\asprin's preference library, \code{asprin.lib}, implements the following basic preference types:
\comment{T2J: Fix admissible input (preference elements)}
\begin{itemize}
	\item  \code{subset} and \code{superset}   
	\item  \code{less(cardinality)} and \code{more(cardinality)}   
	\item  \code{less(weight)} and \code{more(weight)}   
	\item  \code{aso}   (Answer Set Optimization, \cite{brnitr03a})   
	\item  \code{poset} (Qualitative Preferences, \cite{rogima10a})  
\end{itemize}
% [1] Gerhard Brewka, Ilkka Niemela, Miroslaw Truszczynski: Answer Set Optimization. IJCAI 2003: 867-872. 
% [2] Emanuele Di Rosa, Enrico Giunchiglia, Marco Maratea: Solving satisfiability problems with preferences. Constraints 15(4): 485-515 (2010). 
As another example, 
we can use the type \code{less(cardinality)} to minimize the cardinality of the atoms of predicate \code{b/1}: 
%
\lstinputlisting[numbers=none]{examples/preference3.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference3.lp}{preference3.lp} \ 
  asprin.lib}}
This yields the unique optimal answer set $M_2$.

The library of \asprin\ implements furthermore the following composite preference types~\cite{sonpon06a}: 
\comment{T2J: Fix admissible input (preference elements)}
\begin{itemize}
\item \code{and}
\item \code{not}
\item \code{lexico}
\item \code{pareto}
\end{itemize}

For example, 
the following preference specification 
aggregates the basic preferences \code{p1} and \code{p3}
via a \code{pareto} preference, viz.~\code{p4}: 
%
\lstinputlisting[numbers=none]{examples/preference4.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference4.lp}{preference4.lp} \ 
  asprin.lib}}
%
This results in the optimal answer sets are $M_1$, $M_2$ and $M_3$.

Alternatively,
We can aggregates \code{p1} over \code{p3}
via a lexicographic order, \code{p5}:
\lstinputlisting[numbers=none]{examples/preference5.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference5.lp}{preference5.lp} \ 
  asprin.lib}}
In this case, $M_1$ and $M_3$ are the optimal answer sets.

\paragraph{Implementing new preference types.}

The parser of \asprin\ translates preference and optimize statements into regular logic programs.  
For example, 
\attach{examples/preference1.lp}{\code{preference1.lp}} 
is translated into the following rules:
\begin{lstlisting}
preference(p1,subset).
preference(p1,(1,(X)),1,for(a(X)),()) :- dom(X).
optimize(p1).
\end{lstlisting}
Lines~1 and 3 are easy to understand. 
Line~2 can be read as follows.
In preference statement \code{p1}, the first element has variables $\{\code{X}\}$,  
and in the first position of the element there is a positive literal \code{a(X)}  that has an empty list of weights associated. 
\DELc{The format is detailed in \cite{brderosc15a}.}{T: Shouldn't this be here as well?}

We use above a preference statement of type \code{subset}, 
but its meaning is a priori unknown to \asprin.
This is given by a preference program, that is, a logic program representing the semantics of the given preference type. 
Preference programs start with a directive
\begin{lstlisting}[numbers=none]
#program preference(type).
\end{lstlisting}
and end at the end of a file, or with the directive
\lstinline{#program base.}
signaling the start of a base program (cf.~Section~\ref{sec:multi}). 

For example, the preference type \code{subset} can be implemented as follows
(\attach{examples/subset.lp}{\code{subset.lp}}).
%
\lstinputlisting[basicstyle=\small\ttfamily,numbers=none]{examples/subset.lp}
%
Consider that we want to compare two answer sets $H$ and $H'$. 
The true atoms in $H$ are represented by facts of predicate \code{holds/1},  and the true atoms in $H'$ are represented by facts of predicate \code{holds'/1}. 
Intuitively, \code{better(P)} is true if $H$ is preferred to $H'$ with respect to a preference statement \code{P} of type \code{subset}. 
More formally, 
\code{better(P)} is true if there is one atom \code{X} of the preference statement that is false in $H$ and true in $H'$, 
and all atoms \code{Y} of the preference statement that are false in $H'$ are also false in $H$.  
\comment{T2J: This is not self-contained! Must \texttt{holds} be implemented? What is required? On what can one rely? etc
\par I am not suggesting to give \texttt{holds} etc here, just fix teh interface ;)}

\begin{note}
Preference elements in \asprin\ are not restricted to atoms 
but also Boolean formulas, written with connectives 
\code{\~} for negation, 
\code{\&} for conjunction,
and 
\code{|} for disjunction.
\DELc{Please, have a look at \cite{brderosc15a} for more details.}{T: The syntax should be given in the section (see above comments)!\par Also, this
  should not be in the section how-to-implement --- integrate above :)}
\eexample
\end{note}

\comment{T2J: Why is this important? See comment on interface :)}
In addition, 
there is a general integrity constraint enforcing optimization with respect to a given optimization statement
(\attach{examples/basic.lp}{\code{basic.lp}}):
%
\lstinputlisting[numbers=none]{examples/basic.lp}
%
We see that \code{better(P)} must hold whenever \code{P} is optimized. 
Instead of using \asprin's library, \code{asprin.lib}, 
we can now use the preference program, we have just defined:
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% %\attach{examples/subset.lp}{subset.lp}% %\attach{examples/basic.lp}{basic.lp}% 0
\end{lstlisting}
As before, we obtain $M_1$ and $M_3$ as optimal answer sets.
Other new preference types can be easily defined in this way.  
A look at \code{asprin.lib} may give a good starting point. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
