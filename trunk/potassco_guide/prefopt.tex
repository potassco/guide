
\section{Optimization and Preference handling}
\label{sec:prefopt}

\subsection{Multi-objective optimization}
\label{sec:oprimization}

This section is not yet ready for publishing
and will be included in one of the forthcoming editions of this guide.

Some information on multi-objective optimization
can be obtained at the following references.

\begin{itemize}
\item Optimization \cite{gekakasc11b,gekakasc11c,gekasc11b,ankamasc12a}
\item Video series on \clasp's optimization capacities \url{http://potassco.sourceforge.net/videos.html}
\end{itemize}

\subsection{Preference Handling with \asprin}

\asprin\ provides a general framework for optimizing qualitative and quantitative preferences in ASP.
That is, it allows for computing optimal answer sets of logic programs with preferences.
While \asprin\ comes with a library of predefined preference types 
(\code{subset}, \code{pareto}, etc.),
it is readily extensible by new customized preference types.
For a formal description of \asprin, please consult~\cite{brderosc15a}. 

% \asprin\ source code and precompiled binaries for Linux, Mac and Windows are available  
% at \url{http://cs.uni-potsdam.de/asprin}.

\begin{example}
Consider the program
\attach{examples/base.lp}{\code{base.lp}}, 
that we call the base program:
\lstinputlisting[numbers=none]{examples/base.lp}
The output of the solver looks as follows:
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/base.lp}{base.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/base.lp}{base.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
\begin{lstlisting}[numbers=none]
...
Answer: 1
m(2) a(1) a(2) b(1) 
Answer: 2
m(3) a(5) b(2) b(3) b(4) b(5) 
Answer: 3
m(1) a(1) b(1) b(2) b(3) b(4) b(5)
...
\end{lstlisting}
We obtain $3$ answer sets, one with $m(1)$, one with $m(2)$ and another with $m(3)$, 
that we call $M_1$, $M_2$ and $M_3$, respectively.

We can apply \asprin\ to look for the answer sets of the base program that are subset minimal with respect to predicate $a/1$. 
We write the following preference specification in  
\attach{examples/preference1.lp}{\code{preference1.lp}}: 
\lstinputlisting{examples/preference1.lp}
Lines~1--3 define a preference statement of name $p1$ and type $subset$ that contains one preference element in Line~2.
The body of the preference element has to be formed by domain predicates of the base program, in this case $gr(X)$.
Intuitively, the preference statement defines a preference of type subset over atoms of predicate $a/1$. 
Line~4 contains an optimize statement that instructs \asprin\ to compute answer sets that are optimal with respect to $p1$. 

To compute one optimal answer set, invoke the following command: 
\marginlabel{\clingo, \asprin\ and the related files \code{asprin.parser}, \code{asprin.py} and \code{asprin.lib}
             ought to be located in some directory
             in the system path.}%
\comment{JR: I will pretty print all these margin boxes if we decide they stay}
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib
\end{lstlisting}
File \code{asprin.lib} is the preference library of \asprin, 
it is a logic program implementing many preference types.
Follows the output of \asprin:
\begin{lstlisting}[numbers=none]
asprin version 1.0
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND

Models       : 1
  Enumerated : 2

\end{lstlisting}
At first \asprin\ finds the answer set $M_2$ of the base program. 
Then it looks for an answer set that is preferred to $M_2$, and finds $M_1$. 
In the last step, \asprin\ looks for an answer set that is preferred to $M_1$,  
and given that no one is found this proves the optimality of $M_1$. 
In total, one optimal solution was computed, and two answer sets were enumerated. 

We can minimize $a/1$ and $b/1$ with the following preference specification:
%\attach{examples/preference2.lp}{\code{preference2.lp}}: 
\lstinputlisting[numbers=none]{examples/preference2.lp}
Then we obtain that $M_2$ is already an optimal answer set: 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference2.lp}{preference2.lp} \ 
  asprin.lib}\\
}
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
OPTIMUM FOUND

\end{lstlisting}
\eexample
\end{example}


\paragraph{Computing many optimal answer sets}
As with \clasp\ and \clingo, 
in \asprin\ we can compute $n$ optimal models adding the number $n$ to the command line,  
where $0$ is used to compute all optimal models. 
For instance, with the following invocation:
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib 0
\end{lstlisting}
we obtain:
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND

\end{lstlisting}
Here \asprin\ runs as before to compute one optimal solution.
Then it searches for an answer set of the base program that is not worse than $M_1$, 
finds $M_3$ and proves that it is optimal. 
In the last step, \asprin\ looks for some answer set that is not worse than $M_1$ and $M_3$,  
and given that there is none, it finishes. 

Adding file 
\attach{examples/c1.lp}{\code{c1.lp}}: 
\lstinputlisting[numbers=none]{examples/c1.lp}
we obtain two optimal answer sets more, that contain $c(1)$: 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib}\\
}
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(1) a(1) b(4) b(3) b(5) b(2) b(1) c(1)
OPTIMUM FOUND *
Answer: 4
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND
Answer: 5
m(3) a(5) b(4) b(3) b(5) b(2) c(1)
OPTIMUM FOUND *

\end{lstlisting}
When \asprin\ looks for an answer set that is not worse than $M_1$,  
first it looks for models that interpret the same way as $M_1$ 
the atoms that appear in the preference statements. 
This way it finds the second optimal model, that contains $c(1)$, 
and prints it followed by the line \lstinline{OPTIMUM FOUND *}.  
Then it continues searching, finds $M_3$ and the process continues. 

We can project the optimal models on the atoms of the preference statements 
with option \lstinline{--projection}, 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib \
  0 --projection}\\
}
obtaining the three optimal answer sets we had without 
\attach{examples/c1.lp}{\code{c1.lp}}: 
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(4) b(3) b(5) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(3) a(5) b(4) b(3) b(5) b(2)
OPTIMUM FOUND

\end{lstlisting}

\paragraph{More preference types}

The library of \asprin, \code{asprin.lib}, implements the following basic preference types:  
\begin{itemize}
	\item  $subset$ and $superset$   
	\item  $less(cardinality)$ and $more(cardinality)$   
	\item  $less(weight)$ and $more(weight)$   
	\item  $aso$   (Answer Set Optimization, \cite{brnitr03a})   
	\item  $poset$ (Qualitative Preferences, \cite{rogima10a})  
\end{itemize}
% [1] Gerhard Brewka, Ilkka Niemela, Miroslaw Truszczynski: Answer Set Optimization. IJCAI 2003: 867-872. 
% [2] Emanuele Di Rosa, Enrico Giunchiglia, Marco Maratea: Solving satisfiability problems with preferences. Constraints 15(4): 485-515 (2010). 
As an example, we can use the type $less(cardinality)$ to minimize the cardinality of the atoms of predicate b/1: 
\lstinputlisting[numbers=none]{examples/preference3.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference3.lp}{preference3.lp} \ 
  asprin.lib}\\
}
and we obtain the unique optimal answer set $M_2$.

The library of  \asprin\ implements the following composite preference types,  
that appeared in \cite{sonpon06a}: $and$, $not$, $lexico$ and $pareto$.
For example, in the following preference specification 
we apply a $pareto$ preference $p4$ on top of $p1$ and $p3$: 
\lstinputlisting[numbers=none]{examples/preference4.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference4.lp}{preference4.lp} \ 
  asprin.lib}\\
}
and the optimal answer sets are $M_1$, $M_2$ and $M_3$. 
We can also apply a lexicographic order $p5$ giving priority to $p1$ over $p3$: 
\lstinputlisting[numbers=none]{examples/preference5.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference5.lp}{preference5.lp} \ 
  asprin.lib}\\
}
and in this case $M_1$ and $M_3$ are the optimal answer sets.

\paragraph{Implementing new preference types}

The parser of \asprin\ translates the preference and optimize statements into gringo rules.  
For example, 
\attach{examples/preference1.lp}{\code{preference1.lp}} 
is translated into the following rules:
\begin{lstlisting}
preference(p1,subset).
preference(p1,(1,(X)),1,for(a(X)),()) :- gr(X).
optimize(p1).
\end{lstlisting}
Lines~1 and 3 are easy to understand. 
Line~2 can be read as: in preference statement $p1$, the first element has variables $\{X\}$,  
and in the first position of the element there is a positive literal $a(X)$  that has an empty list of weights associated. 
For details about the translation, please have a look at the paper (\cite{brderosc15a}). 

So far we have specified a preference statement of type $subset$, 
but for \asprin\ this preference type $subset$ has no predefined meaning. 
This has to be given by a preference program,  ie. a logic program the represents the semantics of the given preference type. 
Preference programs start with a directive: 
\begin{lstlisting}[numbers=none]
#program preference(type).
\end{lstlisting}
and end at the end of a file, or with a directive:  
\begin{lstlisting}[numbers=none]
#program base.
\end{lstlisting}
that signals the start of a base program. 
For the $subset$ type, we may write file 
\attach{examples/subset.lp}{\code{subset.lp}}: 
\lstinputlisting[basicstyle=\small\ttfamily,numbers=none]{examples/subset.lp}
Consider that we want to compare two answer sets $H$ and $H'$. 
The true atoms in $H$ are represented by facts of predicate $holds/1$,  and the true atoms in $H'$ are represented by facts of predicate $holds'/1$. 
Intuitively, $better(P)$ is true if $H$ is preferred to $H'$ with respect to a preference statement $P$ of type $subset$. 
More formally, 
$better(P)$ is true if there is one atom $X$ of the preference statement that is false in $H$ and true in $H'$, 
and all the atoms $Y$ of the preference statement that are false in $H'$ are also false in $H$.  

\begin{note}
Preference elements in \asprin\ allow not just atoms 
but also boolean formulas, written with connectives \code{\~} for negation, 
\code{\&} for conjunction and \code{|} for disjunction.
Please, have a look at \cite{brderosc15a} for more details. 
\end{note}

To complete the implementation of the preference type we also have file: 
\attach{examples/basic.lp}{\code{basic.lp}}: 
\lstinputlisting[numbers=none]{examples/basic.lp}
where we state that $better(P)$ must hold if $P$ is optimized. 
Instead of using the \asprin\ library at \code{asprin.lib}, 
now we can use the preference program we have defined:
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}%  %\attach{examples/subset.lp}{subset.lp}%  %\attach{examples/basic.lp}{basic.lp}% 0
\end{lstlisting}
and we obtain (as before) that $M_1$ and $M_3$ are the optimal answer sets.
Other new preference types can be easily defined in this way.  
If you want to do this, having a look at \code{asprin.lib} may be the best point to start. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
