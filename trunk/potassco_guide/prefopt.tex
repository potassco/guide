
\section{Optimization and Preference Handling}
\label{sec:prefopt}

\subsection{Multi-objective Optimization with \clasp\ and \clingo}
\label{sec:oprimization}

This subsection is not yet ready for publishing
and will be included in one of the forthcoming editions of this guide.

Some information on multi-objective optimization
can be obtained at the following references.

\begin{itemize}
\item Optimization \cite{gekakasc11b,gekakasc11c,gekasc11b,ankamasc12a}
\item Video series on \clasp's optimization capacities \url{http://potassco.sourceforge.net/videos.html}
\item Consult Section~\ref{subsec:gringo:optimize} for language constructs expressing multi-criteria optimization.
\item Consult Section~\ref{subsec:clasp:solving} and~\ref{subsec:clasp:tune} for relevant \clasp\ options configurating the optimization process.
\end{itemize}

\subsection{Preference Handling with \asprin}\label{sec:asprin}
\comment{T2J: Add index statements. \par JR: yes, I will do it when I'm done with the rest :)}
\index{Optimization!Preference Statements}%
\index{Optimization!Optimization Directives}%
\asprin\ provides a general framework for optimizing qualitative and quantitative preferences in ASP.
It allows for computing optimal answer sets of logic programs with preferences.
While \asprin\ comes with a library of predefined preference types 
(\code{subset}, \code{pareto}, etc.),
it is readily extensible by new customized preference types.
For a formal description of \asprin, please consult~\cite{brderosc15a}. 

\subsubsection{Computing optimal answer sets}

Similar to common optimization in ASP,
where objective functions are added to logic programs
via minimize statements or weak constraints,
a preference specification is added to a logic program
to single out the optimal answer sets wrt the given preferences.
However, as with minimize statements,
such a specification is not part of the program
but rather a meta statement referring to its answer sets.
Hence, preference specifications are directives and thus preceded by \#.
For clarity, we also refer to the underlying program as the \emph{base program}
(also in view of distinguishing it from the \emph{preference program},
implementing the preference specification; see below).

To begin with,
let us consider a simple example providing a holistic view on preference handling with \asprin.
%
\begin{example}
\label{asprin:example1}
Consider the following base program.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}clingo \attach{examples/base.lp}{base.lp} 0}\\
  or alternatively:\\
  \code{\mbox{~}gringo \attach{examples/base.lp}{base.lp} \textbackslash \\\mbox{~}| clasp 0}\\
}
% \attach{examples/base.lp}{\code{base.lp}}
%
\lstinputlisting[numbers=none]{examples/base.lp}
%
% The output of the solver looks as follows:
% \begin{lstlisting}[numbers=none]
% ...
% Answer: 1
% m(2) a(1) a(2) b(1) 
% Answer: 2
% m(3) a(5) b(2) b(3) b(4) b(5) 
% Answer: 3
% m(1) a(1) b(1) b(2) b(3) b(4) b(5)
% ...
% \end{lstlisting}
We obtain three answer sets, one with \code{m(1)}, \code{m(2)}, and \code{m(3)}, respectively,
and refer to them as $X_1$, $X_2$, and $X_3$.

For a first example,
we can use \asprin\ to compute the answer sets of the base program that are subset minimal with respect to atoms of predicate $a/1$. 
This can be done with the following preference specification 
(available in \attach{examples/preference1.lp}{\code{preference1.lp}}): 
%
\lstinputlisting{examples/preference1.lp}
%
Line~1 contains a preference statement of name \code{p1} and type \code{subset} that contains a single (non-ground) preference element.
%The body of the preference element has to be formed by domain predicates, here \code{dom(X)}.
Intuitively, the preference statement \code{p1} defines a preference of type \code{subset} over atoms of predicate \code{a/1}. 
Line~2 contains an optimize statement that instructs \asprin\ to compute answer sets that are optimal with respect to \code{p1}. 

\begin{note}
Unlike \gringo's native optimization statements and weak constraints (cf.\ Section~\ref{subsec:gringo:optimize}),
\asprin\ separates the declaration of preferences from the actual optimization directive.
\end{note}

To compute an answer set of the base program that is optimal with respect to \code{p1}, 
an implementation of the preference type \code{subset} must be provided.
This is comprised in \asprin's preference library,
contained in file \code{asprin.lib}.
With it, the computation can be performed by the following command:
%
\marginlabel{\clingo, \asprin\ and the related files \code{asprin.parser}, \code{asprin.py} and \code{asprin.lib}
             ought to be located in some directory
             in the system path.}%
\comment{JR: I will pretty print all these margin boxes if we decide they stay}
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib
\end{lstlisting}
%
This command produces the following output:
%
\begin{lstlisting}[numbers=none]
asprin version 1.0
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(3) b(2) b(1)
OPTIMUM FOUND

Models       : 1
  Enumerated : 2

\end{lstlisting}
%
At first, \asprin\ finds the answer set $X_2$ of the base program. 
Then, it looks for an answer set that is preferred to $X_2$ and it finds $X_1$. 
In the last step, \asprin\ looks for an answer set that is preferred to $X_1$,  
and given that none is found the optimality of $X_1$ is established. 
In total, two answer sets were enumerated in the computation of an optimal solution.

Alternatively,
we can minimize the extension of predicates \code{a/1} and \code{b/1} with the following preference specification.
%\attach{examples/preference2.lp}{\code{preference2.lp}}: 
%
\lstinputlisting[numbers=none]{examples/preference2.lp}
%
Now, we obtain that $X_2$ is already an optimal answer set: 
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference2.lp}{preference2.lp} \ 
  asprin.lib}}
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
OPTIMUM FOUND
\end{lstlisting}
\end{example}

\subsubsection{Computing multiple optimal answer sets}

In analogy to \clasp\ and \clingo, 
\asprin\ allows for computing $n$ optimal answer sets by adding the number $n$ to the command line;
as well, $0$ is used to compute all optimal answer sets. 

\begin{example}
For instance, the command
%
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% asprin.lib 0
\end{lstlisting}
%
results in the output:
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(3) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(3) a(3) b(3) b(2)
OPTIMUM FOUND
\end{lstlisting}
%
The computation of the first optimal answer set, $X_1$, is the same as above.
Then, \asprin\ searches for an answer set of the base program that is not worse than $X_1$, 
finds $X_3$, and proves that it is optimal. 
In the last step, \asprin\ looks for some answer set that is not worse than $X_1$ and $X_3$,  
and given that there is none, it terminates. 

Adding the following choice rule 
(via file \attach{examples/c1.lp}{\code{c1.lp}})
to the above optimization process
%
\lstinputlisting[numbers=none]{examples/c1.lp}
%
yields two additional optimal answer sets, both containing \code{c(1)}: 
%
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib}}
%
\begin{lstlisting}[numbers=none]
Answer: 1
m(2) a(2) a(1) b(1)
Answer: 2
m(1) a(1) b(3) b(2) b(1)
OPTIMUM FOUND
Answer: 3
m(1) a(1) b(3) b(2) b(1) c(1)
OPTIMUM FOUND *
Answer: 4
m(3) a(3) b(3) b(2)
OPTIMUM FOUND
Answer: 5
m(3) a(3) b(3) b(2) c(1)
OPTIMUM FOUND *
\end{lstlisting}
%
When \asprin\ looks for an answer set that is not worse than $X_1$,  
it first looks for answer sets that interpret atoms appearing in the preference statements
in the same way as $X_1$. 
In this way,
it finds the second optimal model, that contains $c(1)$, 
and prints it followed by the line `\lstinline{OPTIMUM FOUND *}'.  
Then, it continues searching, finds $X_3$ and the process continues. 

Finally,
we can project optimal answer sets on the atoms in preference statements 
by \asprin's option \lstinline{--projection}.
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference1.lp}{preference1.lp} \ 
  \attach{examples/c1.lp}{c1.lp} \ 
  asprin.lib \
  0 --projection}\\
}
This yields only the three optimal answer sets not containing \code{c(1)}.
% \attach{examples/c1.lp}{\code{c1.lp}}:
%
% \begin{lstlisting}[numbers=none]
% Answer: 1
% m(2) a(2) a(1) b(1)
% Answer: 2
% m(1) a(1) b(4) b(3) b(5) b(2) b(1)
% OPTIMUM FOUND
% Answer: 3
% m(3) a(5) b(4) b(3) b(5) b(2)
% OPTIMUM FOUND
% \end{lstlisting}
\end{example}

\subsubsection{Input language of \asprin}

\asprin's input language extends the one described in Section~\ref{sec:language} by constructs for expressing qualitative and quantitative preferences.

A \emph{weighted formula} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{t}$?::?$F$?
\end{lstlisting}
where $\boldsymbol{t}$ is a term tuple
\footnote{%
Term tuples in the current \asprin\ implementation are defined following Figure \ref{fig:terms}, 
except that \emph{terms} cannot contain \emph{functions}, 
and \emph{simpleterms} cannot contain \emph{constants}. 
Moreover, neither intervals (Section \ref{subsec:gringo:interval}) nor pools  (Section \ref{subsec:gringo:pool})
are allowed in weighted formulas. 
These limitations will be removed in future releases. 
By now, as a workaround, these elements can be represented as follows:
in the weighted formula, write a variable (e.g., \code{V}) instead of the prohibited element (e.g., \code{a(X)}),  
and in the body (see below) assign the variable to the element (e.g., \code{V = a(X)}).
}
and $F$ is a either a Boolean formula or a naming atom.
We may drop \code{::} and simply write $F$ whenever $\boldsymbol{t}$ is empty.
Boolean formulas are formed from atoms, possibly preceded by classical negation (`\code{-}'),
using the connectives \code{not} (default negation), \code{\&} (conjunction) and \code{|} (disjunction).
Parentheses can be written as usual,
and when omitted, negation has precedence over conjunction, and conjunction over disjunction.
%
Naming atoms of form \code{name(s)}
refer to the preference associated with preference statement \code{s} (see below).
%
Examples of weighted formulas are 
`\code{42::a}', 
`\code{a(X)}', 
`\code{C::edge(X,Y,C)}', 
`\code{W,(X,Y):: not a(W,X) \& b(Y)}', and 
`\code{X::name(p(X))}'. 

If $F_1$, \ldots, $F_n$ are weighted formulas, then
\begin{lstlisting}[numbers=none,escapechar=?]
{?$F_1$?;?$\dots$?;?$F_m$?}
\end{lstlisting}
is a set of weighted formulas.
We may drop the curly braces if $m=1$.

A \emph{preference element} is of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{F}_1\;$?>?\,\dots\,?>?$\;\boldsymbol{F}_m$? || ?$F$? : ?$B$?
\end{lstlisting}
where each $\boldsymbol{F}_r$ is a set of weighted formulas, 
$F$ is a non-weighted Boolean formula
and $B$ is a rule body where all literals belong to domain predicates
(see Page~\pageref{pg:domain}) or built-ins.
%
We may drop `\code{>}' if $m=1$, 
and `\code{||$\,F$}' and `\code{:$\,B$}' whenever $F$ and/or $B$ are empty, respectively.
%
Intuitively, $r$ gives the rank of the respective set of weighted formulas.
This can be made subject to condition $F$ by using the conditional `\code{||}'.
Preference elements provide a (possible) structure to a set of weighted formulas
by giving a means of conditionalization and a symbolic way of defining pre-orders (in addition to using weights).
%
%Hence
%\code{\{a(X);b(X) \& c(X))\}>d(X)} stands for 
%\code{\{a;neg(b)\}>\{c\} || and(d,neg(d))}. 
%
Examples of preference elements are 
`\code{42::a}', 
`\code{a(X)}',  
`\code{1::name(p);2::name(q)}', 
`\code{\{a(X);b(X)\} > \{c(X);d(X)\}}',  and
`\code{a(X) > b(X) || c(X) : dom(X)}'.

\begin{note}
Here and below, 
the rule body $B$ is intended \emph{exclusively} to provide instantiations for the variables appearing in the expressions to its left.  
Accordingly, the literals in $B$ must be built-ins or belong to domain predicates of the accompanying logic program.
This ensures that $B$ can be fully evaluated during grounding.
\end{note}

\begin{note}
Preference elements are required to be \emph{safe}, 
i.e., all variables in a preference element must occur in some positive literal 
in its body or in the body of the preference statement containing it (see below).  
\end{note} 

A \emph{preference statement} is of the form %
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?;?$\dots$?;?${e}_n$?} : ?$B$?.
\end{lstlisting}
%
where \code{s} is a term giving the preference name, 
\code{t} is a ground\footnote{This is a pragmatic restriction,
enabling \asprin\ to only include the relevant parts of its library.} 
term providing the preference type, 
and each $e_j$ is a preference element.
The rule body $B$ has the same form and purpose as above.
%
%\begin{note}
That is, the body $B$ of a preference statement is used to instantiate the variables of $s$, $t$ and each $e_i$.
For safety, all variables appearing in \code{s} must also appear in a positive literal in $B$.

\begin{example}
\label{asprin:example2}
Given the logic program 
\begin{lstlisting}[numbers=none]
dom(1..2).
{ a(X,Y) : dom(X), dom(Y)}.
\end{lstlisting}
the preference statement 
\begin{lstlisting}[numbers=none]
#preference(p(X),subset){ a(X,Y) : dom(Y) } : dom(X).
\end{lstlisting}
stands for the following two ground preference statements:
\begin{lstlisting}[numbers=none]
#preference(p(1),subset){ a(1,1) ; a(1,2) }.
#preference(p(2),subset){ a(2,1) ; a(2,2) }.
\end{lstlisting}
\end{example}
%\end{note}

Preference statements are accompanied by 
\emph{optimization directives} such as
\begin{lstlisting}[numbers=none,escapechar=?]
#optimize(s) : ?$B$?.
\end{lstlisting}
where $B$ is as above, 
telling \asprin\ to restrict its reasoning mode to the preference relation declared by \code{s}.
% 

A \emph{preference specification} is a set of preference statements along with an optimization directive.
It is valid, if grounding results in acyclic and closed naming dependencies
along with a single optimization directive
(see \cite{brderosc15a} for details).
% A non ground preference specification is valid
% if after grounding it (using the accompanying logic program)
% the resulting ground specification is valid.
Whenever these conditions do not hold, \asprin\ reports an error and exits.
%
As mentioned,
the purpose of such a specification is to define the optimal answer sets of an underlying base logic program.

\begin{example}\label{asprin:example3}
Here is %an example of 
a {preference specification} about leisure activities (without base program).
\begin{lstlisting}[escapechar=?]
#preference(costs,less(weight)){ 
  C :: sauna : cost(sauna,C); 
  C ::  dive : cost(dive,C) 
}.
#preference(fun,superset){ sauna; dive; hike; not bunji }.
#preference(temps,aso){
  dive > sauna ||     hot; 
 sauna > dive  || not hot
}.
#preference(all,pareto){name(costs); name(fun); name(temps)}.

#optimize(all).
\end{lstlisting}
%The preference statement in Line~1 represents the preference relation \code{costs} of type \code{less(weight)}.
Intuitively, this relation optimizes the sum of weights of its preference elements, 
viz.\ \code{C::sauna:cost(sauna,C)} and \code{C::dive:cost(dive,C)}.
Intuitively, this relation optimizes the sum of weights of its preference elements.
This preference type is very similar to the one used by native minimization directives (cf.\ Section~\ref{subsec:gringo:optimize}).
The preference type \code{superset} provides a set inclusion based relation and the one refereed to as \code{aso}
amounts to answer set optimization as put forward in~\cite{brnitr03a}.
These three basic preference relations are combined according to the \code{pareto} principle in Line~10.
And this combined preference relation is declared subject to optimization in Line~12.
\end{example}
%
%All four preference types are predefined in \asprin's preference library and take different syntactic restrictions of preference elements as arguments.

\subsubsection{Preference relations and preference types}

A ground preference statement declares a 
strict partial order over answer sets.\footnote{A strict partial order is a transitive and irreflexive relation.}
This order is called a \emph{preference relation}.
\begin{example}
The preference statement of Example \ref{asprin:example1} stands for the following ground preference statement:
\begin{lstlisting}[numbers=none]
#preference(p1,subset){ a(1); a(2); a(3) }.
\end{lstlisting}
It declares the following preference relation:
\[
\begin{array}{cccl}
X \succ_{\code{p1}} Y & \text{ iff } &         & \{e\in \{\code{a(1)},\code{a(2)},\code{a(3)}\} \mid X\models e\} \\ 
                      &              & \subset & \{e\in \{\code{a(1)},\code{a(2)},\code{a(3)}\} \mid Y\models e\}
\end{array}
\]
In Example \ref{asprin:example1}, 
we get
$X_1\succ_{\code{p1}}X_2$ because \code{\{a(1)\}$\;\subset\;$\{a(1),a(2),a(3)\}}
and $X_3\succ_{\code{p1}}X_2$ given that \code{\{a(2),a(3)\}$\;\subset\;$\{a(1),a(2),a(3)\}};
however, we have $X_1\not\succ_{\code{p1}}X_3$ since \code{\{a(1)\}$\;\not\subset\;$\{a(2),a(3)\}}. 
\end{example}
An answer set $X$ of a base program $P$ is \emph{optimal} with respect to a preference relation $\succ$
if there is no other answer set $Y$ of $P$ such that $Y \succ X$.
In Example \ref{asprin:example1}, 
%with preference statement \code{p1},
$X_1$ and $X_3$ are optimal,
whereas $X_2$ is not because $X_1 \succ_{\code{p1}} X_2$ (and $X_3 \succ_{\code{p1}} X_2$).
%Given a valid preference specification where all preference statements are admissible, 
\asprin\ computes answer sets of the base program
that are optimal with respect to the preference relation 
defined by the preference statement selected for optimization.
Hence, in the example it produces $X_1$ and $X_3$.

But how does a preference statement declare a preference relation?
This is accomplished by the \emph{preference type}
that maps a set $E$ of ground preference elements into a preference relation.
For example, the type \code{subset} maps $E$ into
\[
X \succ Y \text{ iff } \{e\in E\mid X\models e\}\subset\{e\in E\mid Y\models e\}
\]
And when applied to the preference elements of \code{p1} in Example \ref{asprin:example1}, we obtain $\succ_{\code{p1}}$.

The full generality of preference elements is not always needed.
For example, for \code{subset} we are only interested in preference elements that are Boolean formulas.
For this reason, we specify for each preference type its \emph{domain}, 
i.e., the ground preference elements for which the preference type is well defined.
Hence, the domain of \code{subset} consists of Boolean formulas.
Furthermore, a ground preference statement
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?;?$\dots$?;?${e}_n$?}.
\end{lstlisting}
is \emph{admissible} if every ${e}_i$ belongs to the domain of \code{t}.
If a ground preference statement is not admissible, \asprin\ reports an error and exits. 
\begin{example}
In Example \ref{asprin:example1}, the preference statement \code{p1}  
is admissible because \code{a(1)}, \code{a(2)}, and \code{a(3)} are Boolean formulas
and thus belong to the domain of \code{subset}. 
If we added the preference elements \code{1::a(1)} or \code{name(p2)}, 
the statement would not be admissible any more.
\end{example}

\subsubsection{\asprin\ library}

\asprin's preference library implements the following basic preference types:
\begin{itemize}
	\item  \code{subset} and \code{superset}   
	\item  \code{less(cardinality)} and \code{more(cardinality)}   
	\item  \code{less(weight)} and \code{more(weight)}   
	\item  \code{aso}   (Answer Set Optimization, \cite{brnitr03a})   
	\item  \code{poset} (Qualitative Preferences, \cite{rogima10a})  
\end{itemize}

We have already given the definition of \code{subset}. 
The preference types \code{superset}, \code{less(cardinality)}, and \code{more(cardinality)} share the domain of \code{subset}.
Given a set of ground preference elements \code{$E$},
their semantics is defined as follows:
\begin{itemize}
\item
\code{superset} maps $E$ to the preference relation
\[
X \succ Y \text{ iff } \{e\in E\mid X\models e\}\supset\{e\in E\mid Y\models e\}
\]
\item
\code{less(cardinality)} maps $E$ to the preference relation
\[
X \succ Y \text{ iff } \{e\in E\mid X\models e\}<\{e\in E\mid Y\models e\}
\]
\item
\code{more(cardinality)} maps $E$ to the preference relation
\[
X \succ Y \text{ iff } \{e\in E\mid X\models e\}>\{e\in E\mid Y\models e\}
\]
\end{itemize}
\comment{JR: Add Example}

Preference types \code{less(weight)} and \code{more(weight)}
are similar to \code{\#minimize} and \code{\#maximize} statements.
However, they do not comprise priorities but apply to general Boolean formulas.
Their common domain consists of sets of ground preference elements of the form:
\begin{lstlisting}[numbers=none,escapechar=?]
?${w}$?,?$\boldsymbol{t}$?::?$F$?
\end{lstlisting}
Here, ${w}$ is an integer, $\boldsymbol{t}$ a term tuple, and $F$ a Boolean formula. 
%
Their meaning is defined with respect to a set $E$ of ground preference elements:
\begin{itemize}
\item
\code{less(cardinality)} maps $E$ to the preference relation
\[
X \succ Y 
\text{ iff }
\sum_{(w,\boldsymbol{t})\in\{w,\boldsymbol{t}\mid w,\boldsymbol{t}\mathtt{::}F\in E, X\models F\}}w
<
\sum_{(w,\boldsymbol{t})\in\{w,\boldsymbol{t}\mid w,\boldsymbol{t}\mathtt{::}F\in E, Y\models F\}}w
\]
\item
\code{more(cardinality)} maps $E$ to the preference relation
\[
X \succ Y 
\text{ iff }
\sum_{(w,\boldsymbol{t})\in\{w,\boldsymbol{t}\mid w,\boldsymbol{t}\mathtt{::}F\in E, X\models F\}}w
>
\sum_{(w,\boldsymbol{t})\in\{w,\boldsymbol{t}\mid w,\boldsymbol{t}\mathtt{::}F\in E, Y\models F\}}w
\]
\end{itemize}

The preference type~\code{aso} implements answer set optimization~\cite{brnitr03a} and relies upon
ground preference elements of the form:
\begin{lstlisting}[numbers=none,escapechar=?]
?$F_1\,$?>?$\,\dots\,$?>?$\,F_m$? || ?$B$?.
\end{lstlisting}
where each $F_i$ and $B$ are Boolean formulas.
Preference elements of this form are called \code{aso} rules.  
The semantics of \code{aso} is based on satisfaction degrees.
In a nutshell,
the satisfaction degree of an \code{aso} rule $r$ in an answer set $X$, 
written $v_X(r)$, is 
$1$ if $X$ does not satisfy the body $B$, % $X \not\models b$ for some $b\in B$, %\cap\mathcal{A}$ or  if $X \models b$ for some $\naf{b}\in B$, 
or  if $X$ does not satisfy any $F_i$, 
and it is $\min\{k \mid X \models F_k, 1\leq k\leq n\}$ otherwise.
Then, a set of \code{aso} rules $E$ is mapped to the preference relation defined as follows:
$X \succeq Y$ if for all rules $r \in E$, $v_X(r) \leq v_Y(r)$, 
and $X \succ Y$ if $X \succeq Y$ but $Y \not\succeq X$. 
See~\cite{brnitr03a} for details.
\comment{JR: Add Example}

The preference type \code{poset} implements the approach to qualitative preferences put forward in~\cite{giumar12a}.
Such preferences are modeled as a strict partially ordered set
\(
(S,<)
\)
of literals.
The literals in $S$ represent propositions that are preferably satisfied
and the strict partial order $<$ on $S$ gives their relative importance.
%
The \asprin\ implementation of \code{poset} extends the original approach by allowing preferences over Boolean formulas.
The domain of \code{poset} consists of the sets $E$ of ground preference elements of the form
\begin{lstlisting}[numbers=none,escapechar=?]
?$F$?.
\end{lstlisting}
or 
\begin{lstlisting}[numbers=none,escapechar=?]
?$F > F'$?.
\end{lstlisting}
where $F$ and $F'$ are Boolean formulas.
%
To give a glimpse of the formal underpinnings,
consider a set $E$ of such ground preference statements.
The set $S_E$ consists of all Boolean formulas appearing in $E$
and the partial order $>_E$ is the transitive closure of the order 
specified by the preference elements of the second type. 
Then, $X \succ Y$ holds if 
there is some formula $F \in S_E$ such that $X \models F$ and $Y \not\models F$, 
and for every formula $F \in S_E$ such that $Y \models F$ and $X \not\models F$, 
there is a formula
$F'\in S$ such that $F'<F$ and $X \models F'$ but $Y \not\models F'$.
The interested reader is referred to~\cite{{giumar12a}} for full details.
\comment{JR: Add Example}

%As another example,
%we can use the type \code{less(cardinality)} to minimize the cardinality of the atoms of predicate \code{b/1}: 
%%
%\lstinputlisting[numbers=none]{examples/preference3.lp}
%\marginlabel{%
%  To inspect the output, invoke:\\
%  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
%  \attach{examples/preference3.lp}{preference3.lp} \ 
%  asprin.lib}}
%This yields the unique optimal answer set $X_2$.

The library of \asprin\ implements furthermore the following composite preference types,
which amount to the ones defined in~\cite{sonpon06a}: 
\begin{itemize}
\item \code{neg}
\item \code{and}
\item \code{pareto}
\item \code{lexico}
\end{itemize}
Preference types \code{and} and \code{pareto} deal with sets of ground naming atoms
\begin{lstlisting}[numbers=none,escapechar=?]
name(s)
\end{lstlisting}
For \code{neg}, these sets must be singleton.
And for \code{lexico}, each naming atom has an attached tuple $\code{$w$}$: 
\begin{lstlisting}[numbers=none,escapechar=?]
?${w}$?::name(s)
\end{lstlisting}

Given a naming atom \code{name(s)}, 
let $\succeq_{\code{s}}$, $\succ_{\code{s}}$, $=_{\code{s}}$, $\prec_{\code{s}}$, $\preceq_{\code{s}}$ be the 
non-strict, strict, equal, and inverse preference relations associated with preference statement $\code{s}$.
Then, the semantics of each composite preference type is defined as follows:
\begin{itemize}
\item
\code{neg} maps $E=\code{\{name(s)\}}$ to the preference relation
\[
X \succ Y \text{ iff } Y \prec_s X
\]
\item 
\code{and} maps \code{$E=$\{name($s_1$);$\ldots$;name($s_n$)\}} to the preference relation 
\[
X \succ Y \text{ iff } \bigwedge_{\code{name(s)}\in E}(X\succ_\code{s} Y)
\]
\item 
\code{pareto} maps \code{$E=$\{name($s_1$);$\ldots$;name($s_n$)\}} to the preference relation 
\[
X \succ Y \text{ iff } \bigwedge_{\code{name(s)}\in E} (X\succeq_\code{s} Y)\wedge\bigvee_{\code{name(s)}\in E} (X\succ_\code{s} Y)
\]
\item
\code{lexico} maps \code{$E=$\{$w_1$::name($s_1$);$\ldots$;$w_n$::name($s_n$)\}} to the preference relation 
\[
X \succ Y \text{ iff } \bigvee_{\code{w::name(s)}\in E}\!((X\!\succ_\code{s} \!Y)\!\wedge\!\bigwedge_{\code{v::name(s')}\in E,\code{v}<\code{w}}(X =_{\code{s'}} Y)\!)
\] 
\end{itemize} 
\comment{JR: Stopped here\par T: Me too BUT moved section behind :)}

For example, the following preference specification aggregates the basic preferences \code{p1} and \code{p3}
via a \code{pareto} preference, viz.~\code{p4}: 
%
\lstinputlisting[numbers=none]{examples/preference4.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference4.lp}{preference4.lp} \ 
  asprin.lib}}
%
This results in the optimal answer sets $X_1$, $X_2$ and $X_3$.

Alternatively,
we can aggregate \code{p1} over \code{p3}
via a lexicographic order, \code{p5}:
\lstinputlisting[numbers=none]{examples/preference5.lp}
\marginlabel{%
  To inspect the output, invoke:\\
  \code{\mbox{~}asprin \attach{examples/base.lp}{base.lp} \
  \attach{examples/preference5.lp}{preference5.lp} \ 
  asprin.lib}}
In this case, $X_1$ and $X_3$ are the optimal answer sets.

\subsubsection{Implementing preference types}

In \asprin, preference types are implemented by logic programs called \emph{preference programs}.
In a nutshell, a preference type decides if, 
given a preference statement \code{s}, 
an answer set $X$ is better than another answer set $Y$.
To represent that decision by a preference program, 
the three involved elements \code{s}, $X$, and $Y$ are translated into facts and rules.
Let us first look at some simple translations of preference statements.
%In \asprin, preference statements are translated into rules.
%Let's see first some simple examples.
\begin{example}
\label{asprin:example1translated}
Recall the preference statement \code{p1} of Example \ref{asprin:example1}:
%\begin{lstlisting}[numbers=none]
\lstinputlisting[numbers=none,firstline=1,lastline=1]{examples/preference1.lp}
%#preference(p1,subset){ a(X) : dom(X) }.
%\end{lstlisting}
This is translated into: %the rules $F_\code{p1}$:
\begin{lstlisting}
preference(p1,subset).
preference(p1,(1,(X)),1,for(a(X)),()) :- dom(X).
\end{lstlisting}
Line~1 states the name and the type of the preference statement.
Line~2 can be read as follows:
in the preference statement \code{p1}, the first element has variables $\{\code{X}\}$,  
and in the first position of the element there is a Boolean formula \code{a(X)} that has an empty list of associated weights.
%The reification $F_\code{p2}$ of 
The translation of 
\lstinputlisting[numbers=none,firstline=1,lastline=1]{examples/preference2.lp}
replaces \code{p1} with \code{p2} in Line~1 and~2, and adds:
\begin{lstlisting}[numbers=none]
preference(p2,(2,(X)),1,for(b(X)),()) :- dom(X).
\end{lstlisting}
Number \code{2} in \code{(2,(X))} tells us that this is the second preference element. 
\end{example}

\begin{example}
The preference statement of Example \ref{asprin:example2}: 
\begin{lstlisting}[numbers=none]
#preference(p(X),subset){ a(X,Y) : dom(Y) } : dom(X).
\end{lstlisting}
is translated into the rules:
\begin{lstlisting}[numbers=none]
preference(p(X),subset) :- dom(X).
preference(p(X),(1,(X,Y)),1,for(a(X,Y)),()) :- dom(Y), dom(X).
\end{lstlisting}
Observe how \code{dom(X)} is appended to both rules. 
\end{example}

In general, a weighted formula \code{$\boldsymbol{t}$::$F$}
occurs in some set
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{F}_i=$?{?$F_1$?;?$\dots$?;?$F_m$?}
\end{lstlisting}
of a preference element $e_j$ of the form 
\begin{lstlisting}[numbers=none,escapechar=?]
?$\boldsymbol{F}_1\;$?>?$\,\dots\,$?>?$\;\boldsymbol{F}_n$? || ?$F_0$? : ?$B_j$?
\end{lstlisting}
that belongs itself to a preference statement \code{s} of the form
\begin{lstlisting}[numbers=none,escapechar=?]
#preference(s,t){?${e}_1$?;?$\dots$?;?${e}_n$?} : ?$B$?.
\end{lstlisting}
Accordingly, the weighted formula is translated into a rule of the form
\begin{lstlisting}[numbers=none,escapechar=?]
preference(s,(?$j$?,?$\boldsymbol{v}$?),?$i$?,for(?${t}_F$?),?$\boldsymbol{t}$?) :- ?$B_j$?, ?$B$?.
\end{lstlisting}
where $i$ and $j$ are the indexes of $\boldsymbol{F}_i$ and $e_j$, respectively, 
$\boldsymbol{v}$ is a term tuple containing all variables appearing in the rule, 
and ${t}_F$ is a term representing the Boolean formula $F$ 
by using function symbols $\code{\_not/1}$, $\code{\_and/2}$, and $\code{\_or/2}$ in prefix notation.
For example, 
the formula \code{(not a(X) | b(X)) \& c(X)} is translated into \code{\_and(c(X),\_or(\_not(a(X)),b(X)))}. 
%
For representing the condition $F_0$, $i$ is set to $\code{0}$.
%
A naming atom \code{name(s)} is represented analogously,
except that \code{for(${t}_F$)} is replaced by \code{name(s)}.
%
The translation of a preference statement of the form mentioned above 
comprises the translation of all weighted formulas appearing in it
along with the rule:
\begin{lstlisting}[numbers=none,escapechar=?]
preference(s,t) :- ?$B$?.
\end{lstlisting}
Optimize directives are translated similarly:
\begin{lstlisting}[numbers=none,escapechar=?]
#optimize(s) : ?$B$?.
\end{lstlisting}
becomes:
\begin{lstlisting}[numbers=none,escapechar=?]
optimize(s) :- ?$B$?.
\end{lstlisting}

\begin{note}
All bodies $B_j$ and $B$ consist of domain predicates or built-ins. 
%that can always be fully evaluated by the grounder, 
Hence, after grounding, all rules generated in the translation become facts.
\end{note}

\begin{example}
The preference specification of Example \ref{asprin:example3} is translated into the following rules:
\begin{lstlisting}[numbers=none,escapechar=?]
preference(costs, (1, (C)), 1, for(sauna), (C)).
preference(costs, (2, (C)), 1, for(dive),  (C)).
preference(costs, less(weight)).

preference(fun, (1, ()), 1, for(sauna), ()).
preference(fun, (2, ()), 1, for(dive), ()).
preference(fun, (3, ()), 1, for(hike), ()).
preference(fun, (4, ()), 1, for(_not(bunji)), ()).
preference(fun, superset).

preference(temps, (1, ()), 0, for(hot), ()).
preference(temps, (1, ()), 1, for(dive), ()).
preference(temps, (1, ()), 2, for(sauna), ()).
preference(temps, (2, ()), 0, for(_not(hot)), ()).
preference(temps, (2, ()), 1, for(sauna), ()).
preference(temps, (2, ()), 2, for(dive), ()).
preference(temps, aso).

preference(all, (1, ()), 1, name(costs), ()).
preference(all, (2, ()), 1, name(fun), ()).
preference(all, (3, ()), 1, name(temps), ()).
preference(all, pareto).

optimize(all).
\end{lstlisting}
\end{example}

%At this point, we have a preference statement \code{s} represented as one fact of the form:
%\begin{lstlisting}[numbers=none,escapechar=?]
%preference(s,t).
%\end{lstlisting}
%and many facts of the form:
%\begin{lstlisting}[numbers=none,escapechar=?]
%preference(s,(?$j$?,?$\boldsymbol{v}$?),?$i$?,for(?${t}_F$?),?$\boldsymbol{t}$?).
%\end{lstlisting}
%We want to decide whether $X$ is better than $Y$.

A preference program implementing a preference type \code{t}
compares two answer sets $X$ and $Y$
given a preference statement \code{s} of type \code{t}. %, 
%deciding if $X$ is better than $Y$.
To allow for this comparison, 
\asprin\ provides
for every term \code{for(${t}_F$)} appearing in the translation of \code{s}
the fact \code{holds(${t}_F$)} 
whenever $X$ satisfies the Boolean formula $F$.
Analogously, \asprin\ provides the fact \code{holds'(${t}_F$)}, if $Y$ satisfies $F$.

\begin{example}
For the preference statement \code{p1} of Example \ref{asprin:example1}, 
translated in Example \ref{asprin:example1translated}, \asprin\ provides the following facts. 
For deciding whether $X_1 \succ_\code{p1} X_2$ is true,
\asprin\ adds the facts
\code{holds(a(1))}, \code{holds'(a(1))}, \code{holds'(a(2))}, and \code{holds'(a(3))}.
Similarly, for testing $X_3 \succ_\code{p1} X_2$, \asprin\ provides
\code{holds(a(2))}, \code{holds(a(3))}, \code{holds'(a(1))}, \code{holds'(a(2))} and \code{holds'(a(3))}.
And for $X_1 \succ_\code{p1} X_3$, 
atoms \code{holds(a(1))}, \code{holds'(a(2))} and \code{holds'(a(3))} are established.
\end{example}

We have seen how \asprin\ provides the translation of the preference statement \code{s} of type \code{t} 
and the facts of predicates \code{holds/1} and \code{holds'/1} 
for every pair of answer sets $X$ and $Y$ that may be compared.
Then the preference program implementing \code{t} has two parts.
In the first part, we define the predicate \code{better/1} 
in such a way that \code{better(s)} is true 
%in the program that consists of the preference program
%along the translation of the preference statement and the \code{holds/1} and \code{holds'/1} facts 
iff $X \succ_\code{s} Y$.
In the second part, we add a constraint stating that 
%it must not be the case that 
if \code{s} is optimized then \code{better(s)} must be true. 
%A preference program $P$ implements a preference type \code{t} if, 
%given a preference statement \code{s} of type \code{t} and two answer sets $X$ and $Y$, 
%the program that contains $P$ along with the translation of \code{s} and the corresponding 
%\code{holds/1} and \code{holds'/1} facts for $X$ and $Y$ has an answer set
%iff $X \succ_{\code{s}} Y$. 

\begin{example}
The preference type \code{subset} can be implemented as follows
(see file \attach{examples/subset.lp}{\code{subset.lp}}).
%
\lstinputlisting[basicstyle=\small\ttfamily,numbers=none,firstline=1,lastline=4]{examples/subset.lp}
%
Consider that we want to compare two answer sets $X$ and $Y$
for which we have the corresponding \code{holds/1} and \code{holds'/1} facts. 
%The true atoms in $H$ are represented by facts of predicate \code{holds/1},  and the true atoms in $H'$ are represented by facts of predicate \code{holds'/1}. 
Intuitively, \code{better(s)} is true if $X$ better than $Y$ with respect to a preference statement \code{s} 
of type \code{subset}. 
More formally, 
\code{better(s)} is true if there is one formula \code{A} appearing in \code{s} that is false in $X$ and true in $Y$, 
and every formula \code{B} in \code{s} that is false in $Y$ is also false in $X$.  

In addition, 
the following integrity constraint enforces the optimization with respect to a given optimization directive:
(included in file \attach{examples/basic.lp}{\code{basic.lp}}):
%
\lstinputlisting[numbers=none]{examples/basic.lp}
%
This cardinality constraint makes sure that \code{better(P)} holds whenever \code{P} is optimized. 
Given that this rule is shared by many preference programs, 
it is included in a preference-type independent program named \code{preference}.

Instead of using \asprin's library, viz.~\code{asprin.lib}, 
we can now directly use the above preference program as follows:
\begin{lstlisting}[numbers=none,escapechar=\%]
asprin %\attach{examples/base.lp}{base.lp}% %\attach{examples/preference1.lp}{preference1.lp}% %\attach{examples/subset.lp}{subset.lp}% %\attach{examples/basic.lp}{basic.lp}% 0
\end{lstlisting}
As before, we obtain $X_1$ and $X_3$ as optimal answer sets.
%Other new preference types can be easily defined in this way.  
%A look at \code{asprin.lib} may give a good starting point. 
\end{example}

\begin{note}
Preference programs of type $t$ start with a directive
\begin{lstlisting}[numbers=none]
#program preference(t).
\end{lstlisting}
and end with another program directive or at the end of a file
(cf.~Section~\ref{subsec:gringo:meta}).
For every preference type \code{t} appearing in a preference statement \code{s}, 
there must be a preference program block starting with:
\begin{lstlisting}[numbers=none]
#program preference(t).
\end{lstlisting}
If there is no such block, \asprin\ prints an error and exits.
Additionally, ``generic'' preference program blocks starting with the directive
\begin{lstlisting}[numbers=none]
#program preference.
\end{lstlisting}
can be used. 
These are intended to provide rules shared by all preference programs.
\asprin\ loads all ``generic'' preference programs along with 
the preference programs for the types appearing in the preference statements of the program.
\end{note}

\begin{note}
There are some syntax restrictions to the form of preference programs:
\begin{itemize}
\item They may not contain atoms starting with an underscore `\_'.
\item Atoms of predicates \code{preference/2}, \code{preference/5}, 
      \code{holds/1}, \code{holds'} and \code{optimize/1}
      may not appear in the heads of rules.
\end{itemize}
\end{note}

\begin{note}
\asprin\ relies on the correctness of preference programs. 
In other words, 
if a preference program correctly implements the corresponding preference type,
then \asprin\ also functions correctly.
Otherwise, the behavior of \asprin\ is undefined.
\end{note}

\begin{note}
When using \asprin\ to compute many optimal answer sets the syntax of preference programs
is limited to that of stratified logic programs~\cite{apblwa87a}.
This excludes preference programs with disjunctions, choices, or aggregates in rule heads.
\end{note}

Recall from the previous section that we define a set of admissible preference elements for each preference type.
The respective notion of admissibility is defined in \asprin\ using predicate \code{\_error/1}.
That is, \code{\_error(X)} is true whenever the preference statement is not admissible.
In this case, \asprin\ exits and prints the error message bound to \code{X}.\footnote{%
In the current \asprin\ implementation, 
the system only exits after finding a first answer set of the base program.}
For coherence, the corresponding rules are also included in the corresponding preference program.
\begin{example}
The preference program (\attach{examples/subset.lp}{\code{subset.lp}})
includes the following rules to define the admissibility of \code{subset} preference statements:
%
\lstinputlisting[basicstyle=\small\ttfamily,numbers=none,firstline=6,lastline=19]{examples/subset.lp}
%
The first rule checks preference elements containing naming atoms, 
the second the ones containing weights, 
and the third one those that contain more than one Boolean formula.
Function \code{@cat(*args)} is provided by \asprin\ and simply concatenates the terms passed as arguments.
\end{example}

\begin{note}
The predicate \code{\_error/1} must be defined using domain predicates, built-ins or the special 
predicates \code{preference/2}, \code{preference/5} and \code{optimize/1} 
(not using \code{holds/1} or \code{holds'/1}).
%In this way, the predicate may be fully evaluated by the grounder.
\end{note}

\comc{Implementing composite preferences.}{T2R: ?? \par J: Now I can go through it :)}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
