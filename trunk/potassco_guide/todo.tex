\section{TODO}
\com{TODO}
\begin{itemize}
% \item clingo
%   \begin{itemize}
%   \item Python/Lua
%   \item etc
%   \end{itemize}
% \item domains heuristic
%   \begin{itemize}
%   \item options
%   \item heuristic
%   \end{itemize}
% \item meta-programming
% \item CSP \$
% \item abstract for laymen
% \item more prominent mention of AG (large subset of syntex and semantics precisely described)
% \item remark and example environment
% \item use comparison predicates in aggregates rather than identical lower and upper bounds
\item restructure index (lowercase, structure see lp)
%%% \item section disjunctive modeling (do book)
% \item quoting of expressions/symbols (double quotes, punctuation)
\item homogeneous style for schematics in language section
\item the language section uses very often: ``gringo and the grounding component of clingo''
\item Vladimir's comments
\begin{itemize}
 \item 
  The symbols \code{\#sup} and \code{\#inf} are new to me, is this a recent addition to the
  language?  Is it really true that \code{\#sup>f(\#sup)}, but \code{\#inf<f(\#inf)}?
  The explanation of these symbols at the bottom of page 13 is cryptic, I’m
  afraid, unless you say there that a total order on variable-free terms is
  going to be inroduced later.
  \comment{RK: I agree that it is not obvious to the reader why the two symbols are introduced their.
    But we have a forward reference to the aggregate section where their use is described.}
 \item
  The discussion of terms in Sec. 3.1.1 gives the impression that Fig. 2 is a
  complete description of the syntax of terms.  It would be good to say here
  that the definition of a term will be extended later, when arithmetic
  operations and intervals are introduced.  In fact, Fig. 2 defines something
  close to what we call “precomputed” terms in the AG paper.  It may be
  worthwhile to include this (or similar) name for the class of terms covered
  by Fig. 2, for the following reason.  The total order that you talk about
  in Sec. 3.1.7 is not defined actually on all variable-free terms; it is
  defined on *precomputed* variable free terms.  Once we decided whether f(a)
  is greater than g(2), we are committed to the same choice regarding f(a)
  and g(1+1), and regarding g(1..1), right?
  \comment{RK: I disscussed this with Martin. 
      When variable-free terms are introduced, they contain neither arithmetics, pools, or intervals.
      The order among variables is introduced along with comparison literals, 
      where we mention that terms are compared after evaluating arithmetic functions.
      Our conclusion was to not introduce auxiliary notions to keep the guide simple.}
 % \item
 %  Will the reader understand “cannot span positive cycles” and “induces no
 %  positive cycle” in Sec. 3.1.4?  Unfortunately, I don't know what to
 %  suggest.
  \end{itemize}
\item Christoph's comments
  \begin{itemize}
  \item 
    I have one comment regarding the future work section where it says that it
    is considered to add "support for arbitrary positive loops". Since the
    second half of the sentence talks about redefining atoms in incremental
    programs, I was wondering if these two features are meant to be used
    together, i.e., redefining atoms in a cyclic fashion (which would
    contradict the outcome of our discussion after Cristina's defense). If not,
    then it should be clarified which kind of positive loops are meant here
    since most positive loops are already supported (maybe over aggregates?).
  \item 
    Another question concerns Section 3.1.11 (conditional literals), where I
    was wondering how the rule would be instantiated if person(jane) and
    person(john) were no fact but derivable atoms. Then meet would only depend
    on the available atoms whose corresponding person atoms are currently true.
    Maybe one should give another example which demonstrates this. (My idea
    would be to use default-negation to derive an intermediate atom if there is
    a person who is not available, and then use another default-negation to
    check if this atom is not true.).
\end{itemize}
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guide"
%%% End: 
